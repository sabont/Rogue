module Bitmap

class Color( argb:Int32 ) [compound]
  DEFINITIONS
    BLACK       = Color( 0xff000000 )
    BLUE        = Color( 0xff0000FF )
    BROWN       = Color( 0xff882222 )
    CYAN        = Color( 0xff00FFFF )
    DARK_GRAY   = Color( 0xff444444 )
    DARK_GREEN  = Color( 0xff008800 )
    GRAY        = Color( 0xff888888 )
    GREEN       = Color( 0xff00FF00 )
    LIGHT_GRAY  = Color( 0xffCCCCCC )
    LIGHT_GREEN = Color( 0xff88FF88 )
    MAGENTA     = Color( 0xffFF00FF )
    ORANGE      = Color( 0xffFF8800 )
    PINK        = Color( 0xffFFCCCC )
    PURPLE      = Color( 0xff880088 )
    RED         = Color( 0xffFF0000 )
    ROGUE_BLUE  = Color( 0xff3333FF )
    ROYAL_BLUE  = Color( 0xff4169E1 )
    SKY_BLUE    = Color( 0xff87CEEB )
    TRANSPARENT = Color( 0 )
    YELLOW      = Color( 0xffFFFF00 )
    WHITE       = Color( 0xffFFFFFF )

  GLOBAL METHODS
    method create( r:Int32, g:Int32, b:Int32, a=255:Int32 )->Color
      return (a.clamped(0,255):<<:24 | r.clamped(0,255):<<:16 | g.clamped(0,255):<<:8 | b.clamped(0,255))

    method create( r:Real64, g:Real64, b:Real64, a=1.0:Real64 )->Color
      return Color( (r*255)->Int32, (g*255)->Int32, (b*255)->Int32, (a*255)->Int32 )

  METHODS
    method alpha->Real64
      return ((argb :>>: 24) & 255) / 255.0

    method alpha_byte->Int32
      return (argb :>>: 24) & 255

    method alpha_premultiplied->Color
      local a = alpha_byte
      return Color( (red_byte*a)/255, (green_byte*a)/255, (blue_byte*a)/255, a )

    method alpha_unmultiplied->Color
      local a = alpha_byte
      if (a == 0) return Color(0)
      return Color( (red_byte*255)/a, (green_byte*255)/a, (blue_byte*255)/a, a )

    method blue->Real64
      return (argb & 255) / 255.0

    method blue_byte->Int32
      return argb & 255

    method green->Real64
      return ((argb :>>: 8) & 255) / 255.0

    method green_byte->Int32
      return (argb :>>: 8) & 255

    method hash_code->Int32
      return argb

    method is_opaque->Logical
      return ((argb & 0xFF000000) == 0xFF000000)

    method operator*( other:Color )->Color
      local a = other.alpha
      local inverse_a = 1.0 - a
      local r = red * inverse_a   + other.red *a
      local g = green * inverse_a + other.green *a
      local b = blue * inverse_a  + other.blue *a
      return Color( r, g, b, alpha*inverse_a+a )

    method operator&( n:Int32 )->Color
      return Color( argb & n )

    method operator|( n:Int32 )->Color
      return Color( argb | n )

    method operator!->Color
      return Color( !argb )

    method red->Real64
      return ((argb :>>: 16) & 255) / 255.0

    method red_byte->Int32
      return (argb :>>: 16) & 255

    method with_opacity( a:Real64 )->Color
      return (Int32((argb:>>:24) * a):<<:24) | (argb & 0xffFFff)

    method description->String
      return argb.to_hex_string

    method with_alpha( a:Real64 )->Color
      return with_alpha_byte( (a*255)->Int32 )

    method with_alpha_byte( a:Int32 )->Color
      return Color( (a.clamped(0,255) :<<: 24) | (this.argb & 0xFFffFF) )

endClass


class Colors( a:Color, b:Color, c:Color, d:Color, count=4:Int32 ) [compound]
  GLOBAL METHODS
    method create( color:Color )->Colors
      return Colors( color, color, color, color, 4 )

    method create( a:Color, b:Color )->Colors
      return Colors( a, b, Color(0), Color(0), 2 )

    method create( a:Color, b:Color, c:Color )->Colors
      return Colors( a, b, c, Color(0), 3 )

    method create( color:Int32 )->Colors
      return Colors( Color(color), Color(color), Color(color), Color(color), 4 )

    method create( a:Int32, b:Int32 )->Colors
      return Colors( Color(a), Color(b), Color(0), Color(0), 2 )

    method create( a:Int32, b:Int32, c:Int32 )->Colors
      return Colors( Color(a), Color(b), Color(c), Color(0), 3 )

    method create( a:Int32, b:Int32, c:Int32, d:Int32, count=4:Int32 )->Colors
      return Colors( Color(a), Color(b), Color(c), Color(d), count )

  METHODS
    method is_opaque->Logical
      which (count)
        case 0: return true
        case 1: return ((a.argb & 0xFF000000) == 0xFF000000)
        case 2: return ((a.argb & b.argb & 0xFF000000) == 0xFF000000)
        case 3: return ((a.argb & b.argb & c.argb & 0xFF000000) == 0xFF000000)
        case 4: return ((a.argb & b.argb & c.argb & d.argb & 0xFF000000) == 0xFF000000)
        others: return false
      endWhich

    method is_opaque_white->Logical
      which (count)
        case 0: return true
        case 1: return ((a.argb) == 0xFFFFFFFF)
        case 2: return ((a.argb & b.argb) == 0xFFFFFFFF)
        case 3: return ((a.argb & b.argb & c.argb) == 0xFFFFFFFF)
        case 4: return ((a.argb & b.argb & c.argb & d.argb) == 0xFFFFFFFF)
        others: return false
      endWhich

    method operator&( n:Int32 )->Colors
      return Colors( a.argb&n, b.argb&n, c.argb&n, d.argb&n, count )

    method operator|( n:Int32 )->Colors
      return Colors( a.argb|n, b.argb|n, c.argb|n, d.argb|n, count )

    method operator!->Colors
      return Colors( !a.argb, !b.argb, !c.argb, !d.argb, count )

    method description->String
      which (count)
        case 1: return a->String
        case 2: return "[$,$]" (a,b)
        case 3: return "[$,$,$]" (a,b,c)
        others: return "[$,$,$,$]" (a,b,c,d)
      endWhich

    method with_opacity( opacity:Real64 )->Colors
      if (opacity == 1.0) return this

      which (count)
        case 0: return this
        case 1: return Colors( a.with_opacity(opacity), b, c, d, 1 )
        case 2: return Colors( a.with_opacity(opacity), b.with_opacity(opacity), c, d, 2 )
        case 3: return Colors( a.with_opacity(opacity), b.with_opacity(opacity), c.with_opacity(opacity), d, 3 )
        case 4: return Colors( a.with_opacity(opacity), b.with_opacity(opacity), c.with_opacity(opacity), d.with_opacity(opacity), 4 )
        others: return this
      endWhich
endClass

augment Real64
  METHODS
    method lerp( a:Color, b:Color )->Color
      return Color( this.lerp(a.red,b.red), this.lerp(a.green,b.green), this.lerp(a.blue,b.blue), this.lerp(a.alpha,b.alpha) )
endAugment

augment Random
  METHODS
    method color->Color
      # Returns a color with randomized (r,g,b) values and an
      # alpha of 1.0.
      return Color.create(real64,real64,real64)
endAugment
