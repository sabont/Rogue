class Cmd
  PROPERTIES
    t : Token

  METHODS
    method add_to( statements:CmdStatementList )
      statements.add( this )

    method as_type_context->TypeInfo
      # Used by CmdAccess.execute()/execute_assignment()
      return null

    method is_safely_mutable->Logical
      return false

    method call_prior( scope:Scope )->Cmd
      throw t.error( "Illegal target - 'prior' can only be used to call overridden methods." )

    method cast_to( target_type:Type, scope:Scope, &allow_implicit_narrowing, &is_conversion )->Cmd
      return cast_to( require_type, target_type, scope, allow_implicit_narrowing, is_conversion )

    method cast_to( this_type:Type, target_type:Type, scope:Scope, &allow_implicit_narrowing, &is_conversion )->Cmd
      if (this_type is target_type and not is_conversion) return this

      this_type.organize(scope, t)
      target_type.organize(scope, t)

      if (not is_conversion)
        if (this_type.instance_of(target_type) or (target_type.instance_of(this_type) and allow_implicit_narrowing))
          return CmdCastToType( t, this, target_type )
        endIf
      endIf

      if (this_type.is_primitive and target_type.is_primitive)
        if (not (this_type is Program.type_Logical or target_type is Program.type_Logical))
          return CmdCastToType( t, this, target_type )
        endIf
      endIf

      local m_name = "to_" + target_type.name
      if (this_type.has_method_named(m_name))
        return scope.resolve_call( this_type, CmdAccess(t,this,m_name), true )
      endIf

      if (not target_type.instance_of(this_type) or allow_implicit_narrowing)
        if (target_type.find_method( "init($)"(this_type.name) )...
            or target_type.find_global_method( "create($)"(this_type.name)))
          return CmdAccess( t, target_type.name, CmdArgs(this) ).resolve( scope )
        endIf
      endIf

      if (is_conversion)
        if (this_type is target_type) return this

        if (this_type.instance_of(target_type) or (target_type.instance_of(this_type) and allow_implicit_narrowing))
          return CmdCastToType( t, this, target_type )
        endIf
      endIf

      if (target_type is Program.type_Logical) return CmdLogicalize(t,this)

      if (target_type.is_optional)
        if (this_type is target_type.element_type)
          return CmdAccess( t, "$?"(this_type.name), CmdArgs(this) )
        elseIf (this_type.instance_of(target_type.element_type))
          local as_element_type = cast_to( this_type, target_type.element_type, scope ).resolve( scope )
          return as_element_type.cast_to( target_type, scope, allow_implicit_narrowing, is_conversion )
        elseIf (this_type is Program.type_null)
          return CmdAccess( t, "$?"(this_type.name), CmdArgs() )
        elseIf (this_type.is_primitive)
          return cast_to( target_type.element_type, scope, allow_implicit_narrowing ).resolve(scope).cast_to( target_type, scope, allow_implicit_narrowing )
        endIf
      endIf

      if (target_type.instance_of(this_type))
        throw t.error( 'No $.to->$() conversion method exists - use "<expression>->(as $)" instead.' (this_type,target_type,target_type) )
      endIf

      #{
println StackTrace()
trace Type.configure_chain
trace Type.organize_chain
trace Type.resolve_chain
      }#

      if (this_type.is_aspect) return cast_to( Program.type_Object, target_type, scope, allow_implicit_narrowing, is_conversion )

      throw t.error( "Type $ cannot be cast to required type $." (this_type,target_type) )

    method clone( other:Cmd, clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (other) return other.cloned( clone_args, new_t )
      return null

    method clone( args:CmdArgs, clone_args=null:CloneArgs, new_t=null:Token )->CmdArgs
      if (args) return args.cloned( clone_args, new_t )
      return null

    method clone( statements:CmdStatementList, clone_args=null:CloneArgs, new_t=null:Token )->CmdStatementList
      if (statements) return statements.cloned( clone_args, new_t )
      return null

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      throw t.error( "[INTERNAL] $.cloned() is not implemented." (type_name) )

    method combine_literal_operands( common_type:Type )->Cmd
      return this

    method compile_type->Type
      return type.compile_type

    method dispatch( v:Visitor )->Cmd [propagated]
      return v.visit( this )

    method execute( vm:VM )->Value
      throw t.error( 'Unsupported metacode ($).' (type_name) )

    method execute_assignment( vm:VM, new_value:Value )
      throw t.error( 'Unsupported metacode assignment ($).' (type_name) )

    method exit_scope( scope:Scope )
      noAction

    method find_operation_result_type( left_type:Type, right_type:Type )->Type
      local result = find_common_type( left_type, right_type )
      if (not result) return left_type

      if (result is Program.type_Byte) return Program.type_Int32
      return result

    method find_common_type( left_type:Type, right_type:Type )->Type
      if (left_type is null)  return right_type
      if (right_type is null) return left_type

      if (left_type is right_type) return left_type

      if (left_type.is_optional)
        if (right_type.is_optional)
          local common_type = must_find_common_type( left_type.element_type, right_type.element_type )
          return Program.get_type_reference( t, "$?"(common_type.name) ).organize
        else
          must_find_common_type( left_type.element_type, right_type )  # Just make sure it's possible
          return left_type
        endIf
      elseIf (right_type.is_optional)
        must_find_common_type( left_type, right_type.element_type )
        return right_type
      endIf

      if (left_type.is_primitive)
        if (right_type.is_primitive)
          if (left_type is Program.type_Real64 or right_type is Program.type_Real64) return Program.type_Real64
          if (left_type is Program.type_Real32 or right_type is Program.type_Real32) return Program.type_Real32
          if (left_type is Program.type_Int64 or right_type is Program.type_Int64) return Program.type_Int64
          if (left_type is Program.type_Int32 or right_type is Program.type_Int32) return Program.type_Int32
          if (left_type is Program.type_Character or right_type is Program.type_Character) return Program.type_Character
        endIf
      endIf

      if (left_type.instance_of(right_type)) return right_type
      if (right_type.instance_of(left_type)) return left_type

      return null

    method generates_output->Logical
      return true

    method is_generic_function->Logical
      return false

    method is_global->Logical
      return false

    method must_find_common_type( left_type:Type, right_type:Type )->Type
      local common_type = find_common_type( left_type, right_type )
      if (common_type) return common_type
      throw t.error( "Types $ and $ are incompatible." (left_type,right_type) )

    method implicit_type( scope:Scope )->Type
      return null

    method is_scoped_read_access->Logical
      # Access, ReadLocal, ReadProperty, CallX.
      return false

    method is_literal->Logical
      return false

    method is_literal_number->Logical
      return false

    method require_type_context
      if (type) throw t.error( ''Type name expected, e.g. "$.".'' (type) )
      else       throw t.error( ''Type name expected.'' )

    method require_integer->Cmd
      local _type = type
      if (_type is null or _type is not Program.type_Int32)
        throw t.error( "Int32 value expected." )
      endIf
      return this

    method require_logical( scope:Scope )->Cmd
      if (require_type is not Program.type_Logical)
        return CmdLogicalize( t, this ).resolve( scope )
      endIf
      return this

    method require_type->Type
      local result = type
      if (result is null) throw t.error( "Value expected; this statement or expression does not result in a value." )
      return result

    method require_value->Cmd
      require_type
      return this

    method requires_semicolon->Logical
      return true

    method resolve( scope:Scope )->Cmd
      throw t.error( "[INTERNAL] $.resolve() is not defined." (type_name) )
      return this

    method resolve_assignment( scope:Scope, new_value:Cmd )->Cmd
      throw t.error( "Invalid assignment." )

    method resolve_adjust( scope:Scope, delta:Int32 )->Cmd
      throw t.error( "Invalid target for increment/decrement. ($)" (type_name) )

    method resolve_modify_and_assign( scope:Scope, op:TokenType, new_value:Cmd )->Cmd
      throw t.error( "Invalid assignment." )

    method to->Byte
      return this->Int32->Byte

    method to->Int32
      return 0

    method to->Logical
      return false

    method trace_used_code
      dispatch( TraceUsedCodeVisitor )

    method type->Type
      println StackTrace()
      throw t.error( "[INTERNAL] $.type() is not defined." (type_name) )

endClass

#------------------------------------------------------------------------------
# StatementList
#------------------------------------------------------------------------------
class CmdStatementList : Cmd[]
  GLOBAL PROPERTIES
    current : CmdStatementList

  METHODS
    method init
      init( 0 )

    method init( initial_capacity:Int32)
      prior.init( initial_capacity )

    method init( statement:Cmd )
      init
      if (statement) add( statement )

    method init( statement1:Cmd, statement2:Cmd )
      init
      if (statement1) add( statement1 )
      if (statement2) add( statement2 )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdStatementList
      local result = CmdStatementList( count )
      forEach (cmd in this)
        cmd = cmd.cloned( clone_args, new_t )
        if (cmd ) result.add( cmd )
      endForEach
      return result

    method dispatch( v:Visitor )      [propagated]
      v.visit( this )

    method execute( vm:VM )->Value
      forEach (cmd in this)
        cmd.execute( vm )
      endForEach
      return UndefinedValue

    method execute_with_scope( vm:VM )->Value
      use vm.new_scope
        return execute( vm )
      endUse

    method resolve( scope:Scope )
      local result = CmdStatementList( count )

      local original_body = scope.this_body
      scope.this_body = result

      local original_statement = scope.this_statement

      forEach (cmd in this)
        scope.this_statement = cmd
        cmd = cmd.resolve( scope )
        cmd.add_to( result )
      endForEach

      clear
      add( result )

      forEach (statement in this) statement.exit_scope( scope )

      scope.this_statement = original_statement
      scope.this_body = original_body

    method trace_used_code
      dispatch( TraceUsedCodeVisitor )
endClass


#------------------------------------------------------------------------------
# Args
#------------------------------------------------------------------------------
class CmdArgs : Cmd[]
  METHODS
    method init
      prior.init

    method init( initial_capacity:Int32)
      prior.init( initial_capacity )

    method init( arg:Cmd )
      init
      add( arg )

    method init( arg1:Cmd, arg2:Cmd )
      init
      add( arg1 )
      add( arg2 )

    method init( arg1:Cmd, arg2:Cmd, arg3:Cmd )
      init
      add( arg1 )
      add( arg2 )
      add( arg3 )

    method cloned->CmdArgs
      # Need two cloned() overloads here because this one overrides the base class
      # cloned().
      return cloned( null )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdArgs
      local result = CmdArgs( count )
      forEach (cmd in this) result.add( cmd.cloned( clone_args, new_t ) )
      return result

    method dispatch( v:Visitor ) [propagated]
      v.visit( this )

    method execute( vm:VM )->ValueList
      local result = @[]
      forEach (cmd in this)
        result.add( cmd.execute(vm) )
      endForEach
      return result

    method resolve( scope:Scope )
      forEach (i of this)
        local arg = this[i].resolve( scope )
        this[i] = arg
        arg.require_type.organize(scope,arg.t)
      endForEach

    method trace_used_code
      dispatch( TraceUsedCodeVisitor )
endClass


#------------------------------------------------------------------------------
# Statements
#------------------------------------------------------------------------------
class CmdStatement : Cmd
  METHODS
endClass

class CmdLocalDeclaration : CmdStatement
  PROPERTIES
    local_info          : Local
    skip_initialization : Logical
    discard             : Logical  # we made this just in case but it's no longer needed
    validate_name       : Logical  # check for visible locals with the same name

  METHODS
    method init( t, local_info, skip_initialization=false, discard=false, validate_name=true )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local task_args = clone_args->(as TaskArgs)
      if (task_args)
        local new_value = local_info.initial_value
        if (new_value) new_value = new_value.cloned( clone_args, new_t )
        return task_args.replace_write_local( t, local_info, new_value )
      else
        return CmdLocalDeclaration( t, local_info, skip_initialization, discard, validate_name )
      endIf

    method execute( vm:VM )->Value
      local value = UndefinedValue : Value
      if (not skip_initialization and local_info.initial_value)
        value = local_info.initial_value.execute( vm )
      endIf
      vm.add_local( local_info.name, value )
      return UndefinedValue

    method exit_scope( scope:Scope )
      scope.pop_local

    method resolve( scope:Scope )->Cmd
      if (local_info.initial_value)
        local_info.initial_value = local_info.initial_value.resolve( scope )
        local initial_value_type = local_info.initial_value.require_type
        if (local_info.type is null) local_info.type = initial_value_type
      endIf

      if (local_info.type is null or local_info.type is Program.type_null)
        throw t.error( "Cannot determine the type of the local variable - either assign an initial value (local $ = ...) or assign a type (local $ : Int32)." (local_info.name,local_info.name) )
      endIf

      if (local_info.initial_value)
        local_info.initial_value = local_info.initial_value.cast_to(local_info.type,scope).resolve( scope )
      endIf

      local_info.type.organize(scope, t)
      scope.push_local( local_info, &=validate_name )

      return this

    method to->String
      if (local_info.type)
        return "CmdLocalDeclaration($:$)" (local_info.name,local_info.type.name)
      else
        return "CmdLocalDeclaration($)" (local_info.name)
      endIf

endClass

class CmdMetacodeGlobalDeclaration : CmdStatement
  PROPERTIES
    local_info          : Local

  METHODS
    method init( t, local_info )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdMetacodeGlobalDeclaration( t, local_info )

    method execute( vm:VM )->Value
      local value = UndefinedValue : Value
      if (local_info.initial_value)
        value = local_info.initial_value.execute( vm )
      endIf
      VM.globals[ local_info.name ] = value
      return UndefinedValue

      #{
    method resolve( scope:Scope )->Cmd
      if (local_info.initial_value)
        local_info.initial_value = local_info.initial_value.resolve( scope )
        local initial_value_type = local_info.initial_value.require_type
        if (local_info.type is null) local_info.type = initial_value_type
      endIf

      if (local_info.type is null or local_info.type is Program.type_null)
        throw t.error( "Cannot determine the type of the local variable - either assign an initial value (local $ = ...) or assign a type (local $ : Int32)." (local_info.name,local_info.name) )
      endIf

      if (local_info.initial_value)
        local_info.initial_value = local_info.initial_value.cast_to(local_info.type,scope).resolve( scope )
      endIf

      local_info.type.organize(scope, t)
      scope.push_local( local_info )

      return this
      }#

    method to->String
      if (local_info.type)
        return "CmdMetacodeGlobalDeclaration($:$)" (local_info.name,local_info.type.name)
      else
        return "CmdMetacodeGlobalDeclaration($)" (local_info.name)
      endIf

endClass


class CmdReturn : CmdStatement
  PROPERTIES
    value : Cmd

  METHODS
    method init( t, value=null )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local task_args = clone_args->(as TaskArgs)
      if (task_args)
        return task_args.create_return( t, clone(value,clone_args,new_t) )
      else
        return CmdReturn( t, clone(value,clone_args,new_t) )
      endIf

    method execute( vm:VM )->Value
      throw VMReturnException( ?:{value:value.execute(vm) || UndefinedValue} )

    method resolve( scope:Scope )->Cmd
      if (value)
        if (not scope.this_method.return_type)
          local sig = which{ scope.this_method.signature || scope.this_method.name+"()" }
          throw t.error( "$ is not declared as returning a value." (sig) )
        endIf
        value = value.resolve( scope ).cast_to(scope.this_method.return_type,scope).resolve( scope )

      elseIf (scope.this_method.is_initializer)
        # 'return' -> 'return this'
        value = CmdLiteralThis( t, scope.this_method.type_context ).resolve( scope )
      endIf
      return this

    method to->String
      if (value) return "CmdReturn($)" (value)
      else       return "CmdReturn(nil)"

    method type->Type
      return value.type
endClass


#------------------------------------------------------------------------------
# Control Structures
#------------------------------------------------------------------------------
class CmdControlStructure : CmdStatement
  ENUMERATE
    type_block
    type_contingent
    type_if
    type_else_if  # A nested if/else that was originally an elseIf
    type_temporarily
    type_try
    type_which

    type_first_loop
    type_loop
    type_while
    type_forEach

    type_use

  PROPERTIES
    statements          : CmdStatementList
    control_type        : Int32
    contains_yield      : Logical
    escape_label        : String
    escape_label_used   : Logical
    upkeep_label        : String
    task_escape_section : CmdTaskControlSection
    task_upkeep_section : CmdTaskControlSection
    cloned_command      : CmdControlStructure
    # Allows escape and nextIteration commands to update their target

  METHODS
    method init( t )
      statements = CmdStatementList()

    method requires_semicolon->Logical
      return false

    method set_control_logic( control_structure:CmdControlStructure )->Cmd
      control_type   = control_structure.control_type
      contains_yield = control_structure.contains_yield
      escape_label   = control_structure.escape_label
      upkeep_label   = control_structure.upkeep_label
      return this

endClass


class CmdBlock : CmdControlStructure
  PROPERTIES
    statements : CmdStatementList
    expression_type : Type

  METHODS
    method init( t, control_type=CmdControlStructure.type_block )
      statements = CmdStatementList()

    method init( t, statements, control_type=CmdControlStructure.type_block )

    method init( cmd:Cmd )
      t = cmd.t
      statements = CmdStatementList( cmd )
      control_type = CmdControlStructure.type_block

    method execute( vm:VM )->Value
      return statements.execute_with_scope( vm )

    method type->Type
      return expression_type

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local task_args = clone_args->(as TaskArgs)
      if (task_args and this.contains_yield)
        forEach (statement in statements)
          task_args.add( statement.cloned(task_args) )
        endForEach
        return null
      else
        local result = CmdBlock( t, null )
        result.set_control_logic( this )
        cloned_command = result
        result.statements = statements.cloned( clone_args, new_t )
        return result
      endIf

    method requires_semicolon->Logical
      return false

    method resolve( scope:Scope )->CmdBlock
      scope.control_stack.add( this )

      statements.resolve( scope )

      scope.control_stack.remove_last
      return this

endClass

class CmdTemporarily : Cmd
  PROPERTIES
    target     : Cmd
    temp_value : Cmd
    statements : CmdStatementList

  METHODS
    method init( t, target, temp_value, statements=CmdStatementList() )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdTemporarily
      if (new_t) t = new_t
      return CmdTemporarily( t, target.cloned(clone_args,new_t), temp_value.cloned(clone_args,new_t), statements.cloned(clone_args,new_t) )

    method resolve( scope:Scope )->Cmd
      # Transform
      #   temporarily target = temp_value
      #      ...
      #      return x
      #   endTemporarily
      # ->
      #   block
      #     local auto_old_value = target
      #     target = temp_value
      #
      #     ...
      #     target = auto_old_value; return x
      #     if (no guaranteed return) target = auto_old_value
      #   endBlock
      local cmd_block = CmdBlock( t )
      local v_old = Local( t, Program.create_unique_id, null, target.cloned )
      cmd_block.statements.add( CmdLocalDeclaration(t,v_old) )
      cmd_block.statements.add( CmdAssign(t,target,temp_value) )

      # TODO: replace with return path analysis eventually
      local has_guaranteed_return = false
      forEach (statement in statements)
        if (statement instanceOf CmdReturn)
          has_guaranteed_return = true
          escapeForEach
        endIf
      endForEach

      statements.dispatch( InjectCmdBeforeReturnVisitor(CmdAssign(t,target,CmdAccess(t,v_old))) )
      cmd_block.statements.add( forEach in statements )

      if (not has_guaranteed_return)
        # The "guaranteed return" bit is to avoid a warning about unreachable code
        cmd_block.statements.add( CmdAssign(t,target.cloned,CmdAccess(t,v_old)) )
      endIf

      return cmd_block.resolve( scope )

endClass

class CmdBlockWithLocal : Cmd
  PROPERTIES
    variable_name : String
    expression    : Cmd
    statements    : CmdStatementList

  METHODS
    method init( t, variable_name, expression, statements=CmdStatementList() )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdBlockWithLocal
      if (new_t) t = new_t
      return CmdBlockWithLocal( t, variable_name, clone(expression,clone_args,new_t), statements.cloned(clone_args,new_t) )

    method resolve( scope:Scope )->Cmd
      # Transform
      #   block v = expr
      #      ...
      #   endBlock
      # ->
      #   block
      #     local v = expr
      #     ...
      #   endBlock
      #
      # Transform
      #   block v
      #      ...
      #   endBlock
      # ->
      #   block
      #     local v = v
      #     ...
      #   endBlock
      local cmd_block = CmdBlock( t, statements )
      if (not expression) expression = CmdAccess( t, variable_name )
      local temp = Local( t, Program.create_unique_id, null, expression )
      local v = Local( t, variable_name, null, CmdAccess(t,temp) )
      statements.insert( CmdLocalDeclaration(t,v,&!validate_name) )  # Second command inserted first
      statements.insert( CmdLocalDeclaration(t,temp) ) # First command inserted last
      return cmd_block.resolve( scope )
endClass

class CmdIf : CmdControlStructure
  PROPERTIES
    condition           : Cmd
    else_statements     : CmdStatementList

  METHODS
    method init( t, condition=null, control_type=CmdControlStructure.type_if )
      statements = CmdStatementList()

    method init( t, condition, statements, control_type=CmdControlStructure.type_if )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local task_args = clone_args->(as TaskArgs)
      if (task_args and this.contains_yield)
        local next_section = task_args.create_section
        local end_section = task_args.create_section
        task_escape_section = end_section
        task_args.add_conditional_jump( CmdLogicalNot(t,condition.cloned( clone_args, new_t )), next_section )
        forEach (statement in statements)
          task_args.add( statement.cloned(task_args) )
        endForEach
        task_args.add_jump( t, end_section )
        task_args.begin_section( next_section )

        if (else_statements)
          forEach (statement in else_statements)
            task_args.add( statement.cloned(task_args) )
          endForEach
        endIf

        task_args.add_jump( t, end_section )
        task_args.begin_section( end_section )
        if (end_section.ip < task_args.cmd_task_control.sections.count)
          # We're somewhere in the middle; jump to the end
          task_args.jump_to_new_section( t )
        endIf
        return null

      else
        local result = CmdIf( t, condition.cloned( clone_args, new_t ), control_type )
        result.set_control_logic( this )
        cloned_command = result
        result.statements = statements.cloned( clone_args, new_t )

        result.else_statements = clone( else_statements, clone_args, new_t )

        return result

      endIf

    method execute( vm:VM )->Value
      if (condition.execute(vm)) return statements.execute_with_scope( vm )
      if (else_statements)       return else_statements.execute_with_scope( vm )
      return UndefinedValue

    method resolve( scope:Scope )->Cmd
      condition = condition.resolve( scope )
      condition = condition.require_logical( scope )

      if (condition instanceOf CmdLiteral)
        # If the condition is a literal true or false, clear the statements
        # in the false or true section.  We can't get rid of the 'if' entirely
        # because there might be an escapeIf directive in the remaining code.
        if (condition->Logical) else_statements = null
        else                    statements.clear
      endIf

      scope.control_stack.add( this )
      statements.resolve( scope )
      if (else_statements) else_statements.resolve( scope )

      scope.control_stack.remove_last
      return this

endClass


class CmdWhich : CmdControlStructure
  PROPERTIES
    expression   : Cmd
    cases        : CmdWhichCase[]
    case_others  : CmdWhichCase

  METHODS
    method init( t, expression, cases=CmdWhichCase[], case_others=null, control_type=CmdControlStructure.type_which )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdWhich
      if (new_t) t = new_t
      local result = CmdWhich( t, expression.cloned( clone_args, new_t ), null )
      result.set_control_logic( this )
      cloned_command = result

      local cloned_cases = CmdWhichCase[]( cases.count )
      forEach (c in cases) cloned_cases.add( c.cloned( clone_args, new_t ) )
      result.cases = cloned_cases

      if (case_others) result.case_others = case_others.cloned( clone_args, new_t )
      return result

    method add_case( case_t:Token )->CmdWhichCase
      local result = CmdWhichCase( case_t )
      cases.add( result )
      return result

    method add_case( case_t:Token, condition:Cmd, statement=null:Cmd )->CmdWhichCase
      local result = CmdWhichCase( case_t, CmdArgs(condition) )
      if (statement) result.statements.add( statement )
      cases.add( result )
      return result

    method add_case_others( case_t:Token, statement=null:Cmd )->CmdWhichCase
      local result = CmdWhichCase( case_t )
      if (statement) result.statements.add( statement )
      case_others = result
      return result

    method execute( vm:VM )->Value
      local value = expression.execute( vm )
      forEach (c in cases)
        forEach (condition in c.conditions)
          if (value == condition.execute(vm)) return c.statements.execute_with_scope( vm )
        endForEach
      endForEach
      if (case_others) return case_others.statements.execute_with_scope( vm )
      return UndefinedValue

    method resolve( scope:Scope )->Cmd
      local prev_case : CmdWhichCase
      forEach (which_case in cases)
        which_case.convert_case_next( prev_case )
        prev_case = which_case
      endForEach

      # Need to resolve all the cases and statements before deciding whether
      # to convert this to an if/elseIf block or a Switch.  We'll do Switch
      # if all the cases are literal values and if no case contains a 'yield'.
      scope.control_stack.add( this )

      local enum_type       : Type
      local expression_type : Type
      expression = expression.resolve( scope ).require_value
      expression_type = expression.type
      if (expression_type.is_enum)
        enum_type = expression_type
        expression = CmdAccess( t, expression, "value" ).resolve( scope ).require_value
        expression_type = expression.type
      endIf

      local all_literal_cases = true

      if (expression_type is not Program.type_Int32 and expression_type is not Program.type_Character)
        if (expression_type is Program.type_Byte)
          expression = expression.cast_to(Program.type_Int32,scope).resolve( scope )
        else
          all_literal_cases = false  # prevent conversion to C 'switch'
        endIf
      endIf

      if (enum_type) scope.implicit_types.add( enum_type )

      forEach (c in cases)
        c.resolve_conditions( scope )
        if (all_literal_cases)
          forEach (condition in c.conditions)
            if (not condition.is_literal or condition instanceOf CmdLiteralString)
              all_literal_cases = false
              escapeForEach
            endIf
          endForEach
        endIf
        c.statements.resolve( scope )
      endForEach
      if (case_others)
        case_others.conditions.resolve( scope )
        case_others.statements.resolve( scope )
      endIf

      if (enum_type) scope.implicit_types.remove_last

      scope.control_stack.remove_last()

      # Convert to switch?
      if (all_literal_cases and not this.contains_yield)
        return CmdSwitch( t, expression, cases, case_others ).set_control_logic( this )
      endIf

      local result = CmdBlock( t, CmdControlStructure.type_which )
      result.set_control_logic( this )
      expression = expression.resolve( scope )

      local var_name       : String
      local expression_var : Local
      if (expression instanceOf CmdReadLocal)
        expression_var = expression->(as CmdReadLocal).local_info
        var_name = expression_var.name
      else
        var_name = Program.create_unique_id
        expression_var = Local( t, var_name, expression.require_type, expression )
        result.statements.add( CmdLocalDeclaration(t,expression_var) )
      endIf

      if (cases.count)
        local cmd_if = CmdIf( expression.t, cases.first.as_conditional(var_name), cases.first.statements )
        local cur_if = cmd_if
        forEach (i of cases)
          if (i > 0)
            local c = cases[i]
            local cmd_else_if = CmdIf( c.t, c.as_conditional(var_name), CmdControlStructure.type_else_if )
            cmd_else_if.statements = c.statements

            cur_if.else_statements = CmdStatementList( cmd_else_if )
            cur_if = cmd_else_if
          endIf
        endForEach
        if (case_others)
          cur_if.else_statements = case_others.statements
        endIf
        result.statements.add( cmd_if )

      elseIf (case_others)
        # 'others' statements always happen
        forEach (cmd in case_others.statements) result.statements.add(cmd)
      endIf

      return result.resolve( scope )
endClass


class CmdSwitch : CmdControlStructure
  PROPERTIES
    expression   : Cmd
    cases        : CmdWhichCase[]
    case_others  : CmdWhichCase

  METHODS
    method init( t, expression, cases=CmdWhichCase[], case_others=null, control_type=CmdControlStructure.type_which )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdSwitch
      if (new_t) t = new_t
      local result = CmdSwitch( t, expression.cloned( clone_args, new_t ), null )
      result.set_control_logic( this )
      cloned_command = result

      local cloned_cases = CmdWhichCase[]( cases.count )
      forEach (c in cases) cloned_cases.add( c.cloned( clone_args, new_t ) )
      result.cases = cloned_cases

      if (case_others) result.case_others = case_others.cloned( clone_args, new_t )
      return result

    method execute( vm:VM )->Value
      local value = expression.execute( vm )
      forEach (c in cases)
        forEach (condition in c.conditions)
          if (value == condition.execute(vm)) return c.statements.execute_with_scope( vm )
        endForEach
      endForEach
      if (case_others) return case_others.statements.execute_with_scope( vm )
      return UndefinedValue

    method resolve( scope:Scope )->Cmd
      scope.control_stack.add( this )

      expression = expression.resolve( scope )
      forEach (c in cases)
        c.conditions.resolve( scope )
        c.statements.resolve( scope )
      endForEach
      if (case_others)
        case_others.conditions.resolve( scope )
        case_others.statements.resolve( scope )
      endIf

      scope.control_stack.remove_last()
      return this

endClass

class CmdWhichCase : Cmd
  PROPERTIES
    conditions   : CmdArgs
    statements   : CmdStatementList
    is_case_next : Logical

  METHODS
    method init( t, conditions=CmdArgs(), statements=CmdStatementList(), is_case_next=false )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdWhichCase
      if (new_t) t = new_t
      return CmdWhichCase( t, conditions.cloned( clone_args, new_t ), statements.cloned( clone_args, new_t ), is_case_next )

    method as_conditional( expression_var_name:String )->Cmd
      local cmd : Cmd
      forEach (condition in conditions)
        if (cmd)
          cmd = CmdLogicalOr( t, cmd, CmdCompareEQ(t,CmdAccess(t,expression_var_name),condition) )
        else
          cmd = CmdCompareEQ( t, CmdAccess(t,expression_var_name), condition )
        endIf
      endForEach
      return cmd

    method convert_case_next( previous_case:CmdWhichCase )
      if (not is_case_next) return
      is_case_next = false
      if (previous_case and previous_case.conditions.count)
        conditions.add( CmdAdd(t,previous_case.conditions.last,CmdLiteralInt32(t,1)) )
      else
        conditions.add( CmdLiteralInt32(t,0) )
      endIf

    method description->String
      return "CmdWhichCase($,$$)"(conditions,statements,which{is_case_next:"is_case_next"||""})

    method resolve_conditions( scope:Scope )->CmdWhichCase
      conditions.resolve( scope )
      forEach (condition at index in conditions)
        if (condition.require_type.is_enum)
          local cmd_create_compound = condition->(as CmdCreateCompound)
          if (cmd_create_compound)
            conditions[ index ] = cmd_create_compound.args.first
          else
            conditions[ index ] = CmdAccess( t, condition,"value" )
          endIf
        endIf
      endForEach
      return this


endClass


class CmdContingent : CmdControlStructure
  PROPERTIES
    satisfied_statements   : CmdStatementList
    unsatisfied_statements : CmdStatementList

    satisfied_label        : String
    unsatisfied_label      : String

    satisfied_section   : CmdTaskControlSection
    unsatisfied_section : CmdTaskControlSection

  METHODS
    method init( t, statements=CmdStatementList() )
      control_type = CmdControlStructure.type_contingent

    method cloned( clone_args:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local task_args = clone_args->(as TaskArgs)
      if (task_args and this.contains_yield)
        satisfied_section = task_args.create_section
        unsatisfied_section = task_args.create_section
        local end_section = task_args.create_section
        task_escape_section = end_section

        forEach (statement in statements)
          task_args.add( statement.cloned(task_args) )
        endForEach
        task_args.add_jump( t, satisfied_section )

        task_args.begin_section( satisfied_section )
        if (satisfied_statements)
          forEach (statement in satisfied_statements)
            task_args.add( statement.cloned(task_args) )
          endForEach
        endIf
        task_args.add_jump( t, end_section )

        task_args.begin_section( unsatisfied_section )
        if (unsatisfied_statements)
          forEach (statement in unsatisfied_statements)
            task_args.add( statement.cloned(task_args) )
          endForEach
        endIf
        task_args.add_jump( t, end_section )

        task_args.begin_section( end_section )
        if (end_section.ip < task_args.cmd_task_control.sections.count)
          # We're somewhere in the middle; jump to the end
          task_args.jump_to_new_section( t )
        endIf
        return null

      else
        local result = CmdContingent( t, null )
        result.set_control_logic( this )
        cloned_command = result

        result.statements = statements.cloned( clone_args, new_t )
        result.satisfied_statements = clone( satisfied_statements, clone_args, new_t )
        result.unsatisfied_statements = clone( unsatisfied_statements, clone_args, new_t )

        return result
      endIf

    method execute( vm:VM )->Value
      block
        try
          try
            statements.execute_with_scope( vm )
          catch ( ex:VMContingentSatisfiedException )
            if (satisfied_statements) satisfied_statements.execute_with_scope( vm )
            escapeBlock
          catch ( ex:VMContingentUnsatisfiedException )
            if (unsatisfied_statements) unsatisfied_statements.execute_with_scope( vm )
            escapeBlock
          endTry
          if (satisfied_statements) satisfied_statements.execute_with_scope( vm )

        catch ( esc:VMEscapeException )
          if (esc.control_type == this.control_type)
            escapeBlock
          else
            throw esc
          endIf
        endTry
      endBlock
      return UndefinedValue

    method resolve( scope:Scope )->CmdContingent
      scope.control_stack.add( this )

      if (not escape_label) escape_label = Program.create_unique_id

      statements.resolve( scope )
      if (satisfied_statements)   satisfied_statements.resolve( scope )
      if (unsatisfied_statements) unsatisfied_statements.resolve( scope )

      scope.control_stack.remove_last
      return this

    method set_control_logic( original:CmdControlStructure )->Cmd
      prior.set_control_logic( original )
      satisfied_label   = original->(as CmdContingent).satisfied_label
      unsatisfied_label = original->(as CmdContingent).unsatisfied_label
      return this

endClass


#------------------------------------------------------------------------------
# Loops
#------------------------------------------------------------------------------
class CmdGenericLoop : CmdControlStructure
  PROPERTIES
    control_statements : CmdStatementList
    condition          : Cmd
    upkeep             : CmdStatementList

  METHODS
    method init( t, control_type, condition, statements=CmdStatementList(), upkeep=null, control_statements=null )

    method init( t, control_type, condition, statements=CmdStatementList(), upkeep_cmd:Cmd, control_statements=null )
      if (upkeep_cmd)
        upkeep = CmdStatementList(1)
        upkeep.add( upkeep_cmd )
      endIf

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local task_args = clone_args->(as TaskArgs)
      if (task_args and this.contains_yield)
        # Control variable initialization
        if (control_statements)
          forEach (statement in control_statements)
            task_args.add( statement.cloned(task_args) )
          endForEach
        endIf

        # Termination Test
        local condition_section = task_args.jump_to_new_section(t)
        local after_section = task_args.create_section
        task_escape_section = after_section
        task_upkeep_section = task_args.create_section
        if (condition)
          task_args.add_conditional_jump( CmdLogicalNot(t,clone(condition,clone_args,new_t)), after_section )
        endIf

        # Main Body
        forEach (statement in statements)
          task_args.add( statement.cloned(task_args) )
        endForEach

        task_args.add_jump( t, task_upkeep_section )
        task_args.begin_section( task_upkeep_section )

        # Upkeep
        if (upkeep)
          forEach (statement in upkeep)
            task_args.add( statement.cloned(task_args) )
          endForEach
        endIf

        # Jump back to Termination Test
        task_args.add_jump( t, condition_section )

        task_args.begin_section( after_section )
        if (after_section.ip < task_args.cmd_task_control.sections.count)
          # We're somewhere in the middle; jump to the end
          task_args.jump_to_new_section( t )
        endIf

        return null

      else
        local result = CmdGenericLoop( t, control_type, clone(condition,clone_args,new_t), null )
        result.set_control_logic( this )
        cloned_command = result

        result.statements = statements.cloned( clone_args, new_t )
        result.upkeep = clone( upkeep, clone_args, new_t )

        result.control_statements = clone( control_statements, clone_args, new_t )
        return result
      endIf

    method add_control_var( v:Local )
      if (not control_statements) control_statements = CmdStatementList()
      control_statements.add( CmdLocalDeclaration(v.t,v) )

    method add_upkeep( cmd:Cmd )
      if (not upkeep) upkeep = CmdStatementList()
      upkeep.add( cmd )

    method execute( vm:VM )->Value
      try
        use vm.new_scope
          if (control_statements) control_statements.execute( vm )
          while (not condition or condition.execute(vm)->Logical)
            try
              statements.execute( vm )
            catch ( ex:VMNextIterationException )
            endTry
            if (upkeep) upkeep.execute( vm )
          endWhile
        endUse
      catch ( esc:VMEscapeException )
        if (esc.control_type == this.control_type)
          escapeTry
        else
          throw esc
        endIf
      endTry
      return UndefinedValue

    method resolve( scope:Scope )->Cmd
      scope.control_stack.add( this )
      if (control_statements)
        forEach (i of control_statements)
          control_statements[i] = control_statements[i].resolve( scope )
        endForEach
      endIf

      if (condition) condition = condition.resolve( scope ).require_logical( scope )
      statements.resolve( scope )

      if (upkeep) upkeep.resolve( scope )

      if (control_statements)
        forEach (statement in control_statements) statement.exit_scope( scope )
      endIf

      scope.control_stack.remove_last
      return this

    method to->String
      return "CmdGenericLoop(statements:$ control_statements:$ condition:$ upkeep:$)" (statements,control_statements,condition,upkeep)

endClass

class CmdForEach : CmdControlStructure
  PROPERTIES
    # At most one of control_var_name and control_var_tuple will be set.
    # In the latter case, it's because you're doing a destructuring assignment of the control variable.
    control_var_name    : String
    control_var_tuple   : CmdTuple
    index_var_name      : String
    collection_var_name : String
    collection          : Cmd
    first_cmd           : Cmd
    last_cmd            : Cmd
    step_cmd            : Cmd
    is_foreach_of       : Logical

  METHODS
    method init( t, control_var_name, index_var_name, collection, step_cmd, statements=CmdStatementList(), is_foreach_of=false )
      control_type = CmdControlStructure.type_forEach

    method init( t, control_var_tuple, index_var_name, collection, step_cmd, statements=CmdStatementList(), is_foreach_of=false )
      control_type = CmdControlStructure.type_forEach
      control_var_tuple.synthesize_variables = true

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local result = CmdForEach( t, control_var_name, index_var_name, collection.cloned(clone_args,new_t), clone(step_cmd,clone_args,new_t), null, &=is_foreach_of )
      result.control_var_tuple = clone( control_var_tuple, clone_args, new_t )->(as CmdTuple)
      result.first_cmd = clone( first_cmd, clone_args, new_t )
      result.last_cmd = clone( last_cmd, clone_args, new_t )
      result.set_control_logic( this )
      cloned_command = result

      result.statements = statements.cloned( clone_args, new_t )
      result.collection_var_name = collection_var_name

      return result

    method execute( vm:VM )->Value
      if (control_var_tuple) throw t.error( "TODO: MetaRogue forEach() with destructuring tuple assignment." )

      use vm.new_scope

        local v_control = vm.add_local( ?:{control_var_name||Program.create_unique_id}, UndefinedValue )
        local v_index = vm.add_local( ?:{index_var_name||Program.create_unique_id}, UndefinedValue )
        local v_collection = vm.add_local( ?:{collection_var_name||Program.create_unique_id},
          collection.execute(vm) )
        local obj = v_collection.value->Object
        if (obj is null) throw t.error( "Collection evaluates to null in forEach." )

        try
          local collection_count = vm.object_count( v_collection.value )
          local step_size = ?:{ step_cmd:step_cmd.execute(vm)->Int32 || 1 }

          if (first_cmd)         v_index.value = first_cmd.execute( vm )
          elseIf (step_size > 0) v_index.value = Value(0)
          else                   v_index.value = collection_count - 1

          local last_index : Int32
          if (last_cmd)          last_index = last_cmd.execute( vm )->Int32
          elseIf (step_size > 0) last_index = collection_count - 1
          else                   last_index = 0

          local type = obj.type_info
          local m_at = type.find_method( "at(Int32)" )
          if (not m_at) m_at = type.find_method( "get(Int32)" )
          local p_count = type.find_property( "count" )
          local m_count = type.find_method( "count()" )
          local args = @[ v_collection.value ]
          if (m_at and (m_count or p_count))
            if (step_size > 0)
              while (v_index.value <= last_index)
                try
                  args.add( v_index.value )
                  v_control.value = m_at( args )
                  args.remove_last
                  statements.execute( vm )
                catch ( ex:VMNextIterationException )
                endTry
                v_index.value += step_size
              endWhile
            else
              while (v_index.value >= last_index)
                try
                  args.add( v_index.value )
                  v_control.value = m_at( args )
                  args.remove_last
                  statements.execute( vm )
                catch ( ex:VMNextIterationException )
                endTry
                v_index.value += step_size
              endWhile
            endIf
          else
            if (step_cmd) throw t.error( "Cannot specify a step size for a reader-based forEach." )
            if (first_cmd) throw t.error( "'forEach' cannot specify a 'from' when iterating over a reader-type collection." )
            local m_has_another0 = type.find_method( "has_another()" )
            local m_read = type.find_method( "read()" )
            if (not m_has_another0 or not m_read) throw collection.t.error( "Collection defines neither count()/get() nor has_another()/read()." )
            local m_has_another = m_has_another0.returns<<Logical>>
            local context = @[ Value(obj) ]
            v_index.value = Value(0)
            while (m_has_another(obj))
              try
                v_control.value = m_read( context )
                statements.execute( vm )
              catch ( ex:VMNextIterationException )
              endTry
              ++v_index.value
            endWhile
          endIf
        catch ( esc:VMEscapeException )
          if (esc.control_type == this.control_type)
            escapeTry
          else
            throw esc
          endIf
        endTry
      endUse

      return UndefinedValue

    method resolve( scope:Scope )->Cmd
      scope.control_stack.add( this )

      collection = collection.resolve( scope )
      local collection_type = collection.require_type.organize(scope, t)

      local has_count = (collection_type.find_property("count") or collection_type.find_method("count()"))
      local m_at  = collection_type.find_method("at(Int32)")
      local m_get = collection_type.find_method("get(Int32)")
      local has_get = m_get or m_at

      local step_size = 1
      if (step_cmd)
        step_cmd = step_cmd.resolve( scope )
        local literal_integer_cmd = step_cmd->(as CmdLiteralInt32)
        if (literal_integer_cmd)
          step_size = literal_integer_cmd.value
        else
          throw step_cmd.t.error( "Literal integer value expected." )
        endIf
      endIf

      if (not collection_var_name) collection_var_name = Program.create_unique_id

      if (has_count and has_get)
        if (m_at) m_get = m_at  # prefer at(Int32) over get(Int32)

        collection = collection.resolve( scope )
        local collection_var = Local( t, collection_var_name, collection.require_type, collection )

        if (not index_var_name) index_var_name = Program.create_unique_id
        local index_var = Local( t, index_var_name, Program.type_Int32 )
        local last_var : Local
        if (step_size >= 0)
          if (first_cmd) index_var.initial_value = first_cmd
          else           index_var.initial_value = CmdLiteralInt32( t, 0 )
          last_var = Local( t, Program.create_unique_id, Program.type_Int32 )
          if (last_cmd)
            last_var.initial_value = last_cmd
            last_cmd = CmdReadLocal( t, last_var )
          else
            last_var.initial_value = CmdAccess( t, CmdReadLocal(t,collection_var), "count" )
            last_var.initial_value = CmdSubtract( t, last_var.initial_value, CmdLiteralInt32(t,1) )
            last_cmd = CmdReadLocal( t, last_var )
          endIf
        else
          if (first_cmd)
            index_var.initial_value = first_cmd
          else
            index_var.initial_value = CmdSubtract( t, CmdAccess(t,CmdReadLocal(t,collection_var), "count"), CmdLiteralInt32(t,1) )
          endIf
          if (not last_cmd) last_cmd = CmdLiteralInt32( t, 0 )
        endIf

        local control_var : Local
        if (control_var_name)
          control_var = Local( t, control_var_name )
          control_var.initial_value = CmdAccess( t, CmdReadLocal(t,collection_var), m_get.name, CmdArgs(CmdReadLocal(t,index_var)) )
          statements.insert( CmdLocalDeclaration(control_var.t,control_var) )
        elseIf (control_var_tuple)
          local control_tuple = CmdAssign(control_var_tuple.t, control_var_tuple, ...
            CmdAccess( t, CmdReadLocal(t,collection_var), m_get.name, CmdArgs(CmdReadLocal(t,index_var)) ))
          statements.insert(control_tuple)
        endIf

        local modifier : Cmd
        if (step_size >= -1 and step_size <= 1)
          modifier = CmdStepLocal(t,index_var,step_size)
        elseIf (step_size >= 0)
          modifier = CmdModifyAndAssign(t,CmdAccess(t,index_var.name),TokenType.symbol_plus_equals,CmdLiteralInt32(t,step_size))
        else
          modifier = CmdModifyAndAssign(t,CmdAccess(t,index_var.name),TokenType.symbol_minus_equals,CmdLiteralInt32(t,-step_size))
        endIf

        local condition : Cmd
        if (step_size >= 0) condition = CmdCompareLE( t, CmdReadLocal(t,index_var), last_cmd )
        else                condition = CmdCompareGE( t, CmdReadLocal(t,index_var), last_cmd )

        local result = CmdGenericLoop( t, CmdControlStructure.type_forEach, condition, statements )
        result.set_control_logic( this )
        if (not (is_foreach_of and first_cmd and step_size <= -1))
          # 'forEach (i of list from n step -1)' doesn't need to use 'list' as a control var
          result.add_control_var( collection_var )
        endIf
        result.add_control_var( index_var )
        if (last_var) result.add_control_var( last_var )
        result.add_upkeep( modifier )

        scope.control_stack.remove_last
        return result.resolve( scope )

      else
        # Using read_another:
        #   local reader = expression
        #   local next = reader.read_another
        #   local index  = 0
        #   while (next.exists)
        #     local control_var = next.value
        #     next = reader.read
        #     statements
        #     ++index
        #   endWhile
        #
        # Using has_another+read:
        #   local reader = expression
        #   local index  = 0
        #   while (reader.has_another)
        #     local control_var = reader.read
        #     statements
        #     ++index
        #   endWhile
        if (first_cmd)
          throw first_cmd.t.error( "'forEach' cannot specify a 'from' when iterating over a reader-type collection." )
        endIf

        local m_read_another = collection_type.find_method("read_another()")
        local has_another = (collection_type.find_property("has_another") or collection_type.find_method("has_another()"))
        local m_read  = collection_type.find_method("read()")
        if (not m_read_another and (not has_another or not m_read))
          throw collection.t.error( "Illegal iteration target - forEach requires either an indexed collection (.count, .get/.at), an iterator (.read_another) or a reader (.has_another, .read)." )
        endIf
        if (m_read_another and not m_read_another.return_type) throw collection.t.error( "Target's read_another() method does not return a value." )
        if (m_read and not m_read.return_type) throw collection.t.error( "Target's read() method does not return a value." )
        if (step_cmd)
          throw step_cmd.t.error( "Cannot specify a step size for a reader - only for an indexed collection." )
        endIf

        local reader_var = Local( t, collection_var_name, collection_type, collection  )
        local index_var : Local
        if (index_var_name)
          index_var = Local( t, index_var_name, Program.type_Int32, CmdLiteralInt32(t,0) )
        endIf

        local next_var : Local
        if (m_read_another)
          next_var = Local( t, Program.create_unique_id, null, CmdAccess(t,reader_var.name,"read_another") )
          statements.insert( CmdAssign(t,next_var,CmdAccess(t,reader_var.name,"read_another")) )
          if (control_var_name)
            local control_var = Local( t, control_var_name, null,
            CmdAccess(t,CmdAccess(t,next_var.name),"value")  )
            statements.insert( CmdLocalDeclaration(collection.t,control_var) )
          elseIf (control_var_tuple)
            local control_tuple = CmdAssign(control_var_tuple.t, control_var_tuple, ...
              CmdAccess(t,CmdAccess(t,control_var_name),"value")  )
            statements.insert(control_tuple)
          endIf
        else
          if (control_var_name)
            local control_var = Local( t, control_var_name, m_read.return_type,
              CmdAccess(collection.t,CmdAccess(collection.t,reader_var.name),"read")  )
            statements.insert( CmdLocalDeclaration(collection.t,control_var) )
          elseIf (control_var_tuple)
            local control_tuple = CmdAssign(control_var_tuple.t, control_var_tuple, ...
              CmdAccess(collection.t,CmdAccess(collection.t,reader_var.name),"read")  )
            statements.insert(control_tuple)
          else
            statements.insert( CmdAccess(collection.t,CmdAccess(collection.t,reader_var.name),"read")  )
          endIf
        endIf

        local rt = reader_var.t

        local upkeep : Cmd
        if (m_read_another)
          upkeep = CmdAccess( rt, CmdReadLocal(rt,next_var), "exists" )
        else
          upkeep = CmdAccess( rt, CmdReadLocal(rt,reader_var), "has_another" )
        endIf
        local cmd_loop = CmdGenericLoop( t, CmdControlStructure.type_forEach, upkeep, statements )
        cmd_loop.set_control_logic( this )
        cmd_loop.add_control_var( reader_var )
        if (m_read_another) cmd_loop.add_control_var( next_var )
        if (index_var)
          cmd_loop.add_control_var( index_var )
          cmd_loop.add_upkeep( CmdStepLocal(t,index_var,1) )
        endIf

        scope.control_stack.remove_last
        return cmd_loop.resolve( scope )

      endIf
      return this

endClass


class CmdTry : CmdControlStructure
  PROPERTIES
    catches : CmdCatch[]

  METHODS
    method init( t, statements=CmdStatementList(), catches=CmdCatch[] )
      control_type = type_try

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdTry
      if (new_t) t = new_t
      local result = CmdTry( t, null, null )
      result.set_control_logic( this )
      cloned_command = result

      result.statements = statements.cloned( clone_args, new_t )

      local new_catches = CmdCatch[]
      forEach (c in catches) new_catches.add( c.cloned( clone_args, new_t ) )
      result.catches = new_catches

      return result

    method add_catch( catch_t:Token )->CmdCatch
      local c = CmdCatch( catch_t )
      catches.add( c )
      return c

    method execute( vm:VM )->Value
      try
        statements.execute_with_scope( vm )
        return UndefinedValue
      catch ( ex:VMEscapeException )
        if (ex.control_type == this.control_type) return UndefinedValue
        throw ex
      catch ( ex:Exception )
        forEach (c in catches)
          local catch_type : TypeInfo
          if (c.error_var) catch_type = TypeInfo[ c.error_var.type.name ]
          else             catch_type = <<Exception>>

          if (catch_type and ex.type_info.instance_of(catch_type))
            use vm.new_scope
              local catch_name : String
              if (c.error_var) catch_name = c.error_var.name
              else             catch_name = Program.create_unique_id
              vm.add_local( catch_name, Value(ex) )
              c.statements.execute_with_scope( vm )
            endUse

            return UndefinedValue
          endIf
        endForEach
        throw ex
      endTry

    method resolve( scope:Scope )->Cmd
      scope.control_stack.add( this )

      statements.resolve( scope )
      forEach (c in catches) c.resolve( scope )

      if (contains_yield)
        throw t.error( "try/catch blocks cannot contain 'yield' statements." )
      endIf

      scope.control_stack.remove_last

      return this

endClass

class CmdCatch : Cmd
  PROPERTIES
    # One of the following two will be non-null and the other will be null.
    error_var  : Local # catch(err:Error)
    error_type : Type  # catch(Error)

    statements : CmdStatementList

  METHODS
    method init( t, error_var=null, error_type=null, statements=CmdStatementList() )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdCatch
      if (new_t) t = new_t
      return CmdCatch( t, error_var, error_type, statements.cloned( clone_args, new_t ) )

    method resolve( scope:Scope )->Cmd
      local err_type : Type
      if (error_var)
        err_type = error_var.type.organize( scope, t )
      else
        err_type = error_type.organize( scope, t )
      endIf

      if (not err_type.instance_of(Program.type_Exception))
        throw t.error( "Caught value must be instanceOf class Exception." )
      endIf

      if (error_var)
        scope.push_local( error_var )
        statements.resolve( scope )
        scope.pop_local
      else
        statements.resolve( scope )
      endIf

      return this

endClass

class CmdThrow : Cmd
  PROPERTIES
    expression  : Cmd
    is_resolved : Logical

  METHODS
    method init( t, expression, is_resolved=false )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdThrow
      if (new_t) t = new_t
      return CmdThrow( t, expression.cloned( clone_args, new_t ), is_resolved )

    method execute( vm:VM )->Value
      local ex = expression.execute( vm )->Object->(as Exception)
      if (ex is null)
        throw expression.t.error( "Thrown value must be instanceOf Exception." )
      endIf
      throw ex

    method resolve( scope:Scope )->Cmd
      if (not is_resolved)
        is_resolved = true
        expression = expression.resolve( scope )
        local expression_type = expression.require_type
        expression_type.organize(scope, t)
        if (not expression_type.instance_of(Program.type_Exception))
          throw expression.t.error( "Thrown value must be instanceOf class Error." )
        endIf
        expression = CmdAccess( t, expression, "_throw" ).resolve( scope )
      endIf
      return this

    method type->Type
      return expression.type

endClass

class CmdTryExpression : Cmd
  PROPERTIES
    try_expression  : Cmd
    else_expression : Cmd
    result_var      : Local

  METHODS
    method init( t, try_expression, else_expression, result_var )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdTryExpression( t, try_expression.cloned( clone_args, new_t ), else_expression.cloned( clone_args, new_t ), result_var )

    method execute( vm:VM )->Value
      try
        return try_expression.execute( vm )
      catch (Exception)
        return else_expression.execute( vm )
      endTry

    method implicit_type( scope:Scope )->Type
      return try_expression.implicit_type( scope )

    method resolve( scope:Scope )->Cmd
      try_expression = try_expression.resolve( scope ).require_value
      else_expression = else_expression.resolve( scope ).require_value

      local try_type = try_expression.type

      if (else_expression.type is not try_type)
        else_expression = else_expression.cast_to( try_type, scope ).resolve( scope )
      endIf

      result_var.type = try_type

      local cmd_try = CmdTry( t )
      cmd_try.statements.add( CmdWriteLocal(t, result_var, try_expression) )

      local cmd_catch = cmd_try.add_catch( t )
      cmd_catch.error_type = Program.type_Exception
      cmd_catch.statements.add( CmdWriteLocal(t, result_var, else_expression) )

      return cmd_try.resolve( scope )
endClass

#------------------------------------------------------------------------------
# escape and nextIteration
#------------------------------------------------------------------------------
class CmdEscape : Cmd
  PROPERTIES
    control_type : Int32
    target_cmd   : CmdControlStructure

  METHODS
    method init( t, control_type, target_cmd=null )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      if (target_cmd)
        if (target_cmd.task_escape_section)
          local task_args = clone_args->(as TaskArgs)
          return task_args.create_escape( t, target_cmd.task_escape_section )
        else
          local new_target = target_cmd
          while (new_target.cloned_command) new_target = new_target.cloned_command
          return CmdEscape( t, control_type, new_target )
        endIf
      else
        return ThisType( t, control_type )
      endIf

    method execute( vm:VM )->Value
      throw VMEscapeException( t, control_type )

    method resolve( scope:Scope )->Cmd
      local i = scope.control_stack.count
      while (i > 0)
        --i
        local cmd = scope.control_stack[i]
        if (cmd.control_type == control_type)
          while (cmd.cloned_command) cmd = cmd.cloned_command
          if (not cmd.escape_label) cmd.escape_label = Program.create_unique_id
          cmd.escape_label_used = true
          target_cmd = cmd
          return this
        endIf
      endWhile

      throw t.error( "No enclosing structure to escape." )

endClass


class CmdNextIteration : Cmd
  PROPERTIES
    target_cmd   : CmdControlStructure

  METHODS
    method init( t, target_cmd=null )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      if (target_cmd)
        if (target_cmd.task_upkeep_section)
          local task_args = clone_args->(as TaskArgs)
          return task_args.create_escape( t, target_cmd.task_upkeep_section )
        else
          local new_target = target_cmd
          while (new_target.cloned_command) new_target = new_target.cloned_command
          return CmdNextIteration( t, new_target )
        endIf
      else
        return ThisType( t )
      endIf

    method execute( vm:VM )->Value
      throw VMNextIterationException( t )

    method resolve( scope:Scope )->Cmd
      local i = scope.control_stack.count
      while (i > 0)
        --i
        local cmd = scope.control_stack[i]
        if (cmd.control_type >= CmdControlStructure.type_first_loop)
          while (cmd.cloned_command) cmd = cmd.cloned_command
          if (not cmd.upkeep_label) cmd.upkeep_label = Program.create_unique_id
          target_cmd = cmd
          return this
        endIf
      endWhile

      throw t.error( "No enclosing loop for 'nextIteration' to affect." )

endClass


class CmdNecessary : Cmd
  PROPERTIES
    target_cmd   : CmdContingent
    condition    : Cmd

  METHODS
    method init( t, condition, target_cmd=null )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      if (target_cmd.unsatisfied_section)
        local task_args = clone_args->(as TaskArgs)
        local cmd_jump = task_args.create_escape( t, target_cmd.unsatisfied_section )
        if (condition)
          return CmdIf( t, CmdLogicalNot(t,condition.cloned(task_args)), CmdStatementList(cmd_jump) )
        else
          return cmd_jump
        endIf
      else
        local new_target = target_cmd : CmdControlStructure
        while (new_target.cloned_command) new_target = new_target.cloned_command
        return CmdNecessary(t, clone(condition,clone_args,new_t), new_target->(as CmdContingent))
      endIf

    method execute( vm:VM )->Value
      if (not condition.execute(vm)->Logical) throw VMContingentUnsatisfiedException(t)
      return UndefinedValue

    method resolve( scope:Scope )->Cmd
      if (condition) condition = condition.resolve( scope )

      local i = scope.control_stack.count
      while (i > 0)
        --i
        local cmd = scope.control_stack[i]
        if (cmd.control_type == CmdControlStructure.type_contingent)
          while (cmd.cloned_command) cmd = cmd.cloned_command
          local cmd_contingent = cmd->(as CmdContingent)
          if (not cmd_contingent.unsatisfied_label) cmd_contingent.unsatisfied_label = Program.create_unique_id
          target_cmd = cmd_contingent
          return this
        endIf
      endWhile

      throw t.error( "No enclosing contingent." )

endClass


class CmdSufficient : Cmd
  PROPERTIES
    target_cmd   : CmdContingent
    condition    : Cmd

  METHODS
    method init( t, condition, target_cmd=null )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      if (target_cmd.satisfied_section)
        local task_args = clone_args->(as TaskArgs)
        local cmd_jump = task_args.create_escape( t, target_cmd.satisfied_section )
        if (condition)
          return CmdIf( t, condition.cloned(task_args), CmdStatementList(cmd_jump) )
        else
          return cmd_jump
        endIf
      else
        local new_target = target_cmd : CmdControlStructure
        while (new_target.cloned_command) new_target = new_target.cloned_command
        return CmdSufficient(t, clone(condition,clone_args,new_t), new_target->(as CmdContingent))
      endIf

    method execute( vm:VM )->Value
      if (condition.execute(vm)->Logical) throw VMContingentSatisfiedException(t)
      return UndefinedValue

    method resolve( scope:Scope )->Cmd
      if (condition) condition = condition.resolve( scope )

      local i = scope.control_stack.count
      while (i > 0)
        --i
        local cmd = scope.control_stack[i]
        if (cmd.control_type == CmdControlStructure.type_contingent)
          while (cmd.cloned_command) cmd = cmd.cloned_command
          local cmd_contingent = cmd->(as CmdContingent)
          if (not cmd_contingent.satisfied_label) cmd_contingent.satisfied_label = Program.create_unique_id
          target_cmd = cmd_contingent
          return this
        endIf
      endWhile

      throw t.error( "No enclosing contingent." )

endClass

#------------------------------------------------------------------------------
# Literals
#------------------------------------------------------------------------------
class CmdLiteral : Cmd
  METHODS
    method implicit_type( scope:Scope )->Type
      return type

    method is_literal->Logical
      return true

endClass

class CmdLiteralNull : CmdLiteral
  METHODS
    method init( t )

    method cast_to( target_type:Type, scope:Scope, &allow_implicit_narrowing, &is_conversion )->Cmd
      if (target_type.is_optional)
        return CmdAccess( t, "$?"(target_type.element_type.name), CmdArgs() )
      else
        return prior.cast_to( target_type, scope )
      endIf

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLiteralNull( t )

    method execute( vm:VM )->Value
      return NullValue

    method resolve( scope:Scope )->this
      return this

    method to->String
      return "null"

    method type->Type
      return Program.type_null
endClass

class CmdDefaultValue : CmdLiteral
  PROPERTIES
    of_type : Type

  METHODS
    method init( t, of_type )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdDefaultValue( t, of_type )

    method execute( vm:VM )->Value
      if (of_type is Program.type_Logical) return Value(false)
      if (of_type.is_primitive) return Value(0)
      return Value(null)

    method is_literal_number->Logical
      if (not of_type.is_primitive) return false
      if (of_type is Program.type_Logical) return false
      return true

    method resolve( scope:Scope )->Cmd
      of_type.organize(scope, t)
      local default_value = of_type.create_default_value( t )
      if (of_type.is_reference)
        return CmdCastToType( t, default_value, of_type )
      else
        return default_value
      endIf

    method type->Type
      return of_type
endClass

class CmdLiteralNumber : CmdLiteral
  METHODS
    method is_literal_number->Logical
      return true
endClass

class CmdLiteralReal64 : CmdLiteralNumber
  PROPERTIES
    value : Real64

  GLOBAL METHODS
    method create_infinity( t:Token )->this
      return CmdLiteralReal64(t, native("ROGUE_R64_INFINITY")->Real64)

    method create_NaN( t:Token )->this
      return CmdLiteralReal64(t, native("ROGUE_R64_NAN")->Real64)

  METHODS
    method init( t, value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLiteralReal64( t, value )

    method cast_to( target_type:Type, scope:Scope, &allow_implicit_narrowing, &is_conversion )->Cmd
      if (target_type is Program.type_Real32)
        return CmdLiteralReal32( t, value )
      elseIf (target_type is Program.type_Int64)
        return CmdLiteralInt64( t, value )
      elseIf (target_type is Program.type_Int32)
        return CmdLiteralInt32( t, value )
      elseIf (target_type is Program.type_Character)
        return CmdLiteralCharacter( t, value )
      elseIf (target_type is Program.type_Byte)
        return CmdLiteralByte( t, value )
      else
        return prior.cast_to( target_type, scope )
      endIf

    method execute( vm:VM )->Value
      return Value( value )

    method resolve( scope:Scope )->Cmd
      return this

    method to->Int32
      return value->Int32

    method to->Logical
      return value?

    method to->String
      return value

    method type->Type
      return Program.type_Real64
endClass


class CmdLiteralReal32 : CmdLiteralNumber
  PROPERTIES
    value : Real32

  METHODS
    method init( t, value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLiteralReal32( t, value )

    method cast_to( target_type:Type, scope:Scope, &allow_implicit_narrowing, &is_conversion )->Cmd
      if (target_type is Program.type_Real64)
        return CmdLiteralReal64( t, value )
      elseIf (target_type is Program.type_Int64)
        return CmdLiteralInt64( t, value )
      elseIf (target_type is Program.type_Int32)
        return CmdLiteralInt32( t, value )
      elseIf (target_type is Program.type_Character)
        return CmdLiteralCharacter( t, value )
      elseIf (target_type is Program.type_Byte)
        return CmdLiteralByte( t, value )
      else
        return prior.cast_to( target_type, scope )
      endIf

    method execute( vm:VM )->Value
      return Value( value )

    method resolve( scope:Scope )->Cmd
      return this

    method to->Int32
      return value->Int32

    method to->Logical
      return value?

    method to->String
      return value

    method type->Type
      return Program.type_Real32
endClass


class CmdLiteralInt64 : CmdLiteralNumber
  PROPERTIES
    value : Int64

  METHODS
    method init( t, value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLiteralInt64( t, value )

    method cast_to( target_type:Type, scope:Scope, &allow_implicit_narrowing, &is_conversion )->Cmd
      if (target_type is Program.type_Real64)
        return CmdLiteralReal64( t, value )
      elseIf (target_type is Program.type_Real32)
        return CmdLiteralReal32( t, value )
      elseIf (target_type is Program.type_Int32)
        return CmdLiteralInt32( t, value )
      elseIf (target_type is Program.type_Character)
        return CmdLiteralCharacter( t, value )
      elseIf (target_type is Program.type_Byte)
        return CmdLiteralByte( t, value )
      else
        return prior.cast_to( target_type, scope )
      endIf

    method execute( vm:VM )->Value
      return Value( value )

    method resolve( scope:Scope )->Cmd
      return this

    method to->Int32
      return value->Int32

    method to->Logical
      return value?

    method to->String
      return value

    method type->Type
      return Program.type_Int64
endClass


class CmdLiteralInt32 : CmdLiteralNumber
  PROPERTIES
    value : Int32

  METHODS
    method init( t, value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLiteralInt32( t, value )

    method cast_to( target_type:Type, scope:Scope, &allow_implicit_narrowing, &is_conversion )->Cmd
      if (target_type is Program.type_Real64)
        return CmdLiteralReal64( t, value )
      elseIf (target_type is Program.type_Real32)
        return CmdLiteralReal32( t, value )
      elseIf (target_type is Program.type_Int64)
        return CmdLiteralInt64( t, value )
      elseIf (target_type is Program.type_Character)
        return CmdLiteralCharacter( t, value )
      elseIf (target_type is Program.type_Byte)
        return CmdLiteralByte( t, value )
      else
        return prior.cast_to( target_type, scope )
      endIf

    method execute( vm:VM )->Value
      return Value( value )

    method resolve( scope:Scope )->Cmd
      return this

    method to->Int32
      return value

    method to->Logical
      return value?

    method to->String
      return value

    method type->Type
      return Program.type_Int32
endClass


class CmdLiteralCharacter : CmdLiteralNumber
  PROPERTIES
    value : Character

  METHODS
    method init( t, value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLiteralCharacter( t, value )

    method cast_to( target_type:Type, scope:Scope, &allow_implicit_narrowing, &is_conversion )->Cmd
      if (target_type is Program.type_Real64)
        return CmdLiteralReal64( t, value )
      elseIf (target_type is Program.type_Real32)
        return CmdLiteralReal32( t, value )
      elseIf (target_type is Program.type_Int64)
        return CmdLiteralInt64( t, value )
      elseIf (target_type is Program.type_Int32)
        return CmdLiteralInt32( t, value )
      elseIf (target_type is Program.type_Byte)
        return CmdLiteralByte( t, value )
      else
        return prior.cast_to( target_type, scope )
      endIf

    method execute( vm:VM )->Value
      return Value( value )

    method resolve( scope:Scope )->Cmd
      return this

    method to->Int32
      return value->Int32

    method to->Logical
      return value?

    method to->String
      return value

    method type->Type
      return Program.type_Character
endClass

class CmdLiteralByte : CmdLiteralNumber
  PROPERTIES
    value : Byte

  METHODS
    method init( t, value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLiteralByte( t, value )

    method cast_to( target_type:Type, scope:Scope, &allow_implicit_narrowing, &is_conversion )->Cmd
      if (target_type is Program.type_Real64)
        return CmdLiteralReal64( t, value )
      elseIf (target_type is Program.type_Real32)
        return CmdLiteralReal32( t, value )
      elseIf (target_type is Program.type_Int64)
        return CmdLiteralInt64( t, value )
      elseIf (target_type is Program.type_Int32)
        return CmdLiteralInt32( t, value )
      elseIf (target_type is Program.type_Character)
        return CmdLiteralCharacter( t, value )
      else
        return prior.cast_to( target_type, scope )
      endIf

    method execute( vm:VM )->Value
      return Value( value )

    method resolve( scope:Scope )->Cmd
      return this

    method to->Int32
      return value->Int32

    method to->Logical
      return value?

    method to->String
      return value

    method type->Type
      return Program.type_Byte
endClass



class CmdLiteralLogical : CmdLiteral
  PROPERTIES
    value : Logical

  METHODS
    method init( t, value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLiteralLogical( t, value )

    method execute( vm:VM )->Value
      return Value( value )

    method resolve( scope:Scope )->Cmd
      return this

    method to->Int32
      return which{ value:1 || 0 }

    method to->Logical
      return value?

    method to->String
      return value

    method type->Type
      return Program.type_Logical
endClass


class CmdLiteralString : CmdLiteral
  PROPERTIES
    value : String
    index : Int32

  METHODS
    method init( t, value, index=0 )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLiteralString( t, value, index )

    method execute( vm:VM )->Value
      return Value( value )

    method resolve( scope:Scope )->Cmd
      Program.type_String.resolve
      return this

    method to->Logical
      return value?

    method to->String
      return value

    method type->Type
      return Program.type_String
endClass

class CmdFormattedString : Cmd
  PROPERTIES
    format : String
    args   : CmdArgs

  METHODS
    method init( t, format, args )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdFormattedString( t, format, args.cloned( clone_args, new_t ) )

    method execute( vm:VM )->Value
      use builder=StringBuilder.pool
        local arg_i = 0
        forEach (ch in format)
          if (ch == '$')
            if (arg_i < args.count)
              builder.print( args[arg_i].execute(vm)->String )
              ++arg_i
            else
              throw t.error( "More format markers ('$') than arguments in formatted string." )
            endIf
          else
            builder.print( ch )
          endIf
        endForEach
        if (arg_i < args.count)
          throw t.error( "More arguments than format markers ('$') in formatted string." )
        endIf
        return Value( builder->String )
      endUse

    method implicit_type( scope:Scope )->Type
      return Program.type_String

    method resolve( scope:Scope )->Cmd
      local cmd = CmdAccess( t, "StringBuilder", CmdArgs() )
      local fmt = format
      forEach (arg in args)
        arg = arg.resolve(scope).require_value
        local i = locate_marker( fmt )
        if (not i) throw t.error( "More arguments than format markers ('$') in formatted string." )
        if (i.value > 0)
          cmd = CmdAccess( t, cmd, "print", CmdArgs(CmdLiteralString(t,fmt.leftmost(i.value))) )
          fmt = fmt.from(i.value+1)
        else
          fmt = fmt.from(1)
        endIf
        cmd = CmdAccess( t, cmd, "print", CmdArgs(CmdAdd(t,CmdLiteralString(t,""),arg)) )
      endForEach
      if (fmt.count)
        if (locate_marker(fmt))
          throw t.error( "More format markers ('$') than arguments in formatted string." )
        endIf
        cmd = CmdAccess( t, cmd, "print", CmdArgs(CmdLiteralString(t,fmt)) )
      endIf

      return cmd.resolve( scope ).cast_to( Program.type_String, scope ).resolve( scope )

    method locate_marker( fmt:String )->Int32?
      return fmt.locate( '$' )

    method type->Type
      return Program.type_String
endClass

class CmdNamedArg : Cmd
  PROPERTIES
    name           : String
    value          : Cmd
    is_negative    : Logical
    inferred_index : Int32?

  METHODS
    method init( t, name, value=null, is_negative=false )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->CmdNamedArg
      if (new_t) t = new_t
      return CmdNamedArg( t, name, clone(value), is_negative )

    method to->String
      return name

    method to_value->Cmd
      if (value)
        if (is_negative) throw t.error( "Invalid negation of a named parameter with a supplied value." )
        return value
      else
        if (is_negative) return CmdLiteralLogical( t, false )
        else             return CmdLiteralLogical( t, true )
      endIf
endClass

#------------------------------------------------------------------------------
# Access
#------------------------------------------------------------------------------
class CmdAccess : Cmd
  PROPERTIES
    context      : Cmd
    name         : String
    args         : CmdArgs
    named_args   : CmdNamedArg[]
    used_modules : UsedModule
    #debug : Logical

  METHODS
    method init( t, name )

    method init( t, name, args )

    method init( t, name, arg:Cmd )
      args = CmdArgs( arg )

    method init( t, name, args, named_args )

    method init( t, context, name )

    method init( t, context, name, args )

    method init( t, context, name, args, named_args )

    method init( t, context, name, arg:Cmd )
      args = CmdArgs()
      args.add( arg )

    method init( t, context_name:String, name )
      context = CmdAccess( t, context_name )

    method init( t, context_name:String, name, arg:Cmd )
      context = CmdAccess( t, context_name )
      args = CmdArgs( arg )

    method init( t, context_name:String, name, args )
      context = CmdAccess( t, context_name )

    method init( t, local_info:Local )
      init( t, local_info.name )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local result = CmdAccess( t, clone(context,clone_args), name, clone(args,clone_args,new_t) )

      if (named_args)
        result.named_args = CmdNamedArg[]( named_args.count )
        forEach (named_arg in named_args) result.named_args.add( named_arg.cloned )
      endIf

      local macro_args = clone_args->(as MacroArgs)
      if (macro_args)
        return macro_args.inline_access( result )
      endIf

      result.used_modules = used_modules

      return result

    method as_type_context->TypeInfo
      # Used by CmdAccess.execute()/execute_assignment()
      if (context) return null
      if (args)    return null
      return TypeInfo[ name ]

    method execute( vm:VM )->Value
      # Explicit context
      if (context)
        local context : Value
        local obj : Object
        local type = this.context.as_type_context
        if (type)
          # TypeName.xyz - singleton or global reference
          if (type.is_singleton) obj = type.singleton
        else
          context = this.context.execute( vm )
          if (context.is_object or context.is_string)
            obj = context->Object
            type = obj.type_info
          elseIf (context.is_number)
            obj = context
            if (context->Real64.fractional_part) type = <<Real64>>
            else                                 type = <<Int32>>
          elseIf (context.is_logical)
            obj = context
            type = <<Logical>>
          endIf
        endIf

        if (type)
          local args = ?:{ args:args.execute(vm) || @[] }

          local m : MethodInfo
          if (obj)
            if (args.count) m = find_method_by_arg_types( type.methods, name, args )
            if (m is null)  m = type.find_method( name, args.count )  # then search by name & parameter count
            if (m is null)  m = type.find_method( name ) # finally just the name
            if (m)
              ensure context( obj )
              args.insert( context )
              local result = m( args )
              args.remove_first
              return result
            endIf
            local p = type.find_property( name )
            if (p) return type.property( obj, p )
          endIf

          if (not m)
            if (args.count) m = find_method_by_arg_types( type.global_methods, name, args )
            if (m is null)  m = type.find_global_method( name, args.count )
            if (m is null)  m = type.find_global_method( name )
            if (m) return m( args )
            local p = type.find_global_property( name )
            if (p) return type.global_property( p )
            throw t.error( "Reference to undefined method or property $.$." (type.name,name) )
          endIf
        endIf

      else
        # No context given

        # Check for built-in command
        which (name)
          case "MetaError"
            if (args and args.count)
              throw t.error( args.first.execute(vm)->String ).as_metacode_error
            else
              throw t.error( "Unspecified error." ).as_metacode_error
            endIf

          case "print"
            if (args)
              forEach (arg in args) print arg.execute( vm )
            endIf
            return UndefinedValue

          case "println"
            if (args)
              forEach (arg in args) print arg.execute( vm )
            endIf
            println
            return UndefinedValue

          case "source"
            if (args)
              forEach (arg in args) vm.inject.print( arg.execute(vm)->String )
            endIf
            return UndefinedValue

          case "sourceln"
            if (args)
              forEach (arg in args) vm.inject.print( arg.execute(vm)->String )
            endIf
            vm.inject.println
            return UndefinedValue

          case "compileSource"
            if (vm.inject.count)
              local new_filepath = "$ - Meta:$" (vm.t.filepath,vm.t.line)
              local source = vm.inject->String
              vm.inject.clear
              RogueC.parse( new_filepath, source )
            endIf
            return UndefinedValue

          case "t"
            if (not args)
              return Value(t)
            endIf
        endWhich

        # Check locals
        local v = vm.find_local( name )
        if (v)
          return v.value
        endIf

        # Check globals
        if (VM.globals.contains(name))
          return VM.globals[ name ]
        endIf

        # Access is type name - global access or singleton
        local type = TypeInfo[ name ]
        if (type)
          if (args)
            local args = args.execute( vm )
            local obj = type.create_object
            local m : MethodInfo
            if (args.count) m = find_method_by_arg_types( type.methods, "init", args )
            if (m is null) type.find_method( "init", args.count )
            if (m is null) m = type.find_method( "init" )  # omit arg requirements
            if (m) return m( obj, args )
            else   return Value( obj )
          elseIf (name.ends_with("[]"))
            return Value( type.create_object )
          elseIf (type.is_singleton)
            return Value( type.singleton )
          else
            local n = type.name
            throw t.error( "$ is not a singleton type - use $(...) to create a new $ object." (n,n,n) )
          endIf
        endIf

        # Check implicit context of VM execution context
        type = vm.context.type_info
        local m = type.find_method( name, ?:{args:args.count || 0} )
        if (m is null) m = type.find_method( name )
        if (m)
          local args = ?:{ args:args.execute(vm) || @[] }
          return m( vm.context, args )
        endIf
        local p = type.find_property( name )
        if (p) return type.property( vm.context, p )

        m = type.find_global_method( name, ?:{args:args.count || 0} )
        if (m is null) m = type.find_global_method( name )
        if (m)
          local args = ?:{ args:args.execute(vm) || @[] }
          return m( args )
        endIf
        p = type.find_global_property( name )
        if (p) return type.global_property( p )

      endIf
      throw t.error( ''Can't resolve metacode reference to "$".'' (name) )

    method find_method_by_arg_types( methods:MethodInfo[], name:String, args:Value )->MethodInfo
      forEach (m in methods)
        if (m.name == name)
          if (m.parameter_count >= args.count)
            contingent
              forEach (index in 0..<m.parameter_count.or_smaller(args.count))
                necessary (m.parameter_type(index).name == args[index].datatype)
              endForEach
              return m
            endContingent
          endIf
        endIf
      endForEach
      return null

    method execute_assignment( vm:VM, new_value:Value )
      if (context)
        if (args is null)
          local context : Value
          local obj : Object
          local type = this.context.as_type_context
          if (type)
            # TypeName.xyz - singleton or global reference
            if (type.is_singleton) obj = type.singleton
          else
            context = this.context.execute( vm )
            if (context.is_object or context.is_string)
              obj = context->Object
              type = obj.type_info
            endIf
          endIf

          local m : MethodInfo
          local p : PropertyInfo
          if (obj)
            m = type.find_method( "set_" + name, 1 )
            if (m is null)
              p = type.find_property( name )
              if (p)
                type.set_property( obj, p, new_value )
                return
              endIf
            endIf
          endIf

          if (not m)
            m = type.find_global_method( "set_" + name, 1 )
            if (m is null)
              p = type.find_global_property( name )
              if (p)
                type.set_global_property( p, new_value )
                return
              endIf
              throw t.error( "Reference to undefined property $.$." (type.name,name) )
            endIf
          endIf

          local args = ?:{ args:args.execute(vm) || @[] }
          ensure context( obj )
          args.insert( context )
          m( args )
          return
        endIf

      else
        local v = vm.find_local( name )
        if (v)
          v.value = new_value
          return
        endIf

        if (VM.globals.contains(name))
          VM.globals[ name ] = new_value
          return
        endIf

        local type = TypeInfo[ name ]
        if (type and not args and type.is_singleton)
          type.set_singleton( new_value->Object )
        endIf
      endIf
      throw t.error( "Invalid assignment." )

    method implicit_type( scope:Scope )->Type
      if (context)
        local context_type = context.implicit_type( scope )
        if (context_type and context_type.is_enum)
          if (Program.is_resolving)
            # Can safely configure
            context_type.configure( scope )
            if (context_type.categories)
              if ((forEach in context_type.categories).name == name) return context_type
            endIf
          # else still parsing
          endIf
        endIf
        return null
      endIf

      # Handle Dim<<Type>>
      if (name.begins_with("Dim<<"))
        local base_type = scope.find_type( name.after_first("<<").before_first(">>") )
        if (base_type and args)
          which (args.count)
            case 1
              return scope.find_type( base_type.name + "[]" )

            case 2
              if (args[1] instanceOf CmdCreateFunction)
                return scope.find_type( base_type.name + "[]" )
              else
                return scope.find_type( base_type.name + "[][]" )
              endIf

            case 3
              if (args[2] instanceOf CmdCreateFunction)
                return scope.find_type( base_type.name + "[][]" )
              else
                return scope.find_type( base_type.name + "[][][]" )
              endIf
          endWhich
        endIf
      endIf

      return scope.find_type( name )

    method is_scoped_read_access->Logical
      return true

    method resolve( scope:Scope )->Cmd
      return resolve( scope, false )

    method resolve( scope:Scope, ignore_question_mark:Logical )->Cmd
      if (args) args.resolve( scope )

      if (context?)
        if (not ignore_question_mark and name.ends_with('?'))
          return CmdLogicalize( t, CmdAccess(t,context,name.leftmost(-1),args) ).resolve( scope )
        endIf

        context = context.resolve( scope )

      else
        local v = scope.find_local( name )
        if (v)
          if (args) return CmdAccess( t, CmdAccess(t,context,name), "call", args ).resolve( scope )
          return CmdReadLocal(t,v).resolve(scope)
        endIf

        local new_type = scope.find_type( name.after_any('@') )
        if (new_type)
          # new TypeName(...)
          new_type.organize(scope,t)

          if (args is null)
            if (name.ends_with(']'))
              # Turn DataType[] -> DataType[]()
              args = CmdArgs()
            else
              return CmdReadSingleton( t, new_type )
            endIf
          endIf

          if (new_type.is_array)
            return CmdCreateArray( t, new_type, args ).resolve( scope )
          endIf

          if (new_type.is_compound)
            local cmd = scope.resolve_call( new_type, CmdAccess(t,"create",args,named_args), true )
            local cmd_call = cmd->(as CmdCall)
            if (cmd_call and cmd_call.method_info.is_generated)
              # Calling the core compound creation routine
              return CmdCreateCompound( t, new_type, cmd_call.args ).resolve( scope )
            elseIf ( cmd_call)
              return cmd_call
            else
              return cmd
            endIf
          endIf

          local cmd_create = CmdCreateObject( t, new_type )
          local cmd_new = cmd_create : Cmd

          local cmd_call : Cmd
          if (new_type.is_native)
            cmd_call = scope.resolve_call( new_type,
            CmdAccess(t,CmdAccess(t,new_type.name),"create",args,named_args), true )
          else
            cmd_call = scope.resolve_call( new_type, CmdAccess(t,cmd_new,"init",args,named_args), true, Scope.SUPPRESS_INHERITED )
          endIf

          if (cmd_call)
            return cmd_call.cast_to( new_type, scope, &allow_implicit_narrowing ).resolve( scope )
          else
            return cmd_new.resolve(scope)
          endIf

        else
          if (not ignore_question_mark and name.ends_with('?'))
            return CmdLogicalize( t, CmdAccess(t,context,name.leftmost(-1),args) ).resolve( scope )
          endIf
        endIf

        # ---- No call context ----
        local result = scope.resolve_call( scope.this_type, this, false )
        if (result)
          check_for_recursive_getter( scope )
          return result
        endIf

        local p = scope.this_type.find_property( name, used_modules )
        if (p)
          block
            if (args) return CmdAccess( t, CmdAccess(t,context,name), "call", args ).resolve( scope )

            if (scope.this_method.is_global)
              if (scope.this_type.find_global(name)) escapeBlock  # we'll get to the global later
              throw t.error( "Cannot access object property '$' from a global method." (name) )
            endIf
            context = CmdThisContext( t, scope.this_type )
            return CmdReadProperty( t, context, p )
          endBlock
        endIf

        p = scope.this_type.find_global( name )
        if (p)
          if (args) return CmdAccess( t, CmdAccess(t,context,name), "call", args ).resolve( scope )
          else      return CmdReadGlobal( t, p )
        endIf

        if (not args)
          local def = scope.this_type.definition_lookup[ name ]
          if (not def)
            forEach (implicit_type in scope.implicit_types)
              def = implicit_type.definition_lookup[ name ]
              if (def) escapeForEach
            endForEach
          endIf
          if (def) return def.expression.cloned(&new_t=t).resolve( scope )

          p = Program.type_Global.find_property( name, used_modules )
          if (p)
            return CmdReadProperty( t, CmdReadSingleton(t,Program.type_Global), p ).resolve( scope )
          endIf

        endIf

        return scope.resolve_call( scope.this_type, this, true )
      endIf

      local context_type = context.require_type
      context_type.organize(scope,t)

      local result = scope.resolve_call( context_type, this, false )
      if (result) return result

      local p = context_type.find_property( name )
      if (p)
        block
          if (args) return CmdAccess( t, CmdAccess(t,context,name), "call", args ).resolve( scope )
          if (context.is_global)
            if (context_type.find_global(name)) escapeBlock
            throw t.error( "Cannot access object property '$' using a non-object context." (name) )
          endIf
          return CmdReadProperty( t, context, p )
        endBlock
      endIf

      p = context_type.find_global( name )
      if (p)
        if (args) return CmdAccess( t, CmdAccess(t,context,name), "call", args ).resolve( scope )
        context.require_type_context
        return CmdReadGlobal( t, p).resolve(scope)
      endIf

      if (not args)
        local def = context_type.definition_lookup[ name ]
        if (def)
          scope.implicit_types.add( context_type )
          local def_result = def.expression.cloned(&new_t=t).resolve( scope )
          scope.implicit_types.remove_last
          return def_result
        endIf
      endIf

      return scope.resolve_call( context_type, this, true )


    method check_for_recursive_getter( scope:Scope )
      local this_type = scope.this_type
      if (name != scope.this_method.name) return

      local arg_count = which{ args:args.count || 0 }
      if (arg_count != scope.this_method.parameters.count) return
      if (not (this_type.find_property(name,used_modules) or this_type.find_global(name))) return

      throw t.error( "Recursive call to getter " + name + "() - write @" + name + " instead." )

    method resolve_assignment( scope:Scope, new_value:Cmd )->Cmd
      if (args) throw t.error( "The result of a call cannot be assigned a value." )
      local setter_name = which(name[0]) { '@':null || "set_"+name } : String

      local context_was_null = context is null
      if (context is null)
        if (setter_name)
          local v = scope.find_local( name )
          if (v)
            return CmdWriteLocal(t,v,new_value).resolve(scope)
          endIf

          local setter = scope.resolve_call( scope.this_type, CmdAccess(t,setter_name,CmdArgs(new_value)), false )
          if (setter)
            if (scope.this_method.name == setter_name)
              throw t.error( "Recursive call to setter set_" + name + "() - write \"@" + name + " = ...\" instead." )
            endIf
            return setter
          endIf
        endIf

        local as_type = scope.find_type( name )
        if (as_type and as_type.is_singleton)
          return CmdWriteSingleton( t, as_type, new_value ).resolve( scope )
        endIf

        local def = scope.this_type.definition_lookup[ name ]
        if (not def)
          forEach (implicit_type in scope.implicit_types)
            def = implicit_type.definition_lookup[ name ]
            if (def) escapeForEach
          endForEach
        endIf
        if (def) return def.expression.cloned(&new_t=t).resolve_assignment( scope, new_value )

        local p = scope.this_method.type_context.find_global( name )
        if (p and (scope.this_method.is_global or not scope.this_method.type_context.find_property(name)))
          return CmdWriteGlobal( t, p, new_value ).resolve( scope )
        endIf

        if (scope.this_method.is_global)
          p = scope.this_method.type_context.find_property( name )
          if (p) throw t.error( "Cannot access object property '$' from a global method." (name) )
        endIf

        context = CmdThisContext( t, scope.this_type )
      else
        context = context.resolve( scope )
      endIf

      local context_type = context.require_type
      context_type.organize(scope,t)

      if (setter_name)
        local setter = scope.resolve_call( context_type, CmdAccess(t,context,setter_name,CmdArgs(new_value)), false )
        if (setter) return setter
      endIf

      local p = context_type.find_property( name, ?:{context_was_null:used_modules||null} )
      if (p)
        block
          if (context.is_global)
            if (context_type.find_global(name)) escapeBlock
            throw t.error( "Cannot access object property '$' from a non-object context." (name) )
          else
            return CmdWriteProperty( t, context, p, new_value ).resolve(scope)
          endIf
        endBlock
      endIf

      p = context_type.find_global( name )
      if (p)
        context.require_type_context
        return CmdWriteGlobal( t, p, new_value ).resolve(scope)
      endIf

      local def = context_type.definition_lookup[ name ]
      if (not def)
        forEach (implicit_type in scope.implicit_types)
          def = implicit_type.definition_lookup[ name ]
          if (def) escapeForEach
        endForEach
      endIf
      if (def) return def.expression.cloned(&new_t=t).resolve_assignment( scope, new_value )

      if (context_was_null and scope.this_type is not Program.type_Global)
        p = Program.type_Global.find_property( name, used_modules )
        if (p)
          return CmdWriteProperty( t, CmdReadSingleton(t,Program.type_Global), p, new_value ).resolve( scope )
        endIf
      endIf

      if (setter_name)
        local setter = scope.resolve_call( context_type, CmdAccess(t,context,setter_name,CmdArgs(new_value)), true )
        if (setter) return setter
      endIf

      throw t.error( ''No such method or variable "$" exists in the current scope.'' (name) )

    method expand_modify_and_assign( scope:Scope, op:TokenType, new_value:Cmd )->Cmd
      local cmd : Cmd
      which (op)
        case TokenType.symbol_ampersand_equals:    cmd = CmdBitwiseAnd( t, this, new_value )
        case TokenType.symbol_caret_equals:        cmd = CmdPower( t, this, new_value )
        case TokenType.symbol_dot_equals:          cmd = CmdAccess( t, this, name, new_value )
        case TokenType.symbol_minus_equals:        cmd = CmdSubtract( t, this, new_value )
        case TokenType.symbol_percent_equals:      cmd = CmdMod( t, this, new_value )
        case TokenType.symbol_plus_equals:         cmd = CmdAdd( t, this, new_value )
        case TokenType.symbol_slash_equals:        cmd = CmdDivide( t, this, new_value )
        case TokenType.symbol_tilde_equals:        cmd = CmdBitwiseXor( t, this, new_value )
        case TokenType.symbol_times_equals:        cmd = CmdMultiply( t, this, new_value )
        case TokenType.symbol_vertical_bar_equals: cmd = CmdBitwiseOr( t, this, new_value )
        others
          @trace
          throw t.error( "[INTERNAL]" )
      endWhich
      return CmdAssign( t, this.cloned, cmd )

    method resolve_modify_and_assign( scope:Scope, op:TokenType, new_value:Cmd )->Cmd
      local context_type : Type

      if (context)
        context = context.resolve( scope )
        context_type = context.require_type
      else
        if (args is null)
          local v = scope.find_local( name )
          if (v)
            if (args) throw t.error( "Local variable '$' cannot be called like a method."(name) )
            return CmdModifyAndAssignLocal(t,v,op,new_value).resolve(scope)
          endIf
        endIf

        context_type = scope.this_type

      endIf

      local setter_name : String
      if (name[0] != '@')
        setter_name = "set_" + name
        local setter = scope.resolve_call( context_type, CmdAccess(t,setter_name,CmdArgs(new_value)), false )
        if (setter)
          return expand_modify_and_assign( scope, op, new_value ).resolve( scope )
        endIf
      endIf

      local p = context_type.find_property( name )
      if (p)
        block
          local new_context = context
          if (not new_context) new_context = CmdThisContext( t, context_type )
          if (new_context.is_global and scope.this_method.is_global)
            if (context_type.find_global(name)) escapeBlock
            throw t.error( "Cannot access object property '$' from a global method." (name) )
          endIf
          context = new_context
          return CmdModifyAndAssignProperty( t, context, p, op, new_value ).resolve(scope)
        endBlock
      endIf

      p = context_type.find_global( name )
      if (p)
        if (context) context.require_type_context
        return CmdModifyAndAssignGlobal( t, p, op, new_value ).resolve(scope)
      endIf

      local def = context_type.definition_lookup[ name ]
      if (not def)
        forEach (implicit_type in scope.implicit_types)
          def = implicit_type.definition_lookup[ name ]
          if (def) escapeForEach
        endForEach
      endIf
      if (def) return def.expression.cloned(&new_t=t).resolve_modify_and_assign( scope, op, new_value )

      if (setter_name)
        local setter = scope.resolve_call( context_type, CmdAccess(t,setter_name,CmdArgs(new_value)), true )
        if (setter) return expand_modify_and_assign( scope, op, new_value ).resolve( scope )
      endIf

      throw t.error( ''No such method or variable "$" exists in the current scope.'' (name) )

    method to->String
      local buffer = StringBuilder()
      buffer.print( "CmdAccess(" )
      if (context) buffer.print( context ).print( "," )
      buffer.print( '"' ).print( name ).print( '"' )
      if (args) buffer.print( args )
      if (named_args) buffer.print( '&' ).print( named_args )
      buffer.print( ")" )
      return buffer->String

    method type->Type
      local err = t.error( "[INTERNAL] $.type() is not defined (access name '$')." (type_name,name) )
      println err.stack_trace
      throw err
endClass


class CmdElementAccess : Cmd
  PROPERTIES
    context : Cmd
    index   : Cmd

  METHODS
    method init( t, context, index )

    method init( t, name:String, index )
      init( t, CmdAccess(t,name), index )

    method init( t, name:String, i:Int32 )
      init( t, CmdAccess(t,name), CmdLiteralInt32(t,i) )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdElementAccess( t, context.cloned( clone_args, new_t ), index.cloned( clone_args, new_t ) )

    method execute( vm:VM )->Value
      local obj = context.execute( vm )->Object
      if (obj is null) throw t.error( "Cannot get element of null context." )
      local type = obj.type_info
      if (type.instance_of(vm.type_Array)) throw t.error( "Metacode cannot directly access array elements." )
      local i = index.execute( vm )
      return type.call( obj, "get", @[i] )

    method execute_assignment( vm:VM, new_value:Value )
      local obj = context.execute( vm )->Object
      if (obj is null) throw t.error( "Cannot set element of null context." )
      local type = obj.type_info
      if (type.instance_of(vm.type_Array)) throw t.error( "Metacode cannot directly set array elements." )
      local i = index.execute( vm )
      type.call( obj, "set", @[i,new_value] )

    method is_scoped_read_access->Logical
      return true

    method resolve( scope:Scope )->Cmd
      context = context.resolve( scope )

      local context_type = context.require_type
      context_type.organize(scope,t)
      if (context_type.is_array)
        return CmdReadArrayElement( t, context, index ).resolve( scope )
      else
        local args = CmdArgs()
        args.add( index )
        return scope.resolve_call( context_type, CmdAccess(t,context,"get",args), &error_on_fail )
      endIf

    method resolve_assignment( scope:Scope, new_value:Cmd )->Cmd
      context = context.resolve( scope )

      local context_type = context.require_type
      context_type.organize(scope,t)
      if (context_type.is_array)
        return CmdWriteArrayElement( t, context, index, new_value ).resolve( scope )
      else
        local args = CmdArgs()
        args.[ add(index), add(new_value) ]
        local result = scope.resolve_call( context_type, CmdAccess(t,context,"set",args), true )
        return result
      endIf

    method resolve_modify_and_assign( scope:Scope, op:TokenType, new_value:Cmd )->Cmd
      local cmd : Cmd
      which (op)
        case TokenType.symbol_ampersand_equals:    cmd = CmdBitwiseAnd( t, this, new_value )
        case TokenType.symbol_caret_equals:        cmd = CmdPower( t, this, new_value )
        #case TokenType.symbol_dot_equals:          cmd = CmdAccess( t, this, name, new_value )
        case TokenType.symbol_minus_equals:        cmd = CmdSubtract( t, this, new_value )
        case TokenType.symbol_percent_equals:      cmd = CmdMod( t, this, new_value )
        case TokenType.symbol_plus_equals:         cmd = CmdAdd( t, this, new_value )
        case TokenType.symbol_slash_equals:        cmd = CmdDivide( t, this, new_value )
        case TokenType.symbol_tilde_equals:        cmd = CmdBitwiseXor( t, this, new_value )
        case TokenType.symbol_times_equals:        cmd = CmdMultiply( t, this, new_value )
        case TokenType.symbol_vertical_bar_equals: cmd = CmdBitwiseOr( t, this, new_value )
        others
          @trace
          throw t.error( "[INTERNAL]" )
      endWhich
      return CmdAssign( t, this.cloned, cmd ).resolve( scope )

    method resolve_adjust( scope:Scope, delta:Int32 )->Cmd
      return cloned.resolve_assignment( scope, CmdAdd(t,this,CmdLiteralInt32(t,delta)) )

    method to->String
      return "$[$]" (context,index)

endClass


#------------------------------------------------------------------------------
# Object Creation
#------------------------------------------------------------------------------
class CmdCreateObject : Cmd
  PROPERTIES
    of_type       : Type

  METHODS
    method init( t, of_type )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCreateObject( t, of_type )

    method execute( vm:VM )->Value
      local type = TypeInfo[ of_type.name ]
      if (type)
        return Value( type.create_object )
      else
        throw t.error( "No such type $." (of_type.name) )
      endIf

    method resolve( scope:Scope )->Cmd
      of_type.organize(scope,t)
      if (of_type.is_abstract)
        throw t.error( "$ cannot be instantiated because it is an [abstract] type." (of_type.name) )
      endIf
      return this

    method to->String
      return of_type + "()"

    method type->Type
      return of_type
endClass


class CmdCreateCompound : Cmd
  PROPERTIES
    of_type : Type
    args    : CmdArgs

  METHODS
    method init( t, of_type, args )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCreateCompound( t, of_type, args.cloned( clone_args, new_t ) )

    method execute( vm:VM )->Value
      local type = TypeInfo[ of_type.name ]
      if (type)
        local m = type.find_global_method( "from_value(Value)" )
        if (not m)
          throw t.error( "Compound type $ does not define from_value(Value)." )
        endIf
        ensure args
        if (args.count > of_type.property_list.count)
          throw t.error( "Too many arguments specified while creating compound $." (of_type.name) )
        endIf
        local info = @{}
        forEach (arg at i in args)
          info[ of_type.property_list[i].name ] = arg.execute( vm )
        endForEach
        return m.call<<Value>>( info )
      else
        throw t.error( "No such type $." (of_type.name) )
      endIf

    method resolve( scope:Scope )->Cmd
      of_type.organize(scope,t)
      ensure args

      local non_native_property_count = 0
      forEach (p in of_type.property_list)
        if (not p.is_native) ++non_native_property_count
      endForEach

      local i = args.count
      while (args.count < non_native_property_count)
        local p = of_type.property_list[i]
        if (not p.is_native)
          if (p.initial_value)
            args.add( p.initial_value.cloned.resolve(scope) )
          else
            args.add( p.type.create_default_value(t) )
          endIf
        endIf
        ++i
      endWhile

      args.resolve( scope )
      return this

    method type->Type
      return of_type
endClass


#------------------------------------------------------------------------------
# Assign
#------------------------------------------------------------------------------
class CmdAssign : Cmd
  PROPERTIES
    target    : Cmd
    new_value : Cmd

  METHODS
    method init( t, target, new_value )

    method init( t, local_info:Local, new_value )
      target = CmdAccess( t, local_info.name )

    method init( t, name:String, new_value )
      target = CmdAccess( t, name )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdAssign( t, target.cloned( clone_args, new_t ), new_value.cloned( clone_args, new_t ) )

    method execute( vm:VM )->Value
      target.execute_assignment( vm, new_value.execute(vm) )
      return UndefinedValue

    method resolve( scope:Scope )->Cmd
      return target.resolve_assignment( scope, new_value )

    method to->String
      return "CmdAssign($ = $)" (target,new_value)
endClass

#------------------------------------------------------------------------------
# Read/Write
#------------------------------------------------------------------------------

class CmdThisContext : Cmd
  # Implicit or explicit 'this'
  PROPERTIES
    this_type : Type

  METHODS
    method init( t, this_type )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local macro_args = clone_args->(as MacroArgs)
      if (macro_args) return macro_args.inline_this

      local task_args = clone_args->(as TaskArgs)
      if (task_args)
        return task_args.cmd_read_context(t)
      else
        return CmdThisContext( t, this_type )
      endIf

    method execute( vm:VM )->Value
      return Value( vm.context )

    method implicit_type( scope:Scope )->Type
      return this_type

    method is_safely_mutable->Logical
      return true

    method is_scoped_read_access->Logical
      return true

    method require_type_context
      noAction

    method resolve( scope:Scope )->Cmd
      this_type.organize(scope,t)
      return this

    method type->Type
      return this_type
endClass

class CmdLiteralThis : CmdThisContext
  # Explicit 'this'
  PROPERTIES
    this_type : Type

  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local macro_args = clone_args->(as MacroArgs)
      if (macro_args) return macro_args.inline_this

      local task_args = clone_args->(as TaskArgs)
      if (task_args)
        return task_args.cmd_read_context(t)
      else
        return CmdLiteralThis( t, this_type )
      endIf

    method require_type_context
      throw t.error( "Type name expected." )

    method resolve( scope:Scope )->Cmd
      this_type.organize(scope,t)
      if (scope.this_method.is_global)
        throw t.error( "Invalid reference to 'this' object - global methods have no object context." )
      endIf
      return this

    method to->String
      return "this<<$>>" (this_type)
endClass


class CmdReadSingleton : Cmd
  PROPERTIES
    of_type : Type

  METHODS
    method init( t, of_type )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdReadSingleton( t, of_type )

    method execute( vm:VM )->Value
      local type = TypeInfo[ of_type.name ]
      if (type)
        if (type.is_singleton)
          return Value( type.singleton )
        else
          throw t.error( "$ is not a singleton type - use $(...) to create a new object." (of_type.name,of_type.name) )
        endIf
      else
        throw t.error( "No such type $." (of_type.name) )
      endIf

    method is_global->Logical
      return (not of_type.is_singleton)

    method is_safely_mutable->Logical
      return true

    method require_type_context
      noAction

    method resolve( scope:Scope )->Cmd
      of_type.organize(scope,t)
      return this

    method type->Type
      return of_type
endClass


class CmdWriteSingleton : Cmd
  PROPERTIES
    of_type   : Type
    new_value : Cmd

  METHODS
    method init( t, of_type, new_value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdWriteSingleton( t, of_type, new_value.cloned( clone_args, new_t ) )

    method execute( vm:VM )->Value
      local type = TypeInfo[ of_type.name ]
      local new_singleton = new_value.execute( vm )->Object
      if (type)
        if (type.is_singleton)
          return type.set_singleton( new_singleton )
        else
          throw t.error( "Cannot assign an object to non-singleton type $." (of_type.name) )
        endIf
      else
        throw t.error( "No such type $." (of_type.name) )
      endIf

    method resolve( scope:Scope )->Cmd
      of_type.organize(scope,t)
      new_value = new_value.resolve(scope).require_value
      if (not new_value.type.instance_of(of_type))
        throw t.error( "Assigned value must be instanceOf type $." (of_type) )
      endIf
      return this

endClass


class CmdReadLocal : Cmd
  PROPERTIES
    local_info : Local

  METHODS
    method init( t, local_info )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local macro_args = clone_args->(as MacroArgs)
      if (macro_args)
        return macro_args.inline_read_local( this )
      else
        local task_args = clone_args->(as TaskArgs)
        if (task_args)
          return task_args.cmd_read(t,local_info)
        endIf
      endIf

      return CmdReadLocal( t, local_info )

    method execute( vm:VM )->Value
      return vm.get_local( local_info.name )

    method is_safely_mutable->Logical
      return true

    method is_scoped_read_access->Logical
      return true

    method resolve( scope:Scope )->Cmd
      #trace local_info.type, local_info.name, scope.this_method.name, scope.this_type.name
      local_info.type.organize(scope,t)
      return this

    method resolve_adjust( scope:Scope, delta:Int32 )->Cmd
      return CmdStepLocal( t, local_info, delta ).resolve( scope )

    method to->String
      if (local_info.type)
        return 'CmdReadLocal("$":"$")' (local_info.original_name, local_info.type.name)
      else
        return 'CmdReadLocal("$")' (local_info.original_name)
      endIf

    method type->Type
      return local_info.type

endClass


class CmdWriteLocal : Cmd
  PROPERTIES
    local_info : Local
    new_value  : Cmd

  METHODS
    method init( t, local_info, new_value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local macro_args = clone_args->(as MacroArgs)
      if (macro_args)
        return macro_args.inline_write_local( this )
      else
        local task_args = clone_args->(as TaskArgs)
        if (task_args)
          return task_args.cmd_write( t,local_info, new_value.cloned( clone_args, new_t ) )
        endIf
      endIf
      return CmdWriteLocal( t, local_info, clone(new_value,clone_args,new_t) )

    method execute( vm:VM )->Value
      vm.set_local( local_info.name, new_value.execute(vm) )
      return UndefinedValue

    method resolve( scope:Scope )->Cmd
      local_info.type.organize(scope,t)
      local_info.is_modified = true
      new_value = new_value.resolve(scope)
      new_value = new_value.cast_to( local_info.type, scope ).resolve( scope )
      return this

endClass


class CmdReadGlobal : Cmd
  PROPERTIES
    global_info : Property

  METHODS
    method init( t, global_info )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdReadGlobal( t, global_info )

    method execute( vm:VM )->Value
      local p_context_name = global_info.type_context.name
      local p_name         = global_info.name
      local type = TypeInfo[ p_context_name ]
      if (type is null) throw t.error( "No such type: $." (p_context_name) )
      local p = type.find_global_property( p_name )
      if (p is null) throw t.error( "No such global property: $.$." (p_context_name,p_name) )
      return type.global_property( p )

    method resolve( scope:Scope )->Cmd
      global_info.type_context.resolve
      return this

    method resolve_adjust( scope:Scope, delta:Int32 )->Cmd
      return CmdStepGlobal( t, global_info, delta ).resolve( scope )

    method type->Type
      return global_info.type
endClass


class CmdWriteGlobal : Cmd
  PROPERTIES
    global_info  : Property
    new_value     : Cmd

  METHODS
    method init( t, global_info, new_value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdWriteGlobal( t, global_info, new_value.cloned( clone_args, new_t ) )

    method execute( vm:VM )->Value
      local p_context_name = global_info.type_context.name
      local p_name         = global_info.name
      local type = TypeInfo[ p_context_name ]
      if (type is null) throw t.error( "No such type: $." (p_context_name) )
      local p = type.find_global_property( p_name )
      if (p is null) throw t.error( "No such global property: $.$." (p_context_name,p_name) )
      type.set_global_property( p, new_value.execute(vm) )
      return UndefinedValue

    method resolve( scope:Scope )->Cmd
      new_value = new_value.resolve(scope).cast_to( global_info.type, scope ).resolve( scope )
      return this

endClass

class CmdReadProperty : Cmd
  PROPERTIES
    context       : Cmd
    property_info : Property

  METHODS
    method init( t, context, property_info )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdReadProperty( t, context.cloned( clone_args, new_t ), property_info )

    method execute( vm:VM )->Value
      local obj = context.execute( vm )->Object
      local type = obj.type_info
      local name = property_info.name
      local p = type.find_property( name )
      if (p) return type.property( obj, p )
      p = type.find_global_property( name )
      if (p) return type.global_property( p )
      return UndefinedValue

    method is_safely_mutable->Logical
      return context.is_safely_mutable

    method is_scoped_read_access->Logical
      return true

    method resolve( scope:Scope )->Cmd
      context = context.resolve( scope ).require_value
      if (context.type.is_aspect)
        throw t.error( "Cannot read properties using aspect references.  Add a getter to the aspect definition - " +
          "'method $->$: return @$'."  (property_info.name,property_info.type.name,property_info.name) )
      endIf
      return this

    method resolve_adjust( scope:Scope, delta:Int32 )->Cmd
      local setter_name = "set_" + property_info.name
      local getter_name = property_info.name
      local context_type = context.type
      if (context_type.has_method_named(setter_name) or context_type.has_method_named(getter_name))
        return CmdAssign( t, CmdAccess(t,context,property_info.name), CmdAdd(t,CmdAccess(t,context.cloned,property_info.name),CmdLiteralInt32(t,delta)) ).resolve( scope )
      endIf
      return CmdStepProperty( t, context, property_info, delta ).resolve( scope )

    method to->String
      return "$.$" (context,property_info)

    method type->Type
      return property_info.type
endClass


class CmdWriteProperty : Cmd
  PROPERTIES
    context       : Cmd
    property_info : Property
    new_value     : Cmd

  METHODS
    method init( t, context, property_info, new_value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdWriteProperty( t, context.cloned( clone_args, new_t ), property_info, new_value.cloned( clone_args, new_t ) )

    method execute( vm:VM )->Value
      local obj = context.execute( vm )->Object
      local type = obj.type_info
      local name = property_info.name
      local p = type.find_property( name )
      if (p)
        type.set_property( obj, p, new_value.execute(vm) )
      else
        p = type.find_global_property( name )
        if (p) type.set_global_property( p, new_value.execute(vm) )
      endIf
      return UndefinedValue

    method resolve( scope:Scope )->Cmd
      context = context.resolve(scope).require_value

      if (context.type.is_aspect)
        throw t.error( "Cannot write properties using aspect references.  Add a setter to the aspect definition - " +
          "'method set_$(@$)'." (property_info.name,property_info.name) )
      endIf

      new_value = new_value.resolve(scope).require_value.cast_to( property_info.type, scope ).resolve( scope )
      return this

    method to->String
      return "CmdWriteProperty($ = $)" (context,new_value)

endClass

#------------------------------------------------------------------------------
# Method Calls
#------------------------------------------------------------------------------
class CmdCall : Cmd
  PROPERTIES
    context     : Cmd
    method_info : Method
    args        : CmdArgs

  METHODS
    method init( t, context, method_info, args )
      if (context and context.is_global and not method_info.is_global)
        throw t.error( "Cannot call object method $.$ on a non-object." (method_info.type_context,method_info.signature) )
      endIf

    method execute( vm:VM )->Value
      return CmdAccess( t, context, method_info.name, args ).execute( vm )

    method is_scoped_read_access->Logical
      return true

    method require_type->Type
      local result = type
      if (result is null)
        if (method_info.name.before_first("<") == "init" and method_info.type_context)
          # init is a template method.  We let people get away without specifying the return
          # type for init methods -- it's just the type of the class.
          method_info.return_type = method_info.type_context
          return method_info.type_context
        endIf
        throw t.error( "Value expected; call to $.$ does not return a value." (method_info.type_context,method_info.signature) )
      endIf
      return result

    method resolve( scope:Scope )->Cmd
      if (context) context = context.resolve(scope).require_value
      args.resolve( scope )
      method_info.resolve
      return this

    method resolve_adjust( scope:Scope, delta:Int32 )->Cmd
      if (not method_info.return_type)
        throw t.error( "Method '$' does not return a value." (method_info.signature) )
      endIf

      if (method_info.name == "get")
        # Pass back the same args plus our new value
        ensure args
        local setter_args = args.cloned
        setter_args.add( CmdAdd(t,this,CmdLiteralInt32(t,delta)) )
        if (context)
          return CmdAccess( t, context.cloned, "set", setter_args ).resolve(scope)
        else
          return CmdAccess( t, "set", setter_args ).resolve(scope)
        endIf
      else
        # Transform get_name() into set_name(new_value)
        local setter_name = "set_" + method_info.name
        local setter_args = which{ args:args.cloned || CmdArgs() }
        setter_args.add( CmdAdd(t,this,CmdLiteralInt32(t,delta)) )
        if (context)
          return CmdAccess( t, context.cloned, setter_name, setter_args ).resolve(scope)
        else
          return CmdAccess( t, setter_name, setter_args ).resolve(scope)
        endIf
      endIf

    method type->Type
      return method_info.return_type
endClass


class CmdCallRoutine : CmdCall
  METHODS
    method init( t, method_info, args )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCallRoutine( t, method_info, args.cloned( clone_args, new_t ) )

    method to->String
      return "CmdCallRoutine($.$,$)" (method_info.type_context,method_info.signature,args)
endClass

class CmdCallAspectMethod : CmdCall
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCallAspectMethod( t, clone(context,clone_args,new_t), method_info, args.cloned( clone_args, new_t ) )

endClass


class CmdCallMethod : CmdCall
  METHODS
    method call_prior( scope:Scope )->Cmd
      if (method_info.is_initializer and method_info.type_context is not scope.this_type)
        # Calling a prior initializer with a different signature that was hidden by
        # an extended class initializer.
        return CmdCallStaticMethod( t, context, method_info, args )
      endIf

      if (not method_info.overridden_method)
        if (method_info.specializer_count and method_info.type_context.base_class)
          # This method conforms to a method template syntax.  Attempt to instantiate
          # the corresponding method template in the base class.  If successful it
          # will change method_info.overridden_method.
          method_info.type_context.base_class.method_templates.instantiate( method_info.unspecialized_name,
              method_info.specializer_count, t, method_info.name, null )
        endIf

        if (not method_info.overridden_method)
          throw t.error( "Cannot call prior.$ from class $ because the method is not an override - no prior version of it exists." (method_info.signature,method_info.type_context) )
        endIf
      endIf

      return CmdCallStaticMethod( t, context, method_info.overridden_method, args )

    method _is_call_via_methodinfo->Logical
      return (method_info.type_context.name == "MethodInfo" and method_info.name.begins_with("call<<"))

    method require_type->Type
      if (_is_call_via_methodinfo)
        if (type is null)
          throw t.error( "Invocation via MethodInfo.call must use '->' to define the return type if there is one." )
        endIf
      endIf
      return prior.require_type

    method cast_to( target_type:Type, scope:Scope, &allow_implicit_narrowing, &is_conversion )->Cmd
      if (_is_call_via_methodinfo)
        # This turns a call like:
        #   f.type_info.method_info("foo")[0].call(f)->Real64
        # Into:
        #   f.type_info.method_info("foo")[0].returns<<Real64>>.call(f)
        return CmdAccess(t, CmdAccess(t, context, "returns<<$>>" (target_type.name)), "call", args)
      endIf
      return prior.cast_to( target_type, scope, allow_implicit_narrowing, is_conversion )
endClass

class CmdCallDynamicMethod : CmdCallMethod
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCallDynamicMethod( t, clone(context,clone_args,new_t), method_info, args.cloned( clone_args, new_t ) )

    method to->String
      return "CmdCallDynamicMethod($.$,$,$)->$" (method_info.type_context,method_info.signature,context,args,method_info.return_type)
endClass


class CmdCallStaticMethod : CmdCallMethod
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCallStaticMethod( t, clone(context,clone_args,new_t), method_info, args.cloned( clone_args, new_t ) )

    method resolve( scope:Scope )->Cmd
      if (not context) context = CmdThisContext(t,method_info.type_context)
      return prior.resolve( scope )

    method to->String
      return "CmdCallStaticMethod($.$,$)" (method_info.type_context,method_info.signature,args)
endClass


class CmdCallPriorMethod : Cmd
  PROPERTIES
    name       : String
    args       : CmdArgs
    named_args : CmdNamedArg[]

  METHODS
    method init( t, name, args, named_args )

    method execute( vm:VM )->Value
      throw t.error( "[Internal] TODO: metacode prior method call." )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local cloned_named_args : CmdNamedArg[]
      if (named_args)
        cloned_named_args = CmdNamedArg[]( named_args.count )
        forEach (named_arg in named_args) cloned_named_args.add( named_arg.cloned )
      endIf
      return CmdCallPriorMethod( t, name, clone(args,clone_args,new_t), cloned_named_args )

    method is_scoped_read_access->Logical
      return true

    method resolve( scope:Scope )->Cmd
      local access = CmdAccess( t, name, args, named_args )
      if (name == "init")
        local call = scope.resolve_call( scope.this_type, access, &error_on_fail, Scope.CALLING_PRIOR_INIT )
        return call.call_prior( scope )

      else
        local call = scope.resolve_call( scope.this_type, access, &error_on_fail )
        return call.call_prior( scope )
      endIf
endClass


class CmdCallNativeRoutine : CmdCall
  METHODS
    method init( t, method_info, args )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCallNativeRoutine( t, method_info, args.cloned( clone_args, new_t ) )

endClass

class CmdCallNativeMethod : CmdCall
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCallNativeMethod( t, clone(context,clone_args,new_t), method_info, args.cloned( clone_args, new_t ) )

endClass

class CmdCallInlineNative : CmdCall
  PROPERTIES
    adjust_delta : Int32

  METHODS
    method to->String
      return method_info.signature

    method resolve_adjust( scope:Scope, adjust_delta )->Cmd
      return this

    method resolve( scope:Scope )->Cmd
      if (method_info.native_return_type) method_info.native_return_type.organize(scope,t)
      return this
endClass

class CmdCallInlineNativeRoutine : CmdCallInlineNative
  METHODS
    method init( t, method_info, args )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCallInlineNativeRoutine( t, method_info, args.cloned( clone_args, new_t ) )

    method type->Type
      return method_info.return_type
endClass

class CmdCallInlineNativeMethod : CmdCallInlineNative
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCallInlineNativeMethod( t, clone(context,clone_args,new_t), method_info, args.cloned( clone_args, new_t ) )

    method type->Type
      return method_info.return_type
endClass

#------------------------------------------------------------------------------
# Miscellaneous Expressions
#------------------------------------------------------------------------------
class CmdRange : Cmd
  PROPERTIES
    first : Cmd
    last  : Cmd
    step_size  : Cmd

  METHODS
    method init( t, first, last, step_size=null )

    method default_step_size->Int32
      return 1

    method step_cmd->Cmd
      if (step_size) return step_size
      return CmdLiteralInt32( t, default_step_size )

    method resolve( scope:Scope )->Cmd
      first = first.resolve( scope ).require_value
      last = last.resolve( scope ).require_value

      local range_type = must_find_common_type( first.type,last.type )
      if (step_size)
        step_size = step_size.resolve( scope )
        range_type = must_find_common_type( range_type, step_size.require_type )
      else
        step_size = CmdLiteralInt32( t, default_step_size ).cast_to( range_type, scope ).resolve( scope ).require_value
      endIf
      local name = "Range"
      if (this instanceOf CmdRangeUpToLessThan) name = "RangeToLimit"
      return CmdAccess( t, "$<<$>>"(name,range_type), CmdArgs(first,last,step_size) ).resolve( scope )

endClass

class CmdRangeUpTo : CmdRange
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdRangeUpTo( t, first.cloned( clone_args, new_t ), last.cloned( clone_args, new_t ), clone(step_size,clone_args,new_t) )
endClass

class CmdRangeUpToLessThan : CmdRange
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdRangeUpToLessThan( t, first.cloned( clone_args, new_t ), last.cloned( clone_args, new_t ), clone(step_size,clone_args,new_t) )
endClass

class CmdRangeDownTo : CmdRange
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdRangeDownTo( t, first.cloned( clone_args, new_t ), last.cloned( clone_args, new_t ), clone(step_size,clone_args,new_t) )

    method default_step_size->Int32
      return -1
endClass

class CmdTuple : Cmd
  PROPERTIES
    elements   : Cmd[]
    synthesize_variables : Logical
    # If above is true, this is a tuple for destructuring assignment and we should
    # synthesize the variables (e.g., it was done with "local (a,b) = (1,2)").

  METHODS
    method init( t, elements, synthesize_variables=false )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->this
      if (new_t) t = new_t
      return CmdTuple( t, elements.cloned, synthesize_variables )

    method resolve( scope:Scope )->Cmd
      local args = CmdArgs()
      local type_string = ""
      forEach (el at i in elements)
        if (el instanceOf CmdNoAction )
          # CmdNoAction is used as a placeholder for elements that are to be
          # skipped when doing destructuring assignment, and is illegal for
          # value tuples.  We could use them for doing Python-style
          # single-element tuples: "(1,)", but we don't presently.
          throw el.t.error("Expected a value, but got '$'." (el.t))
        endIf
        elements[i] = el.resolve( scope )
        elements[i].require_type.organize( scope,t )
        elements[i] = elements[i].require_value
        args.add(elements[i])
        if (i > 0) type_string += ","

        local element_type = elements[i].type
        if (element_type is Program.type_null)
          throw el.t.error("Ambiguous 'null' in tuple creation. Specify a datatype with 'null->(as String)' etc.")
        endIf
        type_string += element_type.name
      endForEach
      return CmdAccess( t, "Tuple<<$>>"(type_string), args ).resolve( scope )

    method _get_element_type ( rht:Type, index:Int32 ) -> Type
        local prop = rht.find_property("_$" (1+index))
        if (prop) return prop.type
        local meth = rht.find_method("_$()" (1+index))
        if (meth) return meth.return_type
        return null

    method _create_variables ( scope:Scope, rht:Type )
      forEach (el at el_index in elements)
        if (el instanceOf CmdNoAction) nextIteration # They are skipping this one
        local type = _get_element_type(rht, el_index)
        if (el instanceOf CmdTuple)
          # synthesizing for nested destructuring
          (el->(as CmdTuple))._create_variables(scope, type)
          nextIteration
        endIf
        require(el instanceOf CmdAccess)
        local part_var = Local(t, (el->(as CmdAccess)).name, type )
        local part_decl = CmdLocalDeclaration(t,part_var)
        scope.this_body.add( part_decl.resolve(scope) )
      endForEach

    method resolve_assignment( scope:Scope, new_value:Cmd )->Cmd
      new_value = new_value.resolve(scope)
      local rht = new_value.require_type # Type of right-hand tuple
      rht.organize(scope)

      if (rht.is_tuple)
        require(rht.property_list.count >= rht.specializers.count)
        if (rht.specializers.count != elements.count)
          throw t.error("Cannot assign $ elements because the right-hand tuple has $." (elements.count, rht.specializers.count))
        endIf
      else
        # Maybe it supports something vaguely tuple-like.  Let's check...
        # This doesn't support semi-odd things like "method _1(param=false)->t" which could
        # theoretically work.
        forEach (el_index in 0..<elements.count)
          if (_get_element_type(rht, el_index) is null)
            throw t.error("Cannot assign $ elements because the right-hand side has $." (elements.count, el_index))
          endIf
        endForEach
        if (_get_element_type(rht, elements.count))
          throw t.error("Cannot assign $ elements because the right-hand side has more than that." (elements.count))
        endIf
      endIf

      # We assign the RHS to a temporary variable inside a block.
      # Inside the block, we assign elements of the temporary to the individual
      # variables.
      # By having the temporary inside a block, it gets destroyed right after
      # all the assignments, which lets the temporary expire at the correct
      # time.  This may be important for garbage collection, for example.
      # Since the temporary and assignments are inside a block, if we are
      # synthesizing variables, we need to do it in the current scope first.

      if (synthesize_variables) _create_variables(scope, rht)

      local temp_block = CmdBlock( t )

      local temp_var = Local( t, Program.create_unique_id, null, new_value )
      local temp_var_decl = CmdLocalDeclaration(t,temp_var)
      temp_block.statements.add( temp_var_decl )

      forEach (el at el_index in elements)
        if (el instanceOf CmdNoAction) nextIteration # They are skipping this one
        local rhs_part = CmdAccess(t, CmdAccess(t, temp_var), "_"+(el_index+1))
        temp_block.statements.add( CmdAssign(t, el, rhs_part) )
      endForEach

      scope.this_body.add( temp_block.resolve(scope) )
      return CmdNoAction(t)
endClass

#------------------------------------------------------------------------------
# Unary Operators
#------------------------------------------------------------------------------
class CmdUnary : Cmd
  PROPERTIES
    operand : Cmd

  METHODS
    method init( t, operand )

    method prefix_symbol->String
      return ""

    method fn_name->String
      return null

    method resolve( scope:Scope )->Cmd
      operand = operand.resolve( scope ).require_value
      if (operand.is_literal) return resolve_for_literal_operand( scope )
      else                    return resolve_for_operand_type( scope, operand.require_type.organize(scope,t) )

    method resolve_for_literal_operand( scope:Scope )->Cmd
      return this

    method resolve_for_operand_type( scope:Scope, operand_type:Type )->Cmd
      local name = fn_name
      if (name)
        if (operand_type.has_method_named(name))
          return CmdAccess( t, operand, name ).resolve( scope )
        endIf

        if (not operand_type.is_primitive)
          throw t.error( "No method $.$() is defined." (operand_type,name) )
        endIf

      endIf
      return this

    method suffix_symbol->String
      return ""

    method to->String
      return "$($)" (type_name,operand)

    method type->Type
      return operand.type
endClass

class CmdLogicalize : CmdUnary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLogicalize( t, operand.cloned( clone_args, new_t ) )

    method execute( vm:VM )->Value
      return operand.execute( vm )->Logical

    method fn_name->String
      return "operator?"

    method prefix_symbol->String
      return ""

    method resolve( scope:Scope )->Cmd
      operand = operand.resolve( scope )
      local operand_type = operand.require_type.organize( scope, t )
      if (operand_type.is_optional)
        return CmdAccess( t, operand, "exists" ).resolve( scope )
      elseIf (operand_type.has_global_method_named("operator?"))
        return CmdAccess( t, CmdAccess(t,operand_type.name),
          "operator?", CmdArgs(operand) ).resolve( scope, &ignore_question_mark )
      elseIf (operand_type.is_compound)
        if (operand_type.has_method_named("to_Logical"))
          return CmdAccess( t, operand, "to_Logical" ).resolve( scope )
        else
          local name = operand_type.name
          throw t.error( "Cannot convert type $ to required type Logical.  Define method '$.to->Logical' or global method `$.operator?($)`." (name,name,name,name) )
        endIf

      else
        return this
      endIf

    method resolve_for_literal_operand( scope:Scope )->Cmd
      operand = operand.resolve( scope ).require_value
      return this

    method suffix_symbol->String
      return "?"

    method type->Type
      return Program.type_Logical

endClass

class CmdLogicalNot : CmdUnary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLogicalNot( t, operand.cloned( clone_args, new_t ) )

    method execute( vm:VM )->Value
      return Value( not operand.execute( vm )->Logical )

    method implicit_type( scope:Scope )->Type
      return Program.type_Logical

    method prefix_symbol->String
      return "not "

    method resolve( scope:Scope )->Cmd
      operand = operand.resolve( scope ).require_value
      if (operand.is_literal)
        return resolve_for_literal_operand( scope )
      else
        operand = operand.require_logical( scope )
        return this
      endIf

    method resolve_for_literal_operand( scope:Scope )->Cmd
      if (operand instanceOf CmdLiteralReal64)
        return CmdLiteralLogical(t, not ((operand->(as CmdLiteralReal64)).value) )
      elseIf (operand instanceOf CmdLiteralInt32)
        return CmdLiteralLogical(t, not ((operand->(as CmdLiteralInt32)).value) )
      elseIf (operand instanceOf CmdLiteralLogical)
        return CmdLiteralLogical(t, not ((operand->(as CmdLiteralLogical)).value) )
      else
        operand = operand.require_logical( scope )
      endIf
      return this

    method type->Type
      return Program.type_Logical

endClass


class CmdNegate : CmdUnary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdNegate( t, operand.cloned( clone_args, new_t ) )

    method execute( vm:VM )->Value
      return -operand.execute(vm)

    method fn_name->String
      return "operator-"

    method implicit_type( scope:Scope )->Type
      return operand.implicit_type(scope)

    method prefix_symbol->String
      return "(-"

    method resolve_for_literal_operand( scope:Scope )->Cmd
      if (operand instanceOf CmdLiteralReal64)
        return CmdLiteralReal64(t, -(operand->(as CmdLiteralReal64)).value )
      elseIf (operand instanceOf CmdLiteralInt32)
        return CmdLiteralInt32(t, -(operand->(as CmdLiteralInt32)).value )
      endIf
      return this

    method suffix_symbol->String
      return ")"
endClass


class CmdDescribe : CmdUnary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdDescribe( t, operand.cloned( clone_args, new_t ) )

    method execute( vm:VM )->Value
      return operand.execute(vm).description

    method fn_name->String
      return "%"

    method implicit_type( scope:Scope )->Type
      return Program.type_String

    method prefix_symbol->String
      return "(%"

    method resolve_for_literal_operand( scope:Scope )->Cmd
      if (operand instanceOf CmdLiteralReal64)
        return CmdLiteralReal64(t, (operand->(as CmdLiteralReal64)).value.description )
      elseIf (operand instanceOf CmdLiteralInt32)
        return CmdLiteralInt32(t, (operand->(as CmdLiteralInt32)).value.description )
      endIf
      return this

    method resolve_for_operand_type( scope:Scope, operand_type:Type )->Cmd
      if (operand_type.is_reference)
        return CmdAccess( t, CmdAccess(t,"String"), "describe", operand ).resolve( scope )
      else
        return CmdAccess( t, operand, "description" ).resolve( scope )
      endIf
      return this

    method suffix_symbol->String
      return ")"
endClass


#{
class CmdGrouping : CmdUnary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdGrouping( t, operand.cloned( clone_args, new_t ) )

    method execute( vm:VM )->Value
      return operand.execute(vm)

    method fn_name->String
      return "operator()"

    method implicit_type( scope:Scope )->Type
      return operand.implicit_type(scope)

    method prefix_symbol->String
      return "("

    method resolve_for_literal_operand( scope:Scope )->Cmd
      return operand

    method resolve_for_operand_type( scope:Scope, operand_type:Type )->Cmd
      if (operand_type.has_method_named("operator()"))
        return CmdAccess( t, operand, "operator()" ).resolve( scope )
      else
        return operand
      endIf

    method suffix_symbol->String
      return ")"
endClass
}#


#------------------------------------------------------------------------------
# Binary Operators
#------------------------------------------------------------------------------
class CmdBinary : Cmd
  PROPERTIES
    left   : Cmd
    right  : Cmd

  METHODS
    method init( t, left, right )

    method fn_name->String
      throw t.error( "[INTERNAL] $.fn_name() is not defined." (type_name) )

    method requires_parens->Logical
      return true

    method resolve( scope:Scope )->Cmd
      left = left.resolve( scope )
      right = right.resolve( scope )
      local left_type = left.require_type.organize( scope, t )
      local right_type = right.require_type.organize( scope, t )
      local result = resolve_for_types( scope, left_type, right_type )
      return result

    method resolve_for_types( scope:Scope, left_type:Type, right_type:Type )->Cmd
      if (not (left_type.is_primitive and right_type.is_primitive))
        return resolve_operator_method( fn_name, scope, left, left_type, right, right_type )
      endIf

      local common_type = must_find_common_type( left_type, right_type )
      left = left.cast_to( common_type, scope ).resolve( scope )
      right = right.cast_to( common_type, scope ).resolve( scope )
      if (left.is_literal and right.is_literal) return combine_literal_operands( common_type )
      return resolve_for_common_type( scope, common_type )

    method resolve_for_common_type( scope:Scope, common_type:Type )->Cmd
      return this

    method resolve_operator_method( method_name:String, scope:Scope, lhs:Cmd, left_type:Type, rhs:Cmd, right_type:Type, &is_optional )->Cmd
      return resolve_operator_method(method_name, scope, lhs, left_type, rhs, right_type, is_optional, true)

    method resolve_operator_method( method_name:String, scope:Scope, lhs:Cmd, left_type:Type, rhs:Cmd, right_type:Type, is_optional:Logical, resolve:Logical )->Cmd
      local r : Cmd
      if (left_type.has_compatible_global_method_named(method_name,left_type,right_type))
        r = CmdAccess( t, CmdAccess(t,left_type.name), method_name, CmdArgs(lhs,rhs) )
      elseIf (right_type.has_compatible_global_method_named(method_name,left_type,right_type))
        r = CmdAccess( t, CmdAccess(t,right_type.name), method_name, CmdArgs(lhs,rhs) )
      elseIf (left_type.has_compatible_method_named(method_name,right_type))
        r = CmdAccess( t, lhs, method_name, CmdArgs(rhs) )
      elseIf (is_optional)
        return null
      else
        if (left_type is right_type)
          throw t.error( "Neither global method $.$($,$) nor method $.$($) is defined." ...
              (left_type,method_name,left_type,right_type,
               left_type,method_name,right_type) )
        else
          throw t.error( "Neither global method $.$($,$), global method $.$($,$), nor method $.$($) is defined." ...
              (left_type,method_name,left_type,right_type,
               right_type,method_name,left_type,right_type,
               left_type,method_name,right_type) )
        endIf
      endIf
      if (resolve) return r.resolve( scope )
      return r

    method symbol->String
      throw t.error( "[INTERNAL] $.symbol() is not defined." (type_name) )

    method to->String
      return "$($,$)" (type_name,left,right)

    method type->Type
      return find_operation_result_type( left.require_type, right.require_type )
endClass

class CmdAdd : CmdBinary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdAdd( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real64)
        return CmdLiteralReal64(t, (left->(as CmdLiteralReal64)).value + (right->(as CmdLiteralReal64)).value )
      elseIf (common_type is Program.type_Int32)
        return CmdLiteralInt32(t, (left->(as CmdLiteralInt32)).value + (right->(as CmdLiteralInt32)).value )
      else
        return this
      endIf

    method execute( vm:VM )->Value
      return left.execute(vm) + right.execute(vm)

    method fn_name->String
      return "operator+"

    method resolve_operator_method( method_name:String, scope:Scope, lhs:Cmd, left_type:Type, rhs:Cmd, right_type:Type, &is_optional )->Cmd
      if (left_type is Program.type_String and right_type is not Program.type_String)
        # string + non-string -> "" + string.operator+(non_string)
        return CmdAccess( t, CmdAdd(t,CmdLiteralString(t,""),lhs), "operator+", CmdArgs(rhs) ).resolve( scope )
      endIf

      # Let left have a chance to invoke it's own operator+(String) before we arbitrarily convert left->String
      local possible_cmd = prior.resolve_operator_method( method_name, scope, lhs, left_type, rhs, right_type, &is_optional )
      if (possible_cmd) return possible_cmd.resolve( scope )

      if (left_type is not Program.type_String and right_type is Program.type_String)
        # non-string + string -> ("" + non-string) + string
        lhs = CmdAdd( t, CmdLiteralString(t,""), lhs ).resolve( scope )
        left_type = lhs.require_type
      endIf

      return prior.resolve_operator_method( method_name, scope, lhs, left_type, rhs, right_type, &=is_optional )

    method symbol->String
      return "+"
endClass


class CmdSubtract : CmdBinary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdSubtract( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real64)
        return CmdLiteralReal64(t, (left->(as CmdLiteralReal64)).value - (right->(as CmdLiteralReal64)).value )
      elseIf (common_type is Program.type_Int32)
        return CmdLiteralInt32(t, (left->(as CmdLiteralInt32)).value - (right->(as CmdLiteralInt32)).value )
      else
        return this
      endIf

    method execute( vm:VM )->Value
      return left.execute(vm) - right.execute(vm)

    method fn_name->String
      return "operator-"

    method symbol->String
      return "-"
endClass

class CmdMultiply : CmdBinary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdMultiply( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real64)
        return CmdLiteralReal64(t, (left->(as CmdLiteralReal64)).value * (right->(as CmdLiteralReal64)).value )
      elseIf (common_type is Program.type_Int32)
        return CmdLiteralInt32(t, (left->(as CmdLiteralInt32)).value * (right->(as CmdLiteralInt32)).value )
      else
        return this
      endIf

    method execute( vm:VM )->Value
      return left.execute(vm) * right.execute(vm)

    method fn_name->String
      return "operator*"

    method symbol->String
      return "*"
endClass


class CmdDivide : CmdBinary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdDivide( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real64)
        return CmdLiteralReal64(t, (left->(as CmdLiteralReal64)).value / (right->(as CmdLiteralReal64)).value )
      elseIf (common_type is Program.type_Int32)
        return CmdLiteralInt32(t, (left->(as CmdLiteralInt32)).value / (right->(as CmdLiteralInt32)).value )
      else
        return this
      endIf

    method execute( vm:VM )->Value
      return left.execute(vm) / right.execute(vm)

    method fn_name->String
      return "operator/"

    method symbol->String
      return "/"
endClass


class CmdMod : CmdBinary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdMod( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real64)
        return CmdLiteralReal64(t, (left->(as CmdLiteralReal64)).value % (right->(as CmdLiteralReal64)).value )
      elseIf (common_type is Program.type_Int32)
        return CmdLiteralInt32(t, (left->(as CmdLiteralInt32)).value % (right->(as CmdLiteralInt32)).value )
      else
        return this
      endIf

    method execute( vm:VM )->Value
      return left.execute(vm) % right.execute(vm)

    method resolve( scope:Scope )->Cmd
      local result = prior.resolve( scope )
      if (result.is_literal) return result

      local cmd_mod = result->(as CmdMod)
      if (not cmd_mod) return result

      return CmdAccess( t, CmdAccess(t,"Math"), "mod", CmdArgs(cmd_mod.left,cmd_mod.right) ).resolve( scope )

    method fn_name->String
      return "operator%"

    method symbol->String
      return "%"
endClass


class CmdPower : CmdBinary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdPower( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real64)
        return CmdLiteralReal64(t, (left->(as CmdLiteralReal64)).value ^ (right->(as CmdLiteralReal64)).value )
      elseIf (common_type is Program.type_Int32)
        return CmdLiteralInt32(t, (left->(as CmdLiteralInt32)).value ^ (right->(as CmdLiteralInt32)).value )
      else
        return this
      endIf

    method execute( vm:VM )->Value
      return left.execute(vm) ^ right.execute(vm)

    method fn_name->String
      return "operator^"

    method symbol->String
      return "^"
endClass


class CmdBinaryLogical : CmdBinary
  METHODS
    method combine_literal_operands( a:Logical, b:Logical )->Logical
      throw t.error( "[INTERNAL] $.combine_literal_operands(Logical,Logical) is not defined." (type_name) )

    method resolve( scope:Scope )->Cmd
      left = left.resolve( scope ).require_logical( scope )
      right = right.resolve( scope ).require_logical( scope )
      if (left.is_literal and right.is_literal)
        return CmdLiteralLogical(
            t,
            combine_literal_operands(
                left->(as CmdLiteralLogical).value,
                right->(as CmdLiteralLogical).value
              )
          )
      endIf
      return this

    method type->Type
      return Program.type_Logical
endClass

class CmdLogicalAnd : CmdBinaryLogical
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLogicalAnd( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( a:Logical, b:Logical )->Logical
      return (a and b)

    method execute( vm:VM )->Value
      return left.execute(vm)->Logical and right.execute(vm)->Logical

    method symbol->String
      return "and"
endClass


class CmdLogicalOr : CmdBinaryLogical
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLogicalOr( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( a:Logical, b:Logical )->Logical
      return (a or b)

    method execute( vm:VM )->Value
      return left.execute(vm)->Logical or right.execute(vm)->Logical

    method symbol->String
      return "or"
endClass



class CmdLogicalXor : CmdBinaryLogical
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdLogicalXor( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( a:Logical, b:Logical )->Logical
      return (a xor b)

    method execute( vm:VM )->Value
      return left.execute(vm)->Logical xor right.execute(vm)->Logical

    method symbol->String
      return "xor"
endClass


#------------------------------------------------------------------------------
# Comparison Operators
#------------------------------------------------------------------------------
class CmdComparison : CmdBinary
  PROPERTIES
    resolved : Logical

  METHODS
    method resolve_for_types( scope:Scope, left_type:Type, right_type:Type )->Cmd
      resolved = true

      if (left_type.is_compound or right_type.is_compound)
        local result = resolve_for_reference( scope, left_type, right_type, false )
        if (result) return result

        if (left_type is right_type)
          if (this instanceOf CmdCompareEQ or this instanceOf CmdCompareNE)
            # Compounds have a built-in == and !=
            return this
          endIf
          throw t.error( "Compounds of type $ cannot be compared without an operator<($) method." (left_type,left_type) )
        else
          throw t.error( "Incompatible types for comparison: $ and $." (left_type,right_type) )
        endIf

      elseIf (left_type.is_reference or right_type.is_reference)
        return resolve_for_reference( scope, left_type, right_type, true )

      endIf

      local common_type = must_find_common_type( left_type, right_type )
      left = left.cast_to( common_type, scope ).resolve( scope )
      right = right.cast_to( common_type, scope ).resolve( scope )
      if (left.is_literal and right.is_literal) return combine_literal_operands( common_type )

      return this

    method resolve_for_reference( scope:Scope, left_type:Type, right_type:Type, force_error=true:Logical )->Cmd
      throw t.error( "[INTERNAL] $.resolve_for_reference() is undefined." )

    method type->Type
      return Program.type_Logical
endClass

class CmdCompareEQ : CmdComparison
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCompareEQ( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real64)
        return CmdLiteralLogical(t, (left->(as CmdLiteralReal64)).value == (right->(as CmdLiteralReal64)).value )
      elseIf (common_type is Program.type_Int32)
        return CmdLiteralLogical(t, (left->(as CmdLiteralInt32)).value == (right->(as CmdLiteralInt32)).value )
      else
        return this
      endIf

    method execute( vm:VM )->Value
      return left.execute(vm) == right.execute(vm)

    method resolve_for_reference( scope:Scope, left_type:Type, right_type:Type, force_error=true:Logical )->Cmd
      local cmd = resolve_operator_method( "operator==", scope, left, left_type, right, right_type, &is_optional )
      if (cmd) return cmd

      cmd = resolve_operator_method( "operator<>", scope, left, left_type, right, right_type, &is_optional )
      if (cmd) return CmdCompareEQ( t, cmd, CmdLiteralInt32(t,0) ).resolve( scope )

      cmd = resolve_operator_method( "operator!=", scope, left, left_type, right, right_type, &is_optional )
      if (cmd) return CmdLogicalNot( t, cmd )

      if (force_error) resolve_operator_method( "operator==", scope, left, left_type, right, right_type )

      return null

    method symbol->String
      return "=="
endClass

class CmdCompareNE : CmdComparison
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCompareNE( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real64)
        return CmdLiteralLogical(t, (left->(as CmdLiteralReal64)).value != (right->(as CmdLiteralReal64)).value )
      elseIf (common_type is Program.type_Int32)
        return CmdLiteralLogical(t, (left->(as CmdLiteralInt32)).value != (right->(as CmdLiteralInt32)).value )
      else
        return this
      endIf

    method execute( vm:VM )->Value
      return left.execute(vm) != right.execute(vm)

    method resolve_for_reference( scope:Scope, left_type:Type, right_type:Type, force_error=true:Logical )->Cmd
      local cmd = resolve_operator_method( "operator!=", scope, left, left_type, right, right_type, &is_optional )
      if (cmd) return cmd

      cmd = resolve_operator_method( "operator==", scope, left, left_type, right, right_type, &is_optional )
      if (cmd) return CmdLogicalNot( t, cmd )

      cmd = resolve_operator_method( "operator<>", scope, left, left_type, right, right_type, &is_optional )
      if (cmd) return CmdCompareNE( t, cmd, CmdLiteralInt32(t,0) ).resolve( scope )

      if (force_error) resolve_operator_method( "operator!=", scope, left, left_type, right, right_type )

      return null

    method symbol->String
      return "!="
endClass

class CmdCompareLT : CmdComparison
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCompareLT( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real64)
        return CmdLiteralLogical(t, (left->(as CmdLiteralReal64)).value < (right->(as CmdLiteralReal64)).value )
      elseIf (common_type is Program.type_Int32)
        return CmdLiteralLogical(t, (left->(as CmdLiteralInt32)).value < (right->(as CmdLiteralInt32)).value )
      else
        return this
      endIf

    method execute( vm:VM )->Value
      return left.execute(vm) < right.execute(vm)

    method resolve_for_reference( scope:Scope, left_type:Type, right_type:Type, force_error=true:Logical )->Cmd
      local cmd = resolve_operator_method( "operator<", scope, left, left_type, right, right_type, &is_optional )
      if (cmd) return cmd

      cmd = resolve_operator_method( "operator<>", scope, left, left_type, right, right_type, &is_optional )
      if (cmd) return CmdCompareLT( t, cmd, CmdLiteralInt32(t,0) ).resolve( scope )

      cmd = resolve_operator_method( "operator>=", scope, left, left_type, right, right_type, &is_optional )
      if (cmd) return CmdLogicalNot( t, cmd )

      cmd = resolve_operator_method( "operator>", scope, right, right_type, left, left_type, &is_optional )
      if (cmd) return cmd

      if (force_error) resolve_operator_method( "operator<", scope, left, left_type, right, right_type )

      return null

    method symbol->String
      return "<"
endClass

class CmdCompareLE : CmdComparison
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCompareLE( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real64)
        return CmdLiteralLogical(t, (left->(as CmdLiteralReal64)).value <= (right->(as CmdLiteralReal64)).value )
      elseIf (common_type is Program.type_Int32)
        return CmdLiteralLogical(t, (left->(as CmdLiteralInt32)).value <= (right->(as CmdLiteralInt32)).value )
      else
        return this
      endIf

    method execute( vm:VM )->Value
      return left.execute(vm) <= right.execute(vm)

    method resolve_for_reference( scope:Scope, left_type:Type, right_type:Type, force_error=true:Logical )->Cmd
      local cmd = resolve_operator_method( "operator<=", scope, left, left_type, right, right_type, &is_optional )
      if (cmd) return cmd

      cmd = resolve_operator_method( "operator<>", scope, left, left_type, right, right_type, &is_optional )
      if (cmd) return CmdCompareLE( t, cmd, CmdLiteralInt32(t,0) ).resolve( scope )

      cmd = resolve_operator_method( "operator>", scope, left, left_type, right, right_type, &is_optional )
      if (cmd) return CmdLogicalNot( t, cmd )

      cmd = resolve_operator_method( "operator>=", scope, right, right_type, left, left_type, &is_optional )
      if (cmd) return cmd

      local strict = "operator<"
      cmd = resolve_operator_method( strict, scope, left, left_type, right, right_type, &is_optional, &!resolve )
      if (not cmd)
        swapValues left,right
        swapValues left_type,right_type
        strict = "operator>"
      endIf
      if (cmd)
        local cmd2 = resolve_operator_method( "operator==", scope, left, left_type, right, right_type, &is_optional, &!resolve )
        if (cmd2)
          local temp_block = CmdBlock( t )
          temp_block.expression_type = Program.type_Logical

          local temp_lhs = Local( left.t, Program.create_unique_id, null, left )
          local temp_lhs_decl = CmdLocalDeclaration(t,temp_lhs)
          temp_block.statements.add( temp_lhs_decl )
          local temp_rhs = Local( right.t, Program.create_unique_id, null, right )
          local temp_rhs_decl = CmdLocalDeclaration(t,temp_rhs)
          temp_block.statements.add( temp_rhs_decl )
          local a_lhs = CmdAccess(left.t, temp_lhs)
          local a_rhs = CmdAccess(right.t, temp_rhs)
          cmd = resolve_operator_method( "operator==", scope, a_lhs, left_type, a_rhs, right_type, &is_optional, &!resolve )
          cmd2 = resolve_operator_method( strict, scope, a_lhs, left_type, a_rhs, right_type, &is_optional, &!resolve )

          temp_block.statements.add( CmdLogicalOr( t, cmd, cmd2 ) )

          return temp_block.resolve(scope)
        endIf
      endIf

      if (force_error) resolve_operator_method( "operator<=", scope, left, left_type, right, right_type )

      return null

    method symbol->String
      return "<="
endClass

class CmdCompareGT : CmdComparison
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCompareGT( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real64)
        return CmdLiteralLogical(t, (left->(as CmdLiteralReal64)).value > (right->(as CmdLiteralReal64)).value )
      elseIf (common_type is Program.type_Int32)
        return CmdLiteralLogical(t, (left->(as CmdLiteralInt32)).value > (right->(as CmdLiteralInt32)).value )
      else
        return this
      endIf

    method execute( vm:VM )->Value
      return left.execute(vm) > right.execute(vm)

    method resolve_for_reference( scope:Scope, left_type:Type, right_type:Type, force_error=true:Logical )->Cmd
      local cmd = resolve_operator_method( "operator>", scope, left, left_type, right, right_type, &is_optional )
      if (cmd) return cmd

      cmd = resolve_operator_method( "operator<>", scope, left, left_type, right, right_type, &is_optional )
      if (cmd) return CmdCompareGT( t, cmd, CmdLiteralInt32(t,0) ).resolve( scope )

      cmd = resolve_operator_method( "operator<=", scope, left, left_type, right, right_type, &is_optional )
      if (cmd) return CmdLogicalNot( t, cmd )

      cmd = resolve_operator_method( "operator<", scope, right, right_type, left, left_type, &is_optional )
      if (cmd) return cmd

      if (force_error) resolve_operator_method( "operator>", scope, left, left_type, right, right_type )

      return null


    method symbol->String
      return ">"
endClass

class CmdCompareGE : CmdComparison
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCompareGE( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Real64)
        return CmdLiteralLogical(t, (left->(as CmdLiteralReal64)).value >= (right->(as CmdLiteralReal64)).value )
      elseIf (common_type is Program.type_Int32)
        return CmdLiteralLogical(t, (left->(as CmdLiteralInt32)).value >= (right->(as CmdLiteralInt32)).value )
      else
        return this
      endIf

    method execute( vm:VM )->Value
      return left.execute(vm) >= right.execute(vm)

    method resolve_for_reference( scope:Scope, left_type:Type, right_type:Type, force_error=true:Logical )->Cmd
      local cmd = resolve_operator_method( "operator>=", scope, left, left_type, right, right_type, &is_optional )
      if (cmd) return cmd

      cmd = resolve_operator_method( "operator<>", scope, left, left_type, right, right_type, &is_optional )
      if (cmd) return CmdCompareGE( t, cmd, CmdLiteralInt32(t,0) ).resolve( scope )

      cmd = resolve_operator_method( "operator<", scope, left, left_type, right, right_type, &is_optional )
      if (cmd) return CmdLogicalNot( t, cmd )

      cmd = resolve_operator_method( "operator<=", scope, right, right_type, left, left_type, &is_optional )
      if (cmd) return cmd

      local strict = "operator>"
      cmd = resolve_operator_method( strict, scope, left, left_type, right, right_type, &is_optional, &!resolve )
      if (not cmd)
        swapValues left,right
        swapValues left_type,right_type
        strict = "operator<"
      endIf
      cmd = resolve_operator_method( strict, scope, left, left_type, right, right_type, &is_optional, &!resolve )
      if (cmd)
        local cmd2 = resolve_operator_method( "operator==", scope, left, left_type, right, right_type, &is_optional, &!resolve )
        if (cmd2)
          local temp_block = CmdBlock( t )
          temp_block.expression_type = Program.type_Logical

          local temp_lhs = Local( left.t, Program.create_unique_id, null, left )
          local temp_lhs_decl = CmdLocalDeclaration(t,temp_lhs)
          temp_block.statements.add( temp_lhs_decl )
          local temp_rhs = Local( right.t, Program.create_unique_id, null, right )
          local temp_rhs_decl = CmdLocalDeclaration(t,temp_rhs)
          temp_block.statements.add( temp_rhs_decl )
          local a_lhs = CmdAccess(left.t, temp_lhs)
          local a_rhs = CmdAccess(right.t, temp_rhs)
          cmd = resolve_operator_method( "operator==", scope, a_lhs, left_type, a_rhs, right_type, &is_optional, &!resolve )
          cmd2 = resolve_operator_method( strict, scope, a_lhs, left_type, a_rhs, right_type, &is_optional, &!resolve )

          temp_block.statements.add( CmdLogicalOr( t, cmd, cmd2 ) )

          return temp_block.resolve(scope)
        endIf
      endIf

      if (force_error) resolve_operator_method( "operator>=", scope, left, left_type, right, right_type )

      return null

    method symbol->String
      return ">="
endClass

class CmdCompare : CmdComparison
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCompare( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( common_type:Type )->Cmd
      #{
      if (common_type is Program.type_Real64)
        return CmdLiteralInt32(t, (left->(as CmdLiteralReal64)).value <> (right->(as CmdLiteralReal64)).value )
      elseIf (common_type is Program.type_Int32)
        return CmdLiteralInt32(t, (left->(as CmdLiteralInt32)).value <> (right->(as CmdLiteralInt32)).value )
      else
        return this
      endIf
      }#
      return this

    method execute( vm:VM )->Value
      local lhs = left.execute( vm )
      local rhs = right.execute( vm )
      if (lhs < rhs) return -1
      if (lhs > rhs) return  1
      return 0

    method resolve_for_types( scope:Scope, left_type:Type, right_type:Type )->Cmd
      local result = prior.resolve_for_types( scope, left_type, right_type )
      if (result is this)
        # This <> operator hasn't been changed to anything else yet; change it to (a - b).sign
        return CmdAccess( t, CmdSubtract(t,left,right), "sign" ).resolve( scope )
      else
        return result
      endIf

    method resolve_for_reference( scope:Scope, left_type:Type, right_type:Type, force_error=true:Logical )->Cmd
      return resolve_operator_method( "operator<>", scope, left, left_type, right, right_type, &is_optional=not force_error )

    method symbol->String
      return "<>"

    method type->Type
      return Program.type_Int32
endClass

class CmdCompareIs : CmdComparison
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCompareIs( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method execute( vm:VM )->Value
      local lhs = left.execute( vm )
      local rhs = right.execute( vm )
      local left_obj  = lhs->Object
      local right_obj = rhs->Object
      if (left_obj or right_obj)
        return left_obj is right_obj
      else
        return lhs == rhs
      endIf

    method resolve_for_types( scope:Scope, left_type:Type, right_type:Type )->Cmd
      if (left_type.is_reference and right_type.is_reference)
        return this

      elseIf (left_type.is_primitive and right_type.is_primitive)
        return CmdCompareEQ( t, left, right ).resolve( scope )

      elseIf (left_type.is_compound and right_type.is_compound)
        throw t.error( "[INTERNAL] TODO: 'is' for compounds." )

      else
        return CmdLiteralLogical( t, false )

      endIf

    method symbol->String
      return "is"
endClass

class CmdCompareIsNot : CmdComparison
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCompareIsNot( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method execute( vm:VM )->Value
      local lhs = left.execute( vm )
      local rhs = right.execute( vm )
      local left_obj  = lhs->Object
      local right_obj = rhs->Object
      if (left_obj or right_obj)
        return left_obj is not right_obj
      else
        return lhs != rhs
      endIf

    method resolve_for_types( scope:Scope, left_type:Type, right_type:Type )->Cmd
      if (left_type.is_reference and right_type.is_reference)
        return this

      elseIf (left_type.is_primitive and right_type.is_primitive)
        return CmdCompareEQ( t, left, right ).resolve( scope )

      elseIf (left_type.is_compound and right_type.is_compound)
        throw t.error( "[INTERNAL] TODO: 'is' for compounds." )

      else
        throw t.error( "Cannot use 'is not' between mixed type categories $ and $." (left_type,right_type) )

      endIf

    method symbol->String
      return "is not"
endClass

#------------------------------------------------------------------------------
# Bitwise
#------------------------------------------------------------------------------
class CmdBitwiseOp : CmdBinary
  METHODS
    method resolve_for_common_type( scope:Scope, common_type:Type )->Cmd
      if (common_type is Program.type_Byte or common_type is Program.type_Int32)
        left  = left.cast_to( Program.type_Int32, scope ).resolve( scope )
        right = right.cast_to( Program.type_Int32, scope ).resolve( scope )
        return this
      endIf

      if (common_type is Program.type_Character)
        left  = left.cast_to( Program.type_Character, scope ).resolve( scope )
        right = right.cast_to( Program.type_Character, scope ).resolve( scope )
        return this
      endIf

      if (common_type is Program.type_Int64)
        left  = left.cast_to( Program.type_Int64, scope ).resolve( scope )
        right = right.cast_to( Program.type_Int64, scope ).resolve( scope )
        return this
      endIf

      throw t.error( "The '$' operator cannot be applied to type $." (symbol,common_type) )

    method implicit_type( scope:Scope)->Type
      local left_type = left.implicit_type( scope )
      local right_type = right.implicit_type( scope )
      if (left_type and left_type is right_type) return left_type
      return null
endClass

class CmdBitwiseFlip : CmdBitwiseOp
  METHODS
    method resolve_for_common_type( scope:Scope, common_type:Type )->Cmd
      if (common_type is Program.type_Logical)
        left  = left.cast_to( Program.type_Logical, scope ).resolve( scope )
        right = right.cast_to( Program.type_Logical, scope ).resolve( scope )
        return this
      endIf
      return prior.resolve_for_common_type( scope, common_type )
endClass

class CmdBitwiseAnd : CmdBitwiseFlip
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdBitwiseAnd( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Int32)
        return CmdLiteralInt32(t, (left->(as CmdLiteralInt32)).value & (right->(as CmdLiteralInt32)).value )
      elseIf (common_type is Program.type_Logical)
        return CmdLiteralLogical(t, (left->(as CmdLiteralLogical)).value and (right->(as CmdLiteralLogical)).value )
      else
        return this
      endIf

    method execute( vm:VM )->Value
      return (left.execute(vm)->Int64 & right.execute(vm)->Int64)

    method fn_name->String
      return "operator&"

    method symbol->String
      return "&"
endClass

class CmdBitwiseOr : CmdBitwiseFlip
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdBitwiseOr( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Int32)
        return CmdLiteralInt32(t, (left->(as CmdLiteralInt32)).value | (right->(as CmdLiteralInt32)).value )
      elseIf (common_type is Program.type_Logical)
        return CmdLiteralLogical(t, (left->(as CmdLiteralLogical)).value or (right->(as CmdLiteralLogical)).value )
      else
        return this
      endIf

    method execute( vm:VM )->Value
      return (left.execute(vm)->Int64 | right.execute(vm)->Int64)

    method fn_name->String
      return "operator|"

    method symbol->String
      return "|"
endClass

class CmdBitwiseXor : CmdBitwiseFlip
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdBitwiseXor( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Int32)
        return CmdLiteralInt32(t, (left->(as CmdLiteralInt32)).value ~ (right->(as CmdLiteralInt32)).value )
      elseIf (common_type is Program.type_Logical)
        return CmdLiteralLogical(t, (left->(as CmdLiteralLogical)).value xor (right->(as CmdLiteralLogical)).value )
      else
        return this
      endIf

    method execute( vm:VM )->Value
      return (left.execute(vm)->Int64 ~ right.execute(vm)->Int64)

    method fn_name->String
      return "operator~"

    method symbol->String
      return "~"
endClass

class CmdBitwiseShiftLeft : CmdBitwiseOp
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdBitwiseShiftLeft( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Int32)
        return CmdLiteralInt32(t, (left->(as CmdLiteralInt32)).value :<<: (right->(as CmdLiteralInt32)).value )
      else
        return this
      endIf

    method execute( vm:VM )->Value
      return (left.execute(vm)->Int64 :<<: right.execute(vm)->Int32)

    method fn_name->String
      return "operator:<<:"

    method symbol->String
      return ":<<:"
endClass

class CmdBitwiseShiftRight : CmdBitwiseOp
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdBitwiseShiftRight( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Int32)
        return CmdLiteralInt32(t, (left->(as CmdLiteralInt32)).value :<<: (right->(as CmdLiteralInt32)).value )
      else
        return this
      endIf

    method execute( vm:VM )->Value
      return (left.execute(vm)->Int64 :>>: right.execute(vm)->Int32)

    method fn_name->String
      return "operator:>>:"

    method resolve( scope:Scope )->Cmd
      local result = prior.resolve( scope )
      local cmd_shift = result->(as CmdBitwiseShiftRight)
      if (not cmd_shift) return result

      return CmdAccess( t, CmdAccess(t,"Math"), "shift_right", CmdArgs(cmd_shift.left,cmd_shift.right) ).resolve( scope )

    method symbol->String
      return ":>>:"
endClass

class CmdBitwiseShiftRightX : CmdBitwiseOp
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdBitwiseShiftRightX( t, left.cloned( clone_args, new_t ), right.cloned( clone_args, new_t ) )

    method combine_literal_operands( common_type:Type )->Cmd
      if (common_type is Program.type_Int32)
        return CmdLiteralInt32(t, (left->(as CmdLiteralInt32)).value :<<: (right->(as CmdLiteralInt32)).value )
      else
        return this
      endIf

    method execute( vm:VM )->Value
      return (left.execute(vm)->Int64 :>>>: right.execute(vm)->Int32)

    method fn_name->String
      return "operator:>>>:"

    method symbol->String
      return ":>>>:"
endClass


class CmdBitwiseNot : CmdUnary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdBitwiseNot( t, operand.cloned( clone_args, new_t ) )

    method execute( vm:VM )->Value
      return (!operand.execute(vm)->Int64)

    method fn_name->String
      return "operator!"

    method prefix_symbol->String
      return "!"

    method resolve( scope:Scope )->Cmd
      local result = prior.resolve( scope )
      local cmd_not = result->(as CmdBitwiseNot)
      if (not cmd_not) return result

      if (cmd_not.require_type is Program.type_Logical)
        throw t.error( "Use 'not' instead of '!' to invert a Logical value." )
      endIf

      return result

    method resolve_for_literal_operand( scope:Scope )->Cmd
      if (operand instanceOf CmdLiteralInt32)
        return CmdLiteralInt32(t, !(operand->(as CmdLiteralInt32)).value )
      endIf

      return this

    method type->Type
      return operand.type
endClass

#------------------------------------------------------------------------------
# adjust
#------------------------------------------------------------------------------
class CmdStep : Cmd
  PROPERTIES
    operand : Cmd
    delta   : Int32

  METHODS
    method init( t, operand, delta )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdStep( t, operand.cloned( clone_args, new_t ), delta )

    method execute( vm:VM )->Value
      return CmdAssign( t, operand, CmdAdd(t,operand,CmdLiteralInt32(t,delta)) ).execute( vm )

    method is_scoped_read_access->Logical
      return true

    method resolve( scope:Scope )->Cmd
      operand = operand.resolve( scope ).require_value
      return operand.resolve_adjust( scope, delta )
endClass

class CmdStepLocal : Cmd
  PROPERTIES
    local_info : Local
    delta      : Int32

  METHODS
    method init( t, local_info, delta )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local task_args = clone_args->(as TaskArgs)
      if (task_args)
        return CmdStep( t, CmdAccess(t, task_args.cmd_read_this(t), task_args.convert_local_name(local_info)), delta )
      else
        return CmdStepLocal( t, local_info, delta )
      endIf

    method execute( vm:VM )->Value
      local v = require( vm.find_local(local_info.name) )
      v.value += delta
      return UndefinedValue

    method is_scoped_read_access->Logical
      return true

    method resolve( scope:Scope )->Cmd
      if (local_info.type.is_compound)
        return CmdWriteLocal( t, local_info,
          CmdAccess( t,
                     CmdReadLocal(t,local_info),
                     "operator+",
                     CmdLiteralInt32(t,delta)
          ) ).resolve( scope )
      endIf
      return this

    method to->String
      return "CmdStepLocal($)" (local_info.name)

    method type->Type
      return local_info.type

endClass


class CmdStepProperty : Cmd
  PROPERTIES
    context       : Cmd
    property_info : Property
    delta         : Int32

  METHODS
    method init( t, context, property_info, delta )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdStepProperty( t, context.cloned( clone_args, new_t ), property_info, delta )

    method execute( vm:VM )->Value
      local obj = context.execute( vm )->Object
      if (obj)
        local type = obj.type_info
        local p = type.find_property( property_info.name )
        if (p)
          type.set_property( obj, p, type.property(obj,p) + delta )
        endIf
      endIf
      return UndefinedValue

    method is_scoped_read_access->Logical
      return true

    method resolve( scope:Scope )->Cmd
      context = context.resolve( scope ).require_value
      if (property_info.type.is_compound)
        return CmdWriteProperty( t, context.cloned, property_info,
          CmdAccess( t,
                     CmdReadProperty(t,context,property_info),
                     "operator+",
                     CmdLiteralInt32(t,delta)
          ) ).resolve( scope )
      endIf
      return this

    method type->Type
      return null

endClass


class CmdStepGlobal : Cmd
  PROPERTIES
    global_info : Property
    delta       : Int32

  METHODS
    method init( t, global_info, delta )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdStepGlobal( t, global_info, delta )

    method execute( vm:VM )->Value
      local type = TypeInfo[ global_info.type_context ]
      if (type)
        local p = type.find_global_property( global_info.name )
        if (p)
          type.set_global_property( p, type.global_property(p) + delta )
        endIf
      endIf
      return UndefinedValue

    method resolve( scope:Scope )->Cmd
      if (global_info.type.is_compound)
        return CmdWriteGlobal( t, global_info,
          CmdAccess( t,
                     CmdReadGlobal(t,global_info),
                     "operator+",
                     CmdLiteralInt32(t,delta)
          ) ).resolve( scope )
      endIf
      return this

    method type->Type
      return null

endClass


#------------------------------------------------------------------------------
# ModifyAndAssign
#------------------------------------------------------------------------------
class CmdModifyAndAssign : Cmd
  PROPERTIES
    target    : Cmd
    op        : TokenType
    new_value : Cmd

  METHODS
    method init( t, target, op, new_value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdModifyAndAssign( t, target.cloned( clone_args, new_t ), op, new_value.cloned( clone_args, new_t ) )

    method execute( vm:VM )->Value
      local op_cmd : Cmd
      which (op)
        case TokenType.symbol_ampersand_equals:    op_cmd = CmdBitwiseAnd( t, target, new_value )
        case TokenType.symbol_caret_equals:        op_cmd = CmdPower( t, target, new_value )
        #case TokenType.symbol_dot_equals:          op_cmd = CmdAccess( t, this, name, new_value )
        case TokenType.symbol_minus_equals:        op_cmd = CmdSubtract( t, target, new_value )
        case TokenType.symbol_percent_equals:      op_cmd = CmdMod( t, target, new_value )
        case TokenType.symbol_plus_equals:         op_cmd = CmdAdd( t, target, new_value )
        case TokenType.symbol_slash_equals:        op_cmd = CmdDivide( t, target, new_value )
        case TokenType.symbol_tilde_equals:        op_cmd = CmdBitwiseXor( t, target, new_value )
        case TokenType.symbol_times_equals:        op_cmd = CmdMultiply( t, target, new_value )
        case TokenType.symbol_vertical_bar_equals: op_cmd = CmdBitwiseOr( t, target, new_value )
        others
          @trace
          throw t.error( "[INTERNAL]" )
      endWhich
      return CmdAssign( t, target, op_cmd ).execute( vm )

    method is_scoped_read_access->Logical
      return true

    method resolve( scope:Scope )->Cmd
      return target.resolve_modify_and_assign( scope, op, new_value )
endClass

class CmdResolvedModifyAndAssign : Cmd [abstract]
  PROPERTIES
    op         : TokenType
    new_value  : Cmd

  METHODS
    method is_scoped_read_access->Logical
      return true

    method execute( vm:VM )->Value
      local op_target = execution_target
      local op_cmd : Cmd
      which (op)
        case TokenType.symbol_ampersand_equals:    op_cmd = CmdBitwiseAnd( t, op_target, new_value )
        case TokenType.symbol_caret_equals:        op_cmd = CmdPower( t, op_target, new_value )
        #case TokenType.symbol_dot_equals:          op_cmd = CmdAccess( t, op_target, name, new_value )
        case TokenType.symbol_minus_equals:        op_cmd = CmdSubtract( t, op_target, new_value )
        case TokenType.symbol_percent_equals:      op_cmd = CmdMod( t, op_target, new_value )
        case TokenType.symbol_plus_equals:         op_cmd = CmdAdd( t, op_target, new_value )
        case TokenType.symbol_slash_equals:        op_cmd = CmdDivide( t, op_target, new_value )
        case TokenType.symbol_tilde_equals:        op_cmd = CmdBitwiseXor( t, op_target, new_value )
        case TokenType.symbol_times_equals:        op_cmd = CmdMultiply( t, op_target, new_value )
        case TokenType.symbol_vertical_bar_equals: op_cmd = CmdBitwiseOr( t, op_target, new_value )
        others
          @trace
          throw t.error( "[INTERNAL]" )
      endWhich
      return CmdAssign( t, op_target, op_cmd ).execute( vm )

    method execution_target->Cmd [abstract]

    method symbol->String
      if (op is TokenType.symbol_tilde_equals) return "^="
      return op->String

endClass

class CmdModifyAndAssignLocal : CmdResolvedModifyAndAssign
  PROPERTIES
    local_info : Local

  METHODS
    method init( t, local_info, op, new_value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local task_args = clone_args->(as TaskArgs)
      if (task_args)
        return CmdModifyAndAssign( t, CmdAccess(t,CmdThisContext(t,task_args.task_type),"$_$"(local_info.name,local_info.index)), op, new_value.cloned(task_args) )
      else
        return CmdModifyAndAssignLocal( t, local_info, op, new_value.cloned( clone_args, new_t ) )
      endIf

    method execution_target->Cmd
      return CmdAccess( t, local_info.name )

    method is_scoped_read_access->Logical
      return true

    method resolve( scope:Scope )->Cmd
      local m_name = "operator" + op->String
      if (local_info.type.is_reference)
        if (local_info.type.method_lookup_by_name[m_name])
          return CmdAccess( t, CmdReadLocal(t,local_info), m_name, new_value ).resolve( scope )
        else
          new_value = new_value.resolve( scope ).require_value
          m_name = m_name.leftmost(-1)  # operator+= -> operator+
          if (local_info.type.method_lookup_by_name[m_name])
            return CmdWriteLocal( t, local_info,
            CmdAccess( t, CmdReadLocal(t,local_info), m_name, new_value ) ).resolve( scope )
          elseIf (local_info.type.global_method_lookup_by_name[m_name])
            return CmdWriteLocal( t, local_info,
              CmdAccess( t, CmdAccess(t,local_info.type.name), m_name,
                CmdArgs( CmdReadLocal(t,local_info), new_value ) ) ).resolve( scope )
          elseIf (new_value.type.global_method_lookup_by_name[m_name])
            return CmdWriteLocal( t, local_info,
                CmdAccess( t, CmdAccess(t,new_value.type.name), m_name,
                CmdArgs( CmdReadLocal(t,local_info), new_value ) ) ).resolve( scope )
          else
            local arg_type = new_value.require_type
            throw t.error( "No suitable operator method found; type $ implements neither $()($), $=($), nor global method $()(2)." (local_info.type,m_name,arg_type.name,m_name,arg_type.name,m_name) )
          endIf
        endIf
      elseIf (local_info.type.is_compound)
        return CmdWriteLocal( t, local_info,
            CmdAccess( t, CmdReadLocal(t,local_info), m_name.leftmost(-1), new_value ) ).resolve( scope )
      endIf

      which (op)
        case TokenType.symbol_caret_equals
          #if (RogueC.compile_targets["C++"])
          return CmdWriteLocal( t, local_info, CmdPower(t,CmdReadLocal(t,local_info),new_value) ).resolve( scope )

        case TokenType.symbol_percent_equals
          # Mod has be be expanded because Rogue uses a special mod function
          #if (RogueC.compile_targets["C++"])
          return CmdWriteLocal( t, local_info, CmdMod(t,CmdReadLocal(t,local_info),new_value) ).resolve( scope )

        case TokenType.symbol_dot_equals
          local access = new_value->(as CmdAccess)
          if (not access) throw new_value.t.error( "Property or method name expected." )
          if (access.context) throw access.t.error( "Property or method name expected - '.=' cannot be used with a chain of references." )
          access.context = CmdReadLocal( t, local_info )
          return CmdWriteLocal( t, local_info, access ).resolve( scope )
      endWhich

      #new_value = new_value.resolve( scope ).cast_to( local_info.type, scope ).resolve( scope )
      new_value = new_value.resolve( scope )
      return this

    method type->Type
      return local_info.type
endClass


class CmdModifyAndAssignGlobal : CmdResolvedModifyAndAssign
  PROPERTIES
    global_info : Property

  METHODS
    method init( t, global_info, op, new_value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdModifyAndAssignGlobal( t, global_info, op, new_value.cloned( clone_args, new_t ) )

    method execution_target->Cmd
      return CmdAccess( t, CmdAccess(t,global_info.type_context.name), global_info.name )

    method resolve( scope:Scope )->Cmd
      local m_name = "operator" + op->String
      if (global_info.type.is_reference)
        if (global_info.type.method_lookup_by_name[m_name])
          return CmdAccess( t, CmdReadGlobal(t,global_info), m_name, new_value ).resolve( scope )
        else
          new_value = new_value.resolve( scope ).require_value
          m_name = m_name.leftmost(-1)  # operator+= -> operator+
          if (global_info.type.method_lookup_by_name[m_name])
            return CmdWriteGlobal( t, global_info,
              CmdAccess(t, CmdReadGlobal(t,global_info), m_name, new_value) ).resolve( scope )
          elseIf (global_info.type.global_method_lookup_by_name[m_name])
            return CmdWriteGlobal( t, global_info,
              CmdAccess( t, CmdAccess(t,global_info.type.name), m_name,
              CmdArgs( CmdReadGlobal(t,global_info), new_value ) ) ).resolve( scope )
          elseIf (new_value.type.global_method_lookup_by_name[m_name])
            return CmdWriteGlobal( t, global_info,
              CmdAccess( t, CmdAccess(t,new_value.type.name), m_name,
              CmdArgs( CmdReadGlobal(t,global_info), new_value ) ) ).resolve( scope )
          else
            local arg_type = new_value.type.name
            throw t.error( "No suitable operator method found; type $ implements neither $()($) nor $=($)." (global_info.type,m_name,arg_type,m_name,arg_type) )
          endIf
        endIf

      elseIf (global_info.type.is_compound)
        return CmdWriteGlobal( t, global_info,
          CmdAccess( t, CmdReadGlobal(t,global_info), m_name.leftmost(-1), new_value ) ).resolve( scope )
      endIf

      which (op)
        case TokenType.symbol_caret_equals
          #if (RogueC.compile_targets["C++"])
          return CmdWriteGlobal( t, global_info, CmdPower(t,CmdReadGlobal(t,global_info),new_value) ).resolve( scope )

        case TokenType.symbol_percent_equals
          # Mod has be be expanded because Rogue uses a special mod function
          #if (RogueC.compile_targets["C++"])
          return CmdWriteGlobal( t, global_info, CmdMod(t,CmdReadGlobal(t,global_info),new_value) ).resolve( scope )

        case TokenType.symbol_dot_equals
          local access = new_value->(as CmdAccess)
          if (not access) throw new_value.t.error( "Property or method name expected." )
          if (access.context) throw access.t.error( "Property or method name expected - '.=' cannot be used with a chain of references." )
          access.context = CmdReadGlobal( t, global_info )
          return CmdWriteGlobal( t, global_info, access ).resolve( scope )
      endWhich

      new_value = new_value.resolve( scope )
      #new_value = new_value.resolve(scope).cast_to( global_info.type, scope ).resolve( scope )
      return this

    method type->Type
      return global_info.type
endClass

class CmdModifyAndAssignProperty : CmdResolvedModifyAndAssign
  PROPERTIES
    context       : Cmd
    property_info : Property

  METHODS
    method init( t, context, property_info, op, new_value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdModifyAndAssignProperty( t, context.cloned( clone_args, new_t ), property_info, op, new_value.cloned( clone_args, new_t ) )

    method execution_target->Cmd
      return CmdAccess( t, context, property_info.name )

    method resolve( scope:Scope )->Cmd
      local m_name = "operator" + op->String
      if (property_info.type.is_reference)
        if (property_info.type.method_lookup_by_name[m_name])
          return CmdAccess( t, CmdReadProperty(t,context,property_info), m_name, new_value ).resolve( scope )
        else
          m_name = m_name.leftmost(-1)  # operator+= -> operator+
          new_value = new_value.resolve( scope ).require_value
          if (property_info.type.method_lookup_by_name[m_name])
            return CmdWriteProperty( t, context, property_info,
            CmdAccess(t, CmdReadProperty(t,clone(context),property_info), m_name, new_value) ).resolve( scope )
          elseIf (property_info.type.has_global_method_named(m_name))
            return CmdWriteProperty( t, context, property_info,
            CmdAccess(t, CmdAccess(t,property_info.type.name), m_name, CmdArgs(CmdReadProperty(t,clone(context),property_info), new_value)) ).resolve( scope )
          elseIf (new_value.type.has_global_method_named(m_name))
            return CmdWriteProperty( t, context, property_info,
            CmdAccess(t, CmdAccess(t,new_value.type.name), m_name, CmdArgs(CmdReadProperty(t,clone(context),property_info), new_value)) ).resolve( scope )
          else
            local arg_type = new_value.type.name
            throw t.error( "No suitable operator method found; type $ implements neither $()($) nor $=($)." (property_info.type,m_name,arg_type,m_name,arg_type) )
          endIf
        endIf

      elseIf (property_info.type.is_compound)
        return CmdWriteProperty( t, clone(context), property_info,
          CmdAccess( t, CmdReadProperty(t,context,property_info), m_name.leftmost(-1), new_value ) ).resolve( scope )
      endIf

      which (op)
        case TokenType.symbol_caret_equals
          #if (RogueC.compile_targets["C++"])
          return CmdWriteProperty( t, context, property_info, CmdPower(t,CmdReadProperty(t,clone(context),property_info),new_value) ).resolve( scope )

        case TokenType.symbol_percent_equals
          # Mod has be be expanded because Rogue uses a special mod function
          #if (RogueC.compile_targets["C++"])
          return CmdWriteProperty( t, context, property_info, CmdMod(t,CmdReadProperty(t,clone(context),property_info),new_value) ).resolve( scope )

        case TokenType.symbol_dot_equals
          local access = new_value->(as CmdAccess)
          if (not access) throw new_value.t.error( "Property or method name expected." )
          if (access.context) throw access.t.error( "Property or method name expected - '.=' cannot be used with a chain of references." )
          access.context = CmdReadProperty( t, clone(context), property_info )
          return CmdWriteProperty( t, context, property_info, access ).resolve( scope )
      endWhich

      context = context.resolve(scope).require_value
      new_value = new_value.resolve( scope )
      #new_value = new_value.resolve(scope).cast_to( property_info.type, scope ).resolve( scope )
      return this

    method type->Type
      return property_info.type
endClass

#------------------------------------------------------------------------------
# Arrays
#------------------------------------------------------------------------------
class CmdCreateArray : Cmd
  PROPERTIES
    array_type   : Type
    count_cmd    : Cmd

  METHODS
    method init( t, array_type, args:CmdArgs )
      if (args is null or args.count != 1)
        throw t.error( "Array count expected." )
      endIf
      count_cmd = args.first

    method init( t, array_type, count_cmd )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCreateArray( t, array_type, count_cmd.cloned( clone_args, new_t ) )

    method resolve( scope:Scope )->Cmd
      array_type.organize(scope, t)
      count_cmd = count_cmd.resolve(scope).require_integer
      return this

    method type->Type
      return array_type
endClass

class CmdReadArrayElement : Cmd
  PROPERTIES
    context    : Cmd
    array_type : Type
    index      : Cmd

  METHODS
    method init( t, context, index )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local result = CmdReadArrayElement( t, context.cloned( clone_args, new_t ), index.cloned( clone_args, new_t ) )
      result.array_type = array_type
      return result

    method resolve( scope:Scope )->Cmd
      context = context.resolve(scope)
      array_type = context.require_type
      index = index.resolve(scope).require_integer
      return this

    method resolve_adjust( scope:Scope, delta:Int32 )->Cmd
      return CmdWriteArrayElement( t, context, index.cloned, CmdAdd(t,this,CmdLiteralInt32(t,delta)) ).resolve( scope )

    method to->String
      return "CmdReadArrayElement($[$])" (context,index)

    method type->Type
      return array_type.element_type
endClass

class CmdWriteArrayElement : Cmd
  PROPERTIES
    context    : Cmd
    array_type : Type
    index      : Cmd
    new_value  : Cmd

  METHODS
    method init( t, context, index, new_value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdWriteArrayElement( t, context.cloned( clone_args, new_t ), index.cloned( clone_args, new_t ), new_value.cloned( clone_args, new_t ) )

    method resolve( scope:Scope )->Cmd
      if (array_type) return this

      context = context.resolve(scope)
      array_type = context.require_type
      index = index.resolve(scope).require_integer
      new_value = new_value.resolve( scope ).require_value.cast_to( array_type.element_type, scope ).resolve( scope )
      return this

    method type->Type
      return array_type.element_type
endClass


#------------------------------------------------------------------------------
# Type Checks and Conversions
#------------------------------------------------------------------------------
class CmdTypeOperator : Cmd
  PROPERTIES
    operand     : Cmd
    target_type : Type

  METHODS
    method init( t, operand, target_type )

    method type->Type
      return target_type
endClass


class CmdCastToType : CmdTypeOperator
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCastToType( t, operand.cloned( clone_args, new_t ), target_type )

    method execute( vm:VM )->Value
      return operand.execute( vm )  # pass-through

    method resolve( scope:Scope )->Cmd
      operand = operand.resolve( scope )
      target_type.organize(scope, t)
      if (operand.require_type is target_type) return operand
      return this
endClass

class CmdConvertToType : CmdTypeOperator
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdConvertToType( t, operand.cloned( clone_args, new_t ), target_type )

    method execute( vm:VM )->Value
      local to_type = TypeInfo[ target_type.name ]
      if (not to_type) throw t.error( "No such metatype $." (target_type.name) )
      local context = operand.execute( vm )
      if (context.is_object or context.is_string)
        local obj = context->Object
        if (obj is null) throw t.error( "Null context for conversion." )
        local m_convert = obj.type_info.find_method( "to_$()"(to_type.name) )
        if (not m_convert) throw t.error( "$ does not define to->$()." (obj.type_name,to_type.name) )
        return m_convert( @[context] )
      elseIf (to_type is vm.type_Real64)
        return context->Real64->Value
      elseIf (to_type is vm.type_Real32)
        return context->Real32->Value
      elseIf (to_type is vm.type_Int64)
        return context->Int64->Value
      elseIf (to_type is vm.type_Int32)
        return context->Int32->Value
      elseIf (to_type is vm.type_Character)
        return Value(context->Character)
      elseIf (to_type is vm.type_Byte)
        return context->Byte->Value
      elseIf (to_type is vm.type_Logical)
        return context->Logical->Value
      else
        throw t.error( "Cannot convert $ to $." (context,to_type) )
      endIf

    method resolve( scope:Scope )->Cmd
      operand = operand.resolve( scope )
      if ((operand instanceOf CmdCallMethod) and (operand->(as CmdCallMethod))._is_call_via_methodinfo)
        noAction
      else
        operand = operand.require_value
      endIf
      return operand.cast_to( target_type, scope, &is_conversion ).resolve( scope ).resolve( scope )

    method to->String
      return "CmdConvertToType($,$)" (operand,target_type)

    method implicit_type( scope:Scope)->Type
      return target_type
endClass

class CmdAs : CmdTypeOperator
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdAs( t, operand.cloned( clone_args, new_t ), target_type )

    method execute( vm:VM )->Value
      local obj_value = operand.execute( vm )
      local obj = obj_value->Object
      if (obj)
        local type = obj.type_info
        local as_type = TypeInfo[ target_type.name ]
        if (as_type)
          if (type.instance_of(as_type))
            return obj_value
          endIf
        endIf
      endIf
      return NullValue

    method resolve( scope:Scope )->Cmd
      operand = operand.resolve( scope )
      local operand_type = operand.require_type
      target_type.organize(scope, t)
      if (operand_type is target_type) return operand

      if (not (operand_type.is_reference and target_type.is_reference))
        return target_type.create_default_value( t )
      endIf
      return this

    method implicit_type( scope:Scope )->Type
      return target_type
endClass

class CmdInstanceOf : CmdTypeOperator
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdInstanceOf( t, operand.cloned( clone_args, new_t ), target_type )

    method execute( vm:VM )->Value
      local obj_value = operand.execute( vm )
      local obj = obj_value->Object
      if (obj)
        local type = obj.type_info
        local as_type = TypeInfo[ target_type.name ]
        if (as_type)
          if (type.instance_of(as_type))
            return true
          endIf
        endIf
      endIf
      return false

    method resolve( scope:Scope )->Cmd
      operand = operand.resolve( scope ).require_value

      local operand_type = operand.type

      if (operand instanceOf CmdReadSingleton or operand instanceOf CmdThisType)
        # All type references start as "CmdReadSingleton" whether the type is actually a singleton or not
        # Comparing a type to a type or a singleton object to a type
        # If target type is not instanceOf the operand type then we're not trying to check a singleton object
        # but rather just compare two types.
        if (not operand_type.is_reference or not target_type.instance_of(operand_type))
          return CmdLiteralLogical( t, operand_type.instance_of(target_type) )
        endIf

        operand_type.organize( scope, t )
        if (not operand_type.is_singleton)
          return CmdLiteralLogical( t, operand_type.instance_of(target_type) )
        endIf
      endIf

      if (not operand_type.is_reference)
        if (operand_type is Program.type_Logical)
          throw t.error( "Illegal logical operand for instanceOf - note that correct syntax is '<expression> not instanceOf Type' rather than 'not <expression> instanceOf Type'." )
        else
          throw t.error( "Illegal 'instanceOf' on non-reference." )
        endIf
      endIf
      target_type.organize(scope, t)
      return this

    method type->Type
      return Program.type_Logical
endClass

class CmdIsType : CmdTypeOperator
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdIsType( t, operand.cloned( clone_args, new_t ), target_type )

    method execute( vm:VM )->Value
      local obj_value = operand.execute( vm )
      local obj = obj_value->Object
      if (obj)
        local type = obj.type_info
        local as_type = TypeInfo[ target_type.name ]
        if (as_type)
          return type is as_type
        endIf
      endIf
      return false

    method resolve( scope:Scope )->Cmd
      operand = operand.resolve( scope ).require_value

      local operand_type = operand.type

      if (operand instanceOf CmdReadSingleton or operand instanceOf CmdThisType)
        # All type references start as "CmdReadSingleton" whether the type is actually a singleton or not
        # Comparing a type to a type or a singleton object to a type
        # If target type is not instanceOf the operand type then we're not trying to check a singleton object
        # but rather just compare two types.
        if (not operand_type.is_reference or target_type is not operand_type)
          return CmdLiteralLogical( t, operand_type is target_type )
        endIf

        operand_type.organize( scope, t )
        if (not operand_type.is_singleton)
          return CmdLiteralLogical( t, operand_type is target_type )
        endIf
      endIf

      if (not operand_type.is_reference)
        if (operand_type is Program.type_Logical)
          throw t.error( "Illegal logical operand for instanceOf - note that correct syntax is '<expression> not instanceOf Type' rather than 'not <expression> instanceOf Type'." )
        else
          throw t.error( "Illegal 'instanceOf' on non-reference." )
        endIf
      endIf
      target_type.organize(scope, t)
      return this

    method type->Type
      return Program.type_Logical
endClass


class CmdIsAspect( t, operand:Cmd ) : Cmd
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdIsAspect( t, operand.cloned( clone_args, new_t ) )

    method execute( vm:VM )->Value
      local obj = operand.execute( vm )->Object
      return (obj and obj.type_info.is_aspect)

    method implicit_type( scope:Scope )->Type
      return Program.type_Logical

    method resolve( scope:Scope )->Cmd
      return CmdLiteralLogical( t, operand.resolve(scope).require_type.is_aspect )

    method type->Type
      return Program.type_Logical
endClass

class CmdIsClass( t, operand:Cmd ) : Cmd
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdIsClass( t, operand.cloned( clone_args, new_t ) )

    method execute( vm:VM )->Value
      local obj = operand.execute( vm )->Object
      return (obj and obj.type_info.is_class)

    method implicit_type( scope:Scope )->Type
      return Program.type_Logical

    method resolve( scope:Scope )->Cmd
      return CmdLiteralLogical( t, operand.resolve(scope).require_type.is_class )

    method type->Type
      return Program.type_Logical
endClass

class CmdIsComparable( t, left, right ) : CmdBinary
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdIsComparable( t, left.cloned(clone_args,new_t), right.cloned(clone_args,new_t) )

    method implicit_type( scope:Scope )->Type
      return Program.type_Logical

    method resolve( scope:Scope )->Cmd
      left = left.resolve( scope ).require_value
      right = right.resolve( scope ).require_value
      local left_type = left.type
      local right_type = right.type

      if (left_type.is_primitive and right_type.is_primitive) return CmdLiteralLogical( t, true )

      local cmd = resolve_operator_method( "operator<", scope, left, left_type, right, right_type, &is_optional )
      if (not cmd)
        cmd = resolve_operator_method( "operator<>", scope, left, left_type, right, right_type, &is_optional )
        if (not cmd )cmd = resolve_operator_method( "operator>", scope, right, right_type, left, left_type, &is_optional )
      endIf

      return CmdLiteralLogical( t, cmd? )

    method type->Type
      return Program.type_Logical
endClass


class CmdIsCompound( t, operand:Cmd ) : Cmd
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdIsCompound( t, operand.cloned( clone_args, new_t ) )

    method execute( vm:VM )->Value
      local obj = operand.execute( vm )->Object
      return (obj and obj.type_info.is_compound)

    method implicit_type( scope:Scope )->Type
      return Program.type_Logical

    method resolve( scope:Scope )->Cmd
      return CmdLiteralLogical( t, operand.resolve(scope).require_type.is_compound )

    method type->Type
      return Program.type_Logical
endClass

class CmdIsPrimitive( t, operand:Cmd ) : Cmd
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdIsPrimitive( t, operand.cloned( clone_args, new_t ) )

    method implicit_type( scope:Scope )->Type
      return Program.type_Logical

    method execute( vm:VM )->Value
      local obj = operand.execute( vm )->Object
      return (obj and obj.type_info.is_primitive)

    method resolve( scope:Scope )->Cmd
      return CmdLiteralLogical( t, operand.resolve(scope).require_type.is_primitive )

    method type->Type
      return Program.type_Logical
endClass

class CmdIsReference( t, operand:Cmd ) : Cmd
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdIsReference( t, operand.cloned( clone_args, new_t ) )

    method execute( vm:VM )->Value
      local obj = operand.execute( vm )->Object
      return (obj and obj.type_info.is_reference)

    method implicit_type( scope:Scope )->Type
      return Program.type_Logical

    method resolve( scope:Scope )->Cmd
      return CmdLiteralLogical( t, operand.resolve(scope).require_type.is_reference )

    method type->Type
      return Program.type_Logical
endClass

class CmdIsString( t, operand:Cmd ) : Cmd
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdIsString( t, operand.cloned( clone_args, new_t ) )

    method execute( vm:VM )->Value
      local obj = operand.execute( vm )->Object
      return (obj and obj.type_info is vm.type_String)

    method implicit_type( scope:Scope )->Type
      return Program.type_Logical

    method resolve( scope:Scope )->Cmd
      return CmdLiteralLogical( t, operand.resolve(scope).require_type is Program.type_String )

    method type->Type
      return Program.type_Logical
endClass


#------------------------------------------------------------------------------
# Collections
#------------------------------------------------------------------------------
class CmdCreateList : Cmd
  PROPERTIES
    elements   : CmdArgs

  METHODS
    method init( t, elements )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCreateList( t, clone(elements,clone_args,new_t) )

    method execute( vm:VM )->Value
      return elements.execute( vm )  # returns a ValueList

    method implicit_type( scope:Scope )->Type
      if (elements.count == 0) return Program.get_type_reference( t, "ValueList" )

      local common_type = elements.first.implicit_type( scope )
      if (not common_type) return null

      forEach (arg in elements)
        local arg_type = arg.implicit_type( scope )
        if (arg_type is not common_type) return null
      endForEach

      return Program.get_type_reference( t, common_type.name + "[]" )

    method resolve( scope:Scope )->Cmd
      local list_type : Type

      elements.resolve( scope )
      if (not list_type and elements.count)
        local common_type = elements.first.type
        forEach (arg in elements)
          common_type = find_common_type( common_type, arg.type )
        endForEach
        list_type = Program.get_type_reference( t, common_type + "[]" )
        list_type.organize(scope, t)
      endIf

      if (list_type)
        local element_type = list_type.element_type
        forEach (index of elements)
          elements[index] = elements[index].resolve( scope ).cast_to( element_type, scope ).resolve( scope )
        endForEach
      endIf

      if (not list_type) throw t.error( "TODO: [] -> Property[]" )

      return CmdTypedLiteralList( CmdAccess(t,list_type.name), elements ).resolve( scope )

endClass


#------------------------------------------------------------------------------
# Task-Related
#------------------------------------------------------------------------------
class CmdAwait : Cmd
  PROPERTIES
    expression     : Cmd
    statement_list : CmdStatementList
    result_var     : Local

  METHODS
    method init( t, expression, statement_list, result_var=null )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local task_args = clone_args->(as TaskArgs)
      if (task_args)
        throw t.error( "[INTERNAL] CmdAwait should have been converted to other commands before being adapted to a task." )
      else
        return CmdAwait( t, expression.cloned(task_args), statement_list.cloned(task_args), result_var )
      endIf

    method resolve( scope:Scope )->Cmd
      if (not scope.this_method.is_task_conversion)
        throw t.error( "The 'await' command can only be used in [task] methods and routines." )
      endIf

      expression = expression.resolve( scope )
      local task_type = expression.require_type
      local p_result = task_type.find_property( "result" )
      if (result_var)
        if (p_result)
          # Fix up local 'result' type to match task result type
          result_var.type = p_result.type
        else
          throw expression.t.error( "Called task does not produce a result." )
        endIf
      endIf

      local task_var = Local( t, Program.create_unique_id )
      task_var.initial_value = expression
      statement_list.add( CmdLocalDeclaration(t, task_var) )
      statement_list.add( CmdAssign( t, CmdAccess(t,CmdReadLocal(t,task_var),"has_result"), CmdLiteralLogical(t,false) ) )

      local condition = CmdAccess(t,CmdReadLocal(t,task_var),"execute") : Cmd
      condition = CmdLogicalOr( t, condition, CmdLogicalNot(t,CmdAccess(t,CmdReadLocal(t,task_var),"has_result")) )
      local cmd_while = CmdGenericLoop( t, CmdControlStructure.type_while, condition )
      cmd_while.statements.add( CmdYield(t,null) )
      statement_list.add( cmd_while )

      if (result_var)
        statement_list.add( CmdWriteLocal(t, result_var, CmdReadProperty(t,CmdReadLocal(t,task_var),p_result)) )
      endIf

      statement_list.resolve( scope )
      return CmdBlock( t, statement_list ).resolve( scope )
endClass

class CmdYield : Cmd
  PROPERTIES
    return_value : Cmd

  METHODS
    method init( t, return_value )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local task_args = clone_args->(as TaskArgs)
      if (task_args)
        task_args.add_yield( t, clone(return_value,clone_args,new_t) )
        return null
      else
        return CmdYield( t, clone(return_value,clone_args,new_t) )
      endIf

    method resolve( scope:Scope )->Cmd
      if (not scope.this_method.is_task_conversion)
        throw t.error( "The 'yield' statement can only be used in [task] methods and routines." )
      endIf

      if (return_value) return_value = return_value.resolve( scope ).require_value

      forEach (control_structure in scope.control_stack)
        control_structure.contains_yield = true
      endForEach

      return this
endClass

class CmdTaskControlSection
  PROPERTIES
    ip : Int32
    statements = CmdStatementList()

  METHODS
    method init( ip )
endClass

class CmdTaskControl : Cmd
  PROPERTIES
    sections = CmdTaskControlSection[]
    current_section : CmdTaskControlSection

  METHODS
    method init( t )
      current_section = CmdTaskControlSection(1)
      sections.add( current_section )

    method add( cmd:Cmd )->CmdTaskControl
      current_section.statements.add( cmd )
      return this

    method requires_semicolon->Logical
      return false

    method resolve( scope:Scope )->Cmd
      forEach (section in sections)
        section.statements.resolve( scope )
      endForEach
      return this

endClass


#------------------------------------------------------------------------------
# Callbacks
#------------------------------------------------------------------------------
class CmdCreateCallback( t, context:Cmd, name:String, signature:String, return_type:Type,
    is_dynamically_specialized:Logical, specializing_signature:Cmd ) : Cmd
  METHODS
    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdCreateCallback
      if (new_t) t = new_t
      return CmdCreateCallback( t, context.cloned( clone_args, new_t ), name, signature, return_type,
        is_dynamically_specialized, clone(specializing_signature,clone_args) )

    method resolve( scope:Scope )->Cmd
      if (name == "to" and return_type) name = "to_" + return_type.name

      context = context.resolve( scope )
      local context_type = context.require_type
      context_type.organize(scope, t)

      local m = context_type.find_method( name + signature )
      if (not m)
        local methods = context_type.method_lookup_by_name[ name ]
        if (not methods) methods = context_type.global_method_lookup_by_name[ name ]
        if (not methods)        throw t.error( "No such method '$' exists in type $." (name,context_type.name) )
        if (methods.count != 1) throw t.error( "Multiple candidates match ambiguous reference to '$'; add qualifiying parameter types." (name) )
        m = methods.first
      endIf

      local parameter_types : Type[]
      if (m.parameters.count)
        parameter_types = Type[]
        forEach (p in m.parameters) parameter_types.add( p.type )
      endIf

      local separator = which{ is_dynamically_specialized:"->" || "." }
      local callback_type_name = context_type.name + separator + name + Program.get_callback_type_signature(parameter_types)
      local callback_type = Program.get_type_reference( t, callback_type_name )

      if (not callback_type.is_defined)
        callback_type.is_defined = true
        callback_type.attributes.add( Attribute.is_class )

        local base_type = Program.get_callback_type_reference( t, parameter_types, m.return_type )
        callback_type.base_types.add( base_type )
        base_type.extended_types.add( callback_type )

        local m_call = callback_type.add_method( t, "call" )
        local args = CmdArgs()
        if (parameter_types)
          forEach (i of parameter_types)
            local param_name = "param" + (i+1)
            m_call.add_parameter( t, param_name, parameter_types[i] )
            args.add( CmdAccess(t,param_name) )
          endForEach
        endIf

        local cmd : Cmd
        if (m.is_global)
          if (is_dynamically_specialized)
            throw t.error( "Global methods cannot be used to create indirect callbacks." )
          endIf
          callback_type.attributes.add( Attribute.is_singleton )
          cmd = CmdAccess( t, CmdAccess(t,context_type.name), name, args )
        else
          callback_type.add_property( t, "context", context_type )
          local m_init = callback_type.add_method( t, "init" )
          m_init.add_parameter( t, "context" )
          if (is_dynamically_specialized)
            callback_type.base_types.add( Program.get_type_reference(t,"DynamicCallback") )
            callback_type.add_property( t, "void* fn_ptr;", Program.type_Int64 ).mark_native
            callback_type.add_property( t, "original_signature", Program.type_String )
            callback_type.add_property( t, "specializing_signature", Program.type_String )
            m_init.add_parameter( t, "original_signature" )
            m_init.add_parameter( t, "specializing_signature" )
            m_init.statements.add( CmdAssignFnPtr(t,"THIS->fn_ptr",m) )
            m_init.statements.add( CmdAccess(t,"update_function_pointer") )
            cmd = CmdCallFnPtr( t, "THIS->fn_ptr", CmdAccess(t,"context"), m, args )
          else
            cmd = CmdAccess( t, CmdAccess(t,"context"), name, args )
          endIf
        endIf

        if (m.return_type)
          m_call.return_type = m.return_type
          cmd = CmdReturn( t, cmd )
        endIf

        m_call.statements.add( cmd )
      endIf

      if (m.is_global)
        return CmdReadSingleton( t, callback_type ).resolve( scope )
      else
        local args = CmdArgs( context )
        if (is_dynamically_specialized)
          args.add( CmdLiteralString(t,m.signature) )
          args.add( specializing_signature )
        endIf
        return CmdAccess( t, callback_type_name, args ).resolve( scope )
      endIf

endClass


class CmdCreateFunction( t, parameters:FnParam[], return_type:Type, with_args:FnArg[], statements:CmdStatementList, tokens:Token[], is_generic:Logical, query_cmd=null:Cmd ) : Cmd
  METHODS
    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdCreateFunction
      if (new_t) t = new_t
      local args2 : FnArg[]
      if (with_args)
        args2 = FnArg[]
        forEach (arg in with_args)
          args2.add( FnArg( arg.name, arg.value.cloned( clone_args, new_t ) ).set_type( arg.type ) )
        endForEach
      endIf
      return CmdCreateFunction( t, parameters, return_type, args2, clone(statements,clone_args), tokens, is_generic, clone(query_cmd,clone_args,new_t) )

    method implicit_type( scope:Scope )->Type
      if (is_generic_function) return null

      local parameter_types : Type[]
      if (parameters and parameters.count)
        parameter_types = Type[]
        forEach (param in parameters) parameter_types.add( param.type )
      endIf

      return Program.get_callback_type_reference( t, parameter_types, return_type )

    method is_generic_function->Logical
      return is_generic

    method is_scoped_read_access->Logical
      return true

    method resolve( scope:Scope )->Cmd
      if (is_generic)
        if (query_cmd)
          QueryToGenericFunctionConversionVisitor.convert( query_cmd, this )
          query_cmd = null
        endIf
        return this
      endIf

      local parameter_types : Type[]
      if (parameters and parameters.count)
        parameter_types = Type[]
        forEach (param in parameters) parameter_types.add( param.type )
      endIf

      local fn_name = "Function_" + Program.next_unique_integer
      local fn_type = Program.get_type_reference( t, fn_name )

      fn_type.is_defined = true
      fn_type.attributes.add( Attribute.is_class )

      local base_type = Program.get_callback_type_reference( t, parameter_types, return_type )
      fn_type.base_types.add( base_type )
      base_type.extended_types.add( fn_type )

      local m_call = fn_type.add_method( t, "call" )
      if (parameters)
        forEach (param in parameters)
          m_call.add_parameter( t, param.name, param.type )
        endForEach
      endIf

      m_call.return_type = return_type
      if (statements)
        m_call.statements = statements
      else
        local parser = Parser( tokens )
        parser.this_type = fn_type
        parser.this_method = m_call
        parser.parse_multi_line_statements( m_call.statements )
      endIf

      m_call.statements.dispatch( UpdateThisTypeVisitor(fn_type,m_call) )

      if (with_args)
        local m_init = fn_type.add_method( t, "init" )
        local create_args = CmdArgs()
        forEach (fn_arg in with_args)
          local arg = fn_arg.value.resolve( scope ).require_value
          create_args.add( arg )
          fn_type.add_property( fn_arg.value.t, fn_arg.name, arg.type )
          m_init.add_parameter( fn_arg.value.t, fn_arg.name )  # auto-initializing
        endForEach

        return CmdAccess( t, fn_name, create_args ).resolve( scope )

      else
        fn_type.attributes.add( Attribute.is_singleton )
        return CmdReadSingleton( t, fn_type ).resolve( scope )
      endIf

    method type->Type
      if (is_generic_function)
        # Some type is necessary for generic funtcions to avoid triggering a "value expected" error
        # before being able to match the generic function to a method's expected callback type.
        return Program.type_Object
      else
        return implicit_type( null )
      endIf

endClass

#------------------------------------------------------------------------------
# Optional
#------------------------------------------------------------------------------
class CmdCreateOptionalValue : Cmd
  PROPERTIES
    of_type : Type
    value   : Cmd

  METHODS
    method init( t, of_type, value=null )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdCreateOptionalValue( t, of_type, clone(value,clone_args,new_t) )

    method resolve( scope:Scope )->Cmd
      of_type.organize(scope, t)
      if (value) value = value.resolve( scope )
      return this

    method type->Type
      return of_type

endClass


#------------------------------------------------------------------------------
# Miscellaneous
#------------------------------------------------------------------------------
class CmdAssert : Cmd
  PROPERTIES
    condition  : Cmd
    message    : Cmd
    error      : Cmd
    local_info : Local

  METHODS
    method init( t, condition, message, local_info=null )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdAssert
      if (new_t) t = new_t
      return CmdAssert( t, condition.cloned( clone_args, new_t ), message.cloned( clone_args, new_t ), local_info )

    method is_scoped_read_access->Logical
      return true

    method resolve( scope:Scope )->Cmd
      condition = condition.resolve( scope )
      local_info.type = condition.require_type

      message = message.resolve( scope ).require_value
      error = CmdThrow( t, CmdAccess( t, "AssertionError", CmdArgs(message) ) ).resolve( scope )

      return this

    method type->Type
      return condition.type
endClass

class CmdRequire : Cmd
  PROPERTIES
    condition  : Cmd
    message    : Cmd
    error      : Cmd
    local_info : Local

  METHODS
    method init( t, condition, message, local_info=null )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdRequire
      if (new_t) t = new_t
      return CmdRequire( t, condition.cloned( clone_args, new_t ), message.cloned( clone_args, new_t ), local_info )

    method is_scoped_read_access->Logical
      return true

    method resolve( scope:Scope )->Cmd
      condition = condition.resolve( scope )
      local_info.type = condition.require_type

      message = message.resolve( scope ).require_value
      error = CmdThrow( t, CmdAccess( t, "RequirementError", CmdArgs(message) ) ).resolve( scope )

      return this

    method type->Type
      return condition.type

endClass

class CmdTrace : Cmd
  PROPERTIES
    info : Cmd

  METHODS
    method init( t, info )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdTrace
      if (new_t) t = new_t
      return CmdTrace( t, clone(info,clone_args,new_t) )

    method execute( vm:VM )->Value
      println info.execute( vm )->String
      return UndefinedValue

    method resolve( scope:Scope )->Cmd
      return CmdAccess( t, CmdAccess(t,"Global"), "println", CmdArgs(info) ).resolve( scope )

endClass

class CmdLabel : Cmd
  PROPERTIES
    name          : String
    statements    : CmdStatementList
    is_referenced : Logical

  METHODS
    method init( t, name, statements=CmdStatementList() )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdLabel
      if (new_t) t = new_t
      local result = CmdLabel( t, name, statements.cloned( clone_args, new_t ) )
      if (clone_args) clone_args.register_label( result )
      return result

    method generates_output->Logical
      forEach (statement in statements)
        if (statement.generates_output) return true
      endForEach
      return false

    method requires_semicolon->Logical
      return false

    method resolve( scope:Scope )->Cmd
      statements.resolve( scope )
      return this

    method to->String
      return ''CmdLabel($)'' (name)

endClass

class CmdNativeSource : Cmd
  METHODS
    method requires_semicolon->Logical
      return false
endClass

class CmdIncludeNative : CmdNativeSource
  PROPERTIES
    filepath    : String
    file_type   : String
    is_optional : Logical

  METHODS
    method init( t, filepath, file_type, is_optional )
      require (file_type == "code" or file_type == "header")

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdIncludeNative
      if (new_t) t = new_t
      return CmdIncludeNative( t, filepath, file_type, is_optional )

    method resolve( scope:Scope )->Cmd
      return this
endClass

class CmdNativeHeader : CmdNativeSource
  PROPERTIES
    code        : String

  METHODS
    method init( t, code )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdNativeHeader
      if (new_t) t = new_t
      return CmdNativeHeader( t, code )

    method resolve( scope:Scope )->Cmd
      return this
endClass

class CmdNativeCode : CmdNativeSource
  PROPERTIES
    code        : String

  METHODS
    method init( t, code )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdNativeCode
      if (new_t) t = new_t
      return CmdNativeCode( t, code )

    method resolve( scope:Scope )->Cmd
      return this
endClass

class CmdNativeLibrary : Cmd
  PROPERTIES
    library : String

  METHODS
    method init( t, library )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdNativeLibrary
      if (new_t) t = new_t
      return CmdNativeLibrary( t, library )

    method resolve( scope:Scope )->Cmd
      return this
endClass

class CmdInlineNative : Cmd
  PROPERTIES
    code         : String
    this_method  : Method
    result_type  : Type
    modify_op    : TokenType
    adjust_delta : Int32
    new_value    : Cmd
    local_list   : Local[]

  METHODS
    method init( t, code, result_type=null )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdInlineNative
      if (new_t) t = new_t
      local result = CmdInlineNative( t, code, result_type )
      result.modify_op = modify_op
      result.adjust_delta = adjust_delta
      result.new_value = new_value
      return result

    method is_scoped_read_access->Logical
      return true

    method requires_semicolon->Logical
      return false

    method resolve( scope:Scope )->Cmd
      local_list = scope.local_list.cloned
      this_method = scope.this_method
      if (result_type) result_type.organize(scope, t)
      return this

    method resolve_assignment( scope:Scope, new_value )->Cmd
      local_list = scope.local_list.cloned
      this_method = scope.this_method
      new_value = new_value.resolve( scope ).require_value
      if (result_type)
        result_type.organize(scope, t)
      else
        throw t.error( ''Cannot assign to inline native code without specifying its type.  For example, native("...")->$'' (new_value.type) )
      endIf
      new_value = new_value.cast_to( result_type, scope ).resolve( scope )
      return this

    method resolve_modify_and_assign( scope:Scope, modify_op, new_value )->Cmd
      local_list = scope.local_list.cloned
      this_method = scope.this_method
      new_value = new_value.resolve( scope ).require_value
      if (result_type)
        result_type.organize(scope, t)
      else
        throw t.error( ''Cannot modify-and-assign inline native code without specifying its type.  For example, native("...")->$'' (new_value.type) )
      endIf
      new_value = new_value.cast_to( result_type, scope ).resolve( scope )
      return this

    method resolve_adjust( scope:Scope, adjust_delta )->Cmd
      local_list = scope.local_list.cloned
      this_method = scope.this_method
      if (result_type)
        result_type.organize(scope, t)
      else
        throw t.error( ''Cannot increment or decrement inline native code without specifying its type.  For example, native("...")->$'' (new_value.type) )
      endIf
      return this

    method type->Type
      return result_type

endClass

class CmdMakeRequisite : Cmd
  PROPERTIES
    pattern : String

  METHODS
    method init( t, pattern )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdMakeRequisite
      if (new_t) t = new_t
      return CmdMakeRequisite( t, pattern )

    method requires_semicolon->Logical
      return false

    method resolve( scope:Scope )->Cmd
      # See Visitors.rogue : DependencyInjectionVisitor.on_enter(CmdMakeRequisite)
      return this
endClass

class CmdNoAction : Cmd
  METHODS
    method init( t )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdNoAction
      if (new_t) t = new_t
      return CmdNoAction( t )

    method add_to( statements:CmdStatementList )
      noAction

    method generates_output->Logical
      return false

    method requires_semicolon->Logical
      return false

    method resolve( scope:Scope )->Cmd
      return this

    method type->Type
      return null
endClass

class CmdTypedLiteralList : Cmd
  PROPERTIES
    context  : CmdAccess
    elements : CmdArgs

  METHODS
    method init( context, elements=CmdArgs() )
      t = context.t

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdTypedLiteralList
      if (new_t) t = new_t
      return CmdTypedLiteralList(context.cloned(clone_args,new_t)->(as CmdAccess), elements.cloned( clone_args, new_t))

    method add( element:Cmd )->CmdTypedLiteralList
      elements.add( element )
      return this

    method execute( vm:VM )->Value
      local vm_obj : Value
      if (context.args)
        vm_obj = context.execute( vm )
      else
        context.args = CmdArgs()
        vm_obj = context.execute( vm )
        context.args = null
      endIf
      local obj = vm_obj->Object
      if (obj)
        local type = obj.type_info
        local m = type.find_method( "add", 1 )
        if (m)
          local args = @[ vm_obj ]
          forEach (element in elements)
            m( args.add(element.execute(vm)) )
            args.remove_last
          endForEach
          return vm_obj
        endIf
      endIf
      return elements.execute( vm )   # ValueList

    method implicit_type( scope:Scope )->Type
      return type

    method resolve( scope:Scope )->Cmd
      local list_type = Program.get_type_reference( t, context.name )
      local list_var = Local( t, Program.create_unique_id, list_type )
      if (context.args is null) context.args = CmdArgs( CmdLiteralInt32(t,elements.count) )
      list_var.initial_value = context
      local declaration = CmdLocalDeclaration( t, list_var )
      scope.this_body.add( declaration.resolve(scope) )

      local init_block = CmdBlock( t )
      scope.this_body.add( init_block )

      if (context.name == "Byte[]")
        elements.resolve( scope )
        contingent
          necessary ((forEach in elements).is_literal_number)
        satisfied
          # Convert Byte[](a,b,c) to Byte[]("AABBCC")
          local bytes = Byte[]( elements.count )
          bytes.add( (forEach in elements)->Byte )

          init_block.statements.add(
              CmdAccess( t,CmdAccess(t,list_var.name), "add",
                  CmdArgs( CmdLiteralString(t,bytes.to_hex_string) ) ) )
          init_block = init_block.resolve( scope )

          local result = CmdAccess( t, list_var ).resolve( scope )
          return result
        endContingent
      endIf

      forEach (element in elements)
        local item = CmdAccess( t,CmdAccess(t,list_var.name), "add", element )
        init_block.statements.add( item )
      endForEach
      init_block = init_block.resolve( scope )

      local result = CmdAccess( t, list_var ).resolve( scope )
      return result

    method to->String
      return "CmdTypedLiteralList($,$)"(type,elements)

    method type->Type
      return Program.get_type_reference( t, context.name )
endClass


class CmdTypedLiteralTable : Cmd
  PROPERTIES
    context     : CmdAccess
    keys        : CmdArgs
    values      : CmdArgs
    context_var : Local

  METHODS
    method init( context, keys=CmdArgs(), values=CmdArgs() )
      t = context.t

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdTypedLiteralTable
      if (new_t) t = new_t
      return CmdTypedLiteralTable( context.cloned(clone_args,new_t)->(as CmdAccess),
          keys.cloned( clone_args, new_t ), values.cloned( clone_args, new_t ) )

    method add( key:Cmd, value:Cmd )->CmdTypedLiteralTable
      keys.add( key )
      values.add( value )
      return this

    method add_key( key:Cmd )->CmdTypedLiteralTable
      keys.add( key )
      return this

    method add_value( value:Cmd )->CmdTypedLiteralTable
      values.add( value )
      return this

    method execute( vm:VM )->Value
      local vm_obj : Value
      if (context.args)
        vm_obj = context.execute( vm )
      else
        context.args = CmdArgs()
        vm_obj = context.execute( vm )
        context.args = null
      endIf
      local obj = vm_obj->Object
      if (obj)
        local type = obj.type_info
        local m = type.find_method( "set", 2 )
        if (m)
          local args = @[ vm_obj ]
          forEach (i of keys)
            args.add( keys[i].execute(vm) ).add( values[i].execute(vm) )
            m( args )
            args.remove_last
            args.remove_last
          endForEach
          return vm_obj
        endIf
      endIf

      local result = @{}
      forEach (i of keys)
        result[ keys[i].execute(vm)->String ] = values[i].execute(vm)
      endForEach
      return result

    method implicit_type( scope:Scope )->Type
      return type

    method resolve( scope:Scope )->Cmd
      if (not context_var)
        context_var = Local( t, Program.create_unique_id, type )
        ensure context.args
        context_var.initial_value = context

        scope.this_body.add( CmdLocalDeclaration(t,context_var).resolve(scope) )

        local init_block = CmdBlock( t )
        scope.this_body.add( init_block )

        forEach (key at index in keys)
          local access_key = key->(as CmdAccess)
          if (access_key and access_key.context is null and access_key.args is null and access_key.name.begins_with('@'))
            local item = CmdAssign( t, CmdAccess(t,CmdAccess(t,context_var),access_key.name), values[index] )
            init_block.statements.add( item )
          else
            local item = CmdAccess( t,CmdAccess(t,context_var.name), "set", CmdArgs(key,values[index]) )
            init_block.statements.add( item )
          endIf
        endForEach
        init_block = init_block.resolve( scope )
      endIf

      return CmdAccess( t, context_var ).resolve( scope )

    method type->Type
      return Program.get_type_reference( t, context.name )
endClass


class CmdSelect : Cmd
  PROPERTIES
    local_declaration : CmdLocalDeclaration
    local_info : Local
    expression : Cmd
    cases      : CmdSelectCase[]
    value_type : Type

  METHODS
    method init( t, local_info=null, expression=null, cases=CmdSelectCase[] )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdSelect
      if (new_t) t = new_t
      local result = CmdSelect( t, local_info, clone(expression,clone_args,new_t), CmdSelectCase[](cases.count) )
      if (local_declaration) result.local_declaration = local_declaration.cloned( clone_args, new_t )->(as CmdLocalDeclaration)
      forEach (c in cases) result.cases.add( c.cloned( clone_args, new_t ) )
      return result

    method execute( vm:VM )->Value
      if (expression)
        local vm_expr = expression.execute( vm )
        forEach (c in cases)
          if (c.conditions.count)
            forEach (condition in c.conditions)
              local vm_condition = condition.execute( vm )
              if (vm_expr == vm_condition)
                if (c.condition_is_value) return vm_condition
                else                      return c.value.execute( vm )
              endIf
            endForEach
          else
            return c.value.execute( vm )
          endIf
        endForEach
      else
        forEach (c in cases)
          if (c.conditions.count)
            forEach (condition in c.conditions)
              local vm_condition = condition.execute( vm )
              if (vm_condition->Logical)
                if (c.condition_is_value) return vm_condition
                else                      return c.value.execute( vm )
              endIf
            endForEach
          else
            return c.value.execute( vm )
          endIf
        endForEach
      endIf
      return UndefinedValue

    method implicit_type( scope:Scope )->Type
      local common_type : Type
      forEach (c in cases)
        local case_type = c.implicit_type( scope )
        if (not common_type) common_type = case_type
        elseIf (common_type is not case_type) return null
      endForEach
      return common_type

    method resolve( scope:Scope )->Cmd
      if (value_type) return this

      if (not cases.count)
        throw t.error( "Selection list cannot be empty." )
      endIf

      if (expression)
        expression = expression.resolve( scope )
        local expr_type = expression.require_type
        if (not expr_type.is_primitive)
          # Convert e.g. which(string){ case1:value1 || value2 } -> which{ string==case1:value1 || value2 }
          # so that operator overloads are handled correctly.
          forEach (c in cases from cases.count-2 step -1)
            forEach (condition at index in c.conditions)
              c.conditions[ index ] = CmdCompareEQ( expression.t, expression.cloned, condition )
            endForEach
          endForEach
          expression = null
          local_info = null
          local_declaration.discard = true
        endIf
      endIf

      forEach (c in cases)
        c.resolve( scope )
        local case_type = c.type
        value_type = must_find_common_type( value_type, case_type )
      endForEach

      forEach (c in cases)
        c.cast_value( value_type, scope )
      endForEach

      if (expression)
        local expr_type = expression.require_type
        forEach (c in cases)
          c.cast_conditions( expr_type, scope )
        endForEach
      endIf

      return this

    method type->Type
      return value_type
endClass

class CmdSelectCase : Cmd
  PROPERTIES
    conditions : Cmd[]
    value      : Cmd
    local_info : Local
    condition_is_value : Logical

  METHODS
    method init( t, conditions=Cmd[](1), value=null, local_info=null )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdSelectCase
      if (new_t) t = new_t
      local result = CmdSelectCase( t, null, clone(value,clone_args,new_t), local_info )
      result.conditions = Cmd[]( conditions.count )
      forEach (c in conditions) result.conditions.add( c.cloned( clone_args, new_t ) )
      result.condition_is_value = condition_is_value
      return result

    method cast_conditions( to_type:Type, scope:Scope )
      forEach (i of conditions)
        conditions[i] = conditions[i].cast_to( to_type, scope ).resolve( scope ).require_value
      endForEach

    method cast_value( to_type:Type, scope:Scope )
      # Value has been resolved; cast to final type
      local value_type = value.type
      if (value_type.is_optional and not to_type.is_optional)
        value = CmdAccess(value.t,value,"value").resolve( scope )
      endIf
      value = value.cast_to( to_type, scope ).resolve( scope ).require_value

    method implicit_type( scope:Scope )->Type
      return which { value:value.implicit_type(scope) || null }

    method resolve( scope:Scope )->Cmd
      forEach (condition at i in conditions)
        condition = conditions[i].resolve( scope ).require_value
        if (condition.type.is_optional)
          condition = CmdAccess(condition.t,condition,"exists").resolve( scope )
        endIf
        conditions[i] = condition
      endForEach

      if (not value) value = conditions.first.cloned
      value = value.resolve( scope ).require_value

      if (value.type.is_optional and condition_is_value)
        value = CmdAccess(value.t,value,"value").resolve( scope )
      endIf

      return this

    method type->Type
      return value.type
endClass


class CmdEnsure : Cmd
  PROPERTIES
    operand    : Cmd
    args       : CmdArgs
    named_args : CmdNamedArg[]

  METHODS
    method init( t, operand, args, named_args=null )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      local result = CmdEnsure( t, operand.cloned( clone_args, new_t ), clone(args,clone_args,new_t) )

      if (named_args)
        result.named_args = CmdNamedArg[]( named_args.count )
        forEach (named_arg in named_args) result.named_args.add( named_arg.cloned )
      endIf

      return result

    method implicit_type( scope:Scope )->Type
      return operand.implicit_type( scope )

    method is_scoped_read_access->Logical
      return true

    method resolve( scope:Scope )->Cmd
      local cmd_read = operand.cloned.resolve( scope ).require_value
      if (not cmd_read.type.is_reference) throw t.error( "'ensure' can only be used with reference-type variables." )

      local cmd_new = CmdAccess( t, cmd_read.type.name, args )
      cmd_new.named_args = named_args

      # We can convert this statement-level ensure into a simple 'if'.
      cmd_read = operand.cloned.resolve( scope ).require_value

      local cmd_if = CmdIf( t, CmdLogicalNot(t,cmd_read) )
      cmd_if.statements.add( CmdAssign( t, operand, cmd_new ) )

      return cmd_if.resolve( scope )

    method type->Type
      return null

endClass


class CmdImplicitAccess( t ) : Cmd
  # Null access signifies "this" access AKA query value
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdImplicitAccess( t )

    method convert_to_explicit_access->Cmd
      return CmdAccess( t, "value" )

    method resolve( scope:Scope )->Cmd
      throw t.error( "Illegal use of implicit access; can only be used as a query argument in a call." )
endClass


class CmdMetaMethodSignature( t ) : Cmd
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdMetaMethodSignature( t )

    method resolve( scope:Scope )->Cmd
      return CmdLiteralString( t, scope.this_method.signature ).resolve( scope )

    method type->Type
      return Program.type_String
endClass


class CmdTypeSelector( t, of_type:Type ) : Cmd
  PROPERTIES
    generated_cmd : Cmd

  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdTypeSelector( t, of_type )

    method execute( vm:VM )->Value
      return Value( TypeInfo[of_type.name] )

    method implicit_type( scope:Scope )->Type
      return Program.get_type_reference( t, "TypeInfo" )

    method resolve( scope:Scope )->Cmd
      of_type.organize( scope, t )
      if (not generated_cmd)
        generated_cmd = CmdAccess( t, CmdAccess(t,"TypeInfo"), "get", CmdArgs(CmdLiteralString(t,of_type)) ).resolve( scope )
      endIf
      return this

    method type->Type
      return Program.type_TypeInfo
endClass


class CmdPrintln( t, standard=null:Cmd, no_parens=null:Cmd) : Cmd
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdPrintln( t, standard.cloned(clone_args,new_t), no_parens.cloned(clone_args,new_t) )

    method execute( vm:VM )->Value
      return standard.execute( vm )

    method resolve( scope:Scope )->Cmd
      try
        return standard.resolve( scope )
      catch ( err:RogueError )
        return no_parens.resolve( scope )
      endTry
endClass


class CmdSyncObjectInit : CmdStatement
  METHODS
    method init( t )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdSyncObjectInit
      if (new_t) t = new_t
      return CmdSyncObjectInit( t )

    method resolve( scope:Scope )->Cmd
      return this

    method type->Type
      return null
endClass


class CmdSyncObjectCleanup : CmdStatement
  METHODS
    method init( t )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdSyncObjectCleanup
      if (new_t) t = new_t
      return CmdSyncObjectCleanup( t )

    method resolve( scope:Scope )->Cmd
      return this

    method type->Type
      return null
endClass


class CmdInsertionPoint( t, content=null:Cmd ) : CmdStatement
  # Placeholder spot for another command.  'content' can be set or nulled at any
  # point to add or remove a command at this point in the code.
  METHODS
    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdInsertionPoint
      if (new_t) t = new_t
      return CmdInsertionPoint( t, clone(content,clone_args) )

    method implicit_type( scope:Scope )->Type
      if (content) return content.implicit_type( scope )
      return null

    method resolve( scope:Scope )->Cmd
      if (content) content = content.resolve( scope )
      return this

    method type->Type
      if (content) return content.type
      return null
endClass


class CmdIntrospectionCall( t, handler:IntrospectionCallHandler, args:CmdArgs ) : Cmd
  METHODS
    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdIntrospectionCall
      if (new_t) t = new_t
      return CmdIntrospectionCall( t, handler, args.cloned(clone_args,new_t) )

    method implicit_type( scope:Scope )->Type
      return type

    method resolve( scope:Scope )->Cmd
      args.resolve( scope )
      return this

    method to->String
      return "CmdIntrospectionCall:$$" (handler,args)

    method type->Type
      return handler.return_type
endClass


class CmdSourceComment( t, comment:String ) : Cmd
  METHODS
    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdSourceComment
      if (new_t) t = new_t
      return CmdSourceComment( t, comment )

    method resolve( scope:Scope )->Cmd
      return this

    method to->String
      return "CmdSourceComment:$" (comment)
endClass

class CmdUse : Cmd
  PROPERTIES
    variable_name : String
    expression    : Cmd
    statements    : CmdStatementList

  METHODS
    method init( t, variable_name, expression, statements=CmdStatementList() )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdUse
      if (new_t) t = new_t
      return CmdUse( t, variable_name, expression.cloned(clone_args,new_t), statements.cloned(clone_args,new_t) )

    method resolve( scope:Scope )->Cmd
      # Transform
      #   use v = expr
      #      ...
      #      return x
      #   endUse
      # ->
      #   block
      #     local err : Exception
      #     local usage = expr
      #     local v = usage.on_use
      #     local result : [this method return type]
      #     local has_return = false
      #     try
      #       ...
      #       has_return = true
      #       result = x
      #       escapeTry
      #     catch (e:Exception)
      #       err = e
      #     endTry
      #     err = usage.on_end_use( err )
      #     if (err) throw err
      #     if (has_return) return result
      #   endBlock
      local usage_name = Program.create_unique_id
      local result_name : String

      local cmd_try = CmdTry( t, statements )
      cmd_try.control_type = CmdControlStructure.type_use

      # TODO: replace with return path analysis eventually
      local has_guaranteed_return = false
      forEach (statement in cmd_try.statements)
        if (statement instanceOf CmdReturn)
          has_guaranteed_return = true
          escapeForEach
        endIf
      endForEach

      local has_return_name : String
      local has_return_v : Local
      if (not has_guaranteed_return)
        has_return_name = Program.create_unique_id
        has_return_v = Local( t, has_return_name, Program.type_Logical )
      endIf
      local err_v = Local( t, Program.create_unique_id, Program.type_Exception )

      local usage_v = Local( t, usage_name, null, expression )

      local result_v : Local
      if (scope.this_method.return_type)
        result_name = Program.create_unique_id
        result_v = Local( t, result_name, scope.this_method.return_type )
      endIf

      cmd_try.statements.dispatch( ConvertReturnToEscapeVisitor(scope.this_method,result_name,has_return_name,cmd_try) )

      local cmd_catch = cmd_try.add_catch( t )
      cmd_catch.error_var = Local( t, Program.create_unique_id, Program.type_Exception )
      cmd_catch.statements.add( CmdAssign(t,err_v,CmdAccess(t,cmd_catch.error_var)) )

      local cmd_block = CmdBlock( t )
      cmd_block.statements.add( CmdLocalDeclaration(t,err_v) )
      if (has_return_v) cmd_block.statements.add( CmdLocalDeclaration(t,has_return_v) )
      cmd_block.statements.add( CmdLocalDeclaration(t,usage_v) )
      if (result_v) cmd_block.statements.add( CmdLocalDeclaration(t,result_v) )

      local v = Local( t, variable_name, null, CmdAccess(usage_v.t,usage_v.name,"on_use") )
      cmd_block.statements.add( CmdLocalDeclaration(t,v) )
      cmd_block.statements.add( CmdInlineNative(t,"Rogue_ignore_unused($$);"('$',variable_name)) )
      cmd_block.statements.add( cmd_try )

      cmd_block.statements.add( CmdOnEndUse(t,usage_v,v,err_v) )
      # CmdOnEndUse no longer needs to be a separate class. It's an artifact of 'use'
      # originally being expanded into a command block at the point of parsing rather
      # than during resolve(). TODO: refactor to incorporate

      local cmd_if = CmdIf( t, CmdLogicalize(t,CmdAccess(t,err_v)) )
      cmd_if.statements.add( CmdThrow(t,CmdAccess(t,err_v)) )
      cmd_block.statements.add( cmd_if )

      local statements_for_return = cmd_block.statements
      if (not has_guaranteed_return)
        cmd_if = CmdIf( t, CmdAccess(t,has_return_v) )
        cmd_block.statements.add( cmd_if )
        statements_for_return = cmd_if.statements
      endIf
      if (scope.this_method.return_type)
        statements_for_return.add( CmdReturn(t,CmdAccess(t,result_name)) )
      else
        statements_for_return.add( CmdReturn(t) )
      endIf

      return cmd_block.resolve( scope )

endClass

class CmdOnEndUse : Cmd
  PROPERTIES
    usage_v     : Local
    resource_v  : Local
    exception_v : Local

  METHODS
    method init( t, usage_v, resource_v, exception_v )

    method cloned( clone_args:CloneArgs, new_t=null:Token )->CmdOnEndUse
      if (new_t) t = new_t
      return CmdOnEndUse( t, usage_v, resource_v, exception_v )

    method resolve( scope:Scope )->Cmd
      local candidates = usage_v.type.method_lookup_by_name[ "on_end_use" ]
      if (not candidates or candidates.count == 0) throw t.error( "'use' context object does not define on_end_use()." )
      if (candidates.count >  1) throw t.error( "'use' context object can only have one method named on_end_use()." )
      local m = candidates.first
      m.resolve
      local args = CmdArgs()
      which (m.parameters.count)
        case 1
          if (m.parameters.first.type.instance_of(Program.type_Exception))
            args.add( CmdAccess(t,exception_v) )
          else
            args.add( CmdAccess(t,resource_v) )
          endIf
        case 2
          if (m.parameters.first.type.instance_of(Program.type_Exception))
            args.add( CmdAccess(t,exception_v) )
            args.add( CmdAccess(t,resource_v) )
          else
            args.add( CmdAccess(t,resource_v) )
            args.add( CmdAccess(t,exception_v) )
          endIf
      endWhich
      local cmd_call = CmdAccess( t, CmdAccess(t,usage_v), "on_end_use", args )

      if (m.return_type)
        return CmdAssign( t, CmdAccess(t,exception_v), cmd_call ).resolve( scope )
      else
        return cmd_call.resolve( scope )
      endIf
endClass


class CmdThisType : Cmd
  PROPERTIES
    this_type : Type
    args      : CmdArgs
    cmd_new   : Cmd

  METHODS
    method init( t, this_type, args=CmdArgs() )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdThisType( t, this_type, clone(args,clone_args,new_t) )

    method implicit_type( scope:Scope )->Type
      return this_type

    method resolve( scope:Scope )->Cmd
      this_type.organize(scope,t)
      if (cmd_new is null)
        cmd_new = CmdAccess( t, this_type.name, clone(args) ).resolve( scope )
      endIf
      return this

    method type->Type
      return this_type
endClass

class CmdAssignFnPtr( t, name:String, method_info:Method ) : Cmd
  # A specialized Cmd used in creating Dynamic Callbacks (CmdCreateCallback)
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return ThisType( t, name, method_info )

    method implicit_type( scope:Scope )->Type
      return null

    method resolve( scope:Scope )->Cmd
      return this

    method type->Type
      return null
endClass

class CmdCallFnPtr( t, name:String, context:Cmd, method_info:Method, args:CmdArgs ) : CmdCallStaticMethod
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return ThisType( t, name, context.cloned(clone_args,new_t), method_info, args.cloned(clone_args,new_t) )

endClass

class CmdContextBlock : Cmd
  # Intermediate representation of context.[a,b,c]
  # Equivalent to following as-if-chained: context.a.b.c
  PROPERTIES
    context     : Cmd
    args        : CmdArgs
    context_var_name : String

  METHODS
    method init( t, context, context_var_name=Program.create_unique_id, args=CmdArgs() )

    method add( access:Cmd )
      args.add( access )

    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->Cmd
      if (new_t) t = new_t
      return CmdContextBlock( t, context.cloned(clone_args,new_t), context_var_name, args.cloned(clone_args,new_t) )

    method implicit_type( scope:Scope )->Type
      return context.implicit_type( scope )

    method resolve( scope:Scope )->Cmd
      local cmd_block = CmdBlock( t )
      local context_var = Local( t, context_var_name )
      context_var.initial_value = context.resolve( scope )
      cmd_block.expression_type = context_var.initial_value.type
      cmd_block.statements.add( CmdLocalDeclaration(t,context_var) )
      forEach (arg in args)
        cmd_block.statements.add( arg )
      endForEach
      cmd_block.statements.add( CmdReadLocal(t,context_var) )  # gets converted into a return
      return cmd_block.resolve( scope )

    method type->Type
      return context.type
endClass

class CmdChangeState( t, expression:Cmd ) : Cmd
  # Generally '[> X]' is shorthand for 'state = X'
  # 'X' can be any expression although that feature is unlikely to be used often.
  METHODS
    method cloned( clone_args=null:CloneArgs, new_t=null:Token )->CmdChangeState
      if (new_t) t = new_t
      return CmdChangeState( t, expression.cloned(clone_args,new_t) )

    method resolve( scope:Scope )->Cmd
      return CmdAssign( t, CmdAccess(t,"state"), expression ).resolve( scope )

    method type->Type
      return null
endClass
