class File
  DEPENDENCIES
    nativeHeader #include <cstdio>

  GLOBAL METHODS
    method abs( filepath:String )->String [macro]
      return File.absolute_filepath( filepath )

    method absolute_filepath( filepath:String )->String
      if (not filepath) return null
      filepath = expand_path( filepath )

      if (not exists(filepath))
        local parent = folder( filepath )
        if (parent.count == 0) parent = "."
        return "$/$" (absolute_filepath(parent),filename(filepath))
      endIf

      local return_value : String

      native @|#if defined(_WIN32)
              |{
              |  char long_name[PATH_MAX+4];
              |  char full_name[PATH_MAX+4];
              |
              |  strcpy_s( long_name, PATH_MAX+4, (char*)$filepath->utf8 );
              |
              |  if (GetFullPathName(long_name, PATH_MAX+4, full_name, 0) != 0)
              |  {
              |    $return_value = RogueString_create_from_utf8( full_name, -1 );
              |  }
              |}
              |#else
              |{
              |  int original_dir_fd;
              |  int new_dir_fd;
              |  char filename[PATH_MAX];
              |  char c_filepath[ PATH_MAX ];
              |  bool is_folder;
              |
              |  is_folder = RogueFile__is_folder__String( $filepath );
              |
              |  int len = $filepath->byte_count;
              |  if (len >= PATH_MAX) len = PATH_MAX - 1;
              |  memcpy( c_filepath, (char*)$filepath->utf8, len );
              |  c_filepath[len] = 0;
              |
              |  // A way to get back to the starting folder when finished.
              |  original_dir_fd = open( ".", O_RDONLY );
              |
              |  if (is_folder)
              |  {
              |    filename[0] = 0;
              |  }
              |  else
              |  {
              |    // fchdir only works with a path, not a path+filename (c_filepath).
              |    // Copy out the filename and null terminate the filepath to be just a path.
              |    int i = (int) strlen( c_filepath ) - 1;
              |    while (i >= 0 && c_filepath[i] != '/') --i;
              |    strcpy( filename, c_filepath+i+1 );
              |    if (i == -1) strcpy( c_filepath, "." );
              |    else         c_filepath[i] = 0;
              |  }
              |  new_dir_fd = open( c_filepath, O_RDONLY );
              |
              |  do
              |  {
              |    if (original_dir_fd >= 0 && new_dir_fd >= 0)
              |    {
              |      int r = fchdir( new_dir_fd );
              |      if ( r != 0 ) break;
              |      char * r2 = getcwd( c_filepath, PATH_MAX );
              |      if ( r2 == 0 ) break;
              |      if ( !is_folder )
              |      {
              |        strcat( c_filepath, "/" );
              |        strcat( c_filepath, filename );
              |      }
              |      r = fchdir( original_dir_fd );
              |      if ( r != 0 ) break;
              |    }
              |
              |    $return_value = RogueString_create_from_utf8( c_filepath, -1 );
              |  } while (false);
              |
              |  if (original_dir_fd >= 0) close( original_dir_fd );
              |  if (new_dir_fd >= 0) close( new_dir_fd );
              |}
              |#endif

      if (return_value is null)
        throw IOError("Could not get absolute path")
      endIf

      return fix_slashes( return_value )

    method before_wildcard_pattern( filepath:String )->String
      # Example: alpha/beta/image*.png -> alpha/beta
      while (filepath.contains('?') or filepath.contains('*'))
        filepath = File.folder( filepath )
      endWhile
      return filepath

    method character_writer( filepath:String )->CharacterToUTF8ByteWriter
      filepath = expand_path( filepath )
      return CharacterToUTF8ByteWriter( File.writer(filepath) )

    method common_path( filepath_a:String, filepath_b:String )->String
      local a = filepath_a
      local b = filepath_b

      if (a == b) return a

      # Remove trailing '/'
      while (a.count > 1 and a.ends_with('/')) a = a.leftmost( -1 )
      while (b.count > 1 and b.ends_with('/')) b = b.leftmost( -1 )

      while ((a.count > 0 or b.count > 0) and a != b)
        if (a.count > b.count) a = File.folder( a )
        else                   b = File.folder( b )
      endWhile

      return a  # 'a' and 'b' are the same at this point

    method contains( filepath:String, filename:String )->Logical
      return (File.listing( filepath, filename ).count > 0)

    method copy( from_filepath:String, to_filepath:String, &if_newer, &if_different, &dry_run, &verbose )->Logical
      from_filepath = expand_path( from_filepath )
      to_filepath = expand_path( to_filepath )

      if (not exists(from_filepath))
        throw Error( "Source file for copy() does not exist: " + from_filepath )
      endIf

      if (is_folder(from_filepath))
        throw Error( "First argument must be a file; cannot copy() from folder: " + from_filepath )
      endIf

      if (is_folder(to_filepath))
        to_filepath /= filename(from_filepath)
      else
        local containing_folder = folder( to_filepath )
        if (containing_folder != "" and not is_folder(containing_folder))
          File.create_folder( containing_folder )
          if (not is_folder(containing_folder))
            throw Error( "Cannot copy() to nonexistent folder: " + containing_folder )
          endIf
        endIf
      endIf

      contingent
        sufficient (if_newer and is_newer_than(from_filepath,to_filepath))
        sufficient (if_different and is_different_than(from_filepath,to_filepath))
        necessary (not if_newer and not if_different)

      satisfied
        if (dry_run) return true

        if (verbose) println "Copying $ -> $" (from_filepath,to_filepath)
        local reader = File.reader( from_filepath )
        local writer = File.writer( to_filepath )
        local file_buffer = Byte[]( 1024 )
        while (reader.has_another)
          reader.read( file_buffer.[clear], 1024 )
          writer.write( file_buffer )
        endWhile
        writer.close

        return true

      unsatisfied
        return false

      endContingent

    method conventional_filepath( filepath:String )->String
      if (System.is_windows) return filepath.replacing( '/', '\\' )
      else                   return filepath

    method crc32( filepath:String )->Int32
      nativeCode
        const RogueUInt32 Rogue_crc32_table[256] =
        {
          0x00000000, 0x77073096, 0xee0e612c, 0x990951ba, 0x076dc419, 0x706af48f,
          0xe963a535, 0x9e6495a3, 0x0edb8832, 0x79dcb8a4, 0xe0d5e91e, 0x97d2d988,
          0x09b64c2b, 0x7eb17cbd, 0xe7b82d07, 0x90bf1d91, 0x1db71064, 0x6ab020f2,
          0xf3b97148, 0x84be41de, 0x1adad47d, 0x6ddde4eb, 0xf4d4b551, 0x83d385c7,
          0x136c9856, 0x646ba8c0, 0xfd62f97a, 0x8a65c9ec, 0x14015c4f, 0x63066cd9,
          0xfa0f3d63, 0x8d080df5, 0x3b6e20c8, 0x4c69105e, 0xd56041e4, 0xa2677172,
          0x3c03e4d1, 0x4b04d447, 0xd20d85fd, 0xa50ab56b, 0x35b5a8fa, 0x42b2986c,
          0xdbbbc9d6, 0xacbcf940, 0x32d86ce3, 0x45df5c75, 0xdcd60dcf, 0xabd13d59,
          0x26d930ac, 0x51de003a, 0xc8d75180, 0xbfd06116, 0x21b4f4b5, 0x56b3c423,
          0xcfba9599, 0xb8bda50f, 0x2802b89e, 0x5f058808, 0xc60cd9b2, 0xb10be924,
          0x2f6f7c87, 0x58684c11, 0xc1611dab, 0xb6662d3d, 0x76dc4190, 0x01db7106,
          0x98d220bc, 0xefd5102a, 0x71b18589, 0x06b6b51f, 0x9fbfe4a5, 0xe8b8d433,
          0x7807c9a2, 0x0f00f934, 0x9609a88e, 0xe10e9818, 0x7f6a0dbb, 0x086d3d2d,
          0x91646c97, 0xe6635c01, 0x6b6b51f4, 0x1c6c6162, 0x856530d8, 0xf262004e,
          0x6c0695ed, 0x1b01a57b, 0x8208f4c1, 0xf50fc457, 0x65b0d9c6, 0x12b7e950,
          0x8bbeb8ea, 0xfcb9887c, 0x62dd1ddf, 0x15da2d49, 0x8cd37cf3, 0xfbd44c65,
          0x4db26158, 0x3ab551ce, 0xa3bc0074, 0xd4bb30e2, 0x4adfa541, 0x3dd895d7,
          0xa4d1c46d, 0xd3d6f4fb, 0x4369e96a, 0x346ed9fc, 0xad678846, 0xda60b8d0,
          0x44042d73, 0x33031de5, 0xaa0a4c5f, 0xdd0d7cc9, 0x5005713c, 0x270241aa,
          0xbe0b1010, 0xc90c2086, 0x5768b525, 0x206f85b3, 0xb966d409, 0xce61e49f,
          0x5edef90e, 0x29d9c998, 0xb0d09822, 0xc7d7a8b4, 0x59b33d17, 0x2eb40d81,
          0xb7bd5c3b, 0xc0ba6cad, 0xedb88320, 0x9abfb3b6, 0x03b6e20c, 0x74b1d29a,
          0xead54739, 0x9dd277af, 0x04db2615, 0x73dc1683, 0xe3630b12, 0x94643b84,
          0x0d6d6a3e, 0x7a6a5aa8, 0xe40ecf0b, 0x9309ff9d, 0x0a00ae27, 0x7d079eb1,
          0xf00f9344, 0x8708a3d2, 0x1e01f268, 0x6906c2fe, 0xf762575d, 0x806567cb,
          0x196c3671, 0x6e6b06e7, 0xfed41b76, 0x89d32be0, 0x10da7a5a, 0x67dd4acc,
          0xf9b9df6f, 0x8ebeeff9, 0x17b7be43, 0x60b08ed5, 0xd6d6a3e8, 0xa1d1937e,
          0x38d8c2c4, 0x4fdff252, 0xd1bb67f1, 0xa6bc5767, 0x3fb506dd, 0x48b2364b,
          0xd80d2bda, 0xaf0a1b4c, 0x36034af6, 0x41047a60, 0xdf60efc3, 0xa867df55,
          0x316e8eef, 0x4669be79, 0xcb61b38c, 0xbc66831a, 0x256fd2a0, 0x5268e236,
          0xcc0c7795, 0xbb0b4703, 0x220216b9, 0x5505262f, 0xc5ba3bbe, 0xb2bd0b28,
          0x2bb45a92, 0x5cb36a04, 0xc2d7ffa7, 0xb5d0cf31, 0x2cd99e8b, 0x5bdeae1d,
          0x9b64c2b0, 0xec63f226, 0x756aa39c, 0x026d930a, 0x9c0906a9, 0xeb0e363f,
          0x72076785, 0x05005713, 0x95bf4a82, 0xe2b87a14, 0x7bb12bae, 0x0cb61b38,
          0x92d28e9b, 0xe5d5be0d, 0x7cdcefb7, 0x0bdbdf21, 0x86d3d2d4, 0xf1d4e242,
          0x68ddb3f8, 0x1fda836e, 0x81be16cd, 0xf6b9265b, 0x6fb077e1, 0x18b74777,
          0x88085ae6, 0xff0f6a70, 0x66063bca, 0x11010b5c, 0x8f659eff, 0xf862ae69,
          0x616bffd3, 0x166ccf45, 0xa00ae278, 0xd70dd2ee, 0x4e048354, 0x3903b3c2,
          0xa7672661, 0xd06016f7, 0x4969474d, 0x3e6e77db, 0xaed16a4a, 0xd9d65adc,
          0x40df0b66, 0x37d83bf0, 0xa9bcae53, 0xdebb9ec5, 0x47b2cf7f, 0x30b5ffe9,
          0xbdbdf21c, 0xcabac28a, 0x53b39330, 0x24b4a3a6, 0xbad03605, 0xcdd70693,
          0x54de5729, 0x23d967bf, 0xb3667a2e, 0xc4614ab8, 0x5d681b02, 0x2a6f2b94,
          0xb40bbe37, 0xc30c8ea1, 0x5a05df1b, 0x2d02ef8d
        };
      endNativeCode

      filepath = expand_path( filepath )
      if (not File.exists(filepath)) return 0

      native @|RogueUInt32 result = ~0U;
      local reader = File.reader( filepath )
      local file_buffer = Byte[]( 1024 )
      while (reader.has_another)
        reader.read( file_buffer.[clear], 1024 )
        native @|RogueByte* byte_ptr = $file_buffer->data->as_bytes - 1;
                |for (int i=$file_buffer->count+1; --i; )
                |{
                |  result = Rogue_crc32_table[ (result ^ *(++byte_ptr)) & 0xFF ] ^ (result >> 8);
                |}
      endWhile

      return native( "(RogueInt32)~result" )->Int32

    method create_folder( filepath:String )->Logical
      # Creates the specified folder along with intermediate folders
      # if necessary.  Returns 'true' on success or if the filepath
      # already exists as a folder.  Returns 'false' on failure to
      filepath = expand_path( filepath )
      while (filepath.count > 1 and filepath.ends_with('/'))
        filepath = filepath.leftmost( -1 )
      endWhile

      filepath = File.absolute_filepath( filepath )

      # create or if the filepath already exists but is not a folder.
      if (File.exists(filepath)) return File.is_folder( filepath )

      # Check for the parent folder's existence and recursively create
      # that if necessary.
      local parent = File.folder( filepath )
      if (not create_folder(parent)) return false

      # Note: 0777 is a permission mask rather than the actual permission setting.
      native @|#if defined(ROGUE_PLATFORM_WINDOWS)
              |  return (0 == mkdir((char*)$filepath->utf8));
              |#else
              |  return (0 == mkdir((char*)$filepath->utf8, 0777));
              |#endif

    method delete( filepath:String )->Logical
      if (not filepath) return false
      filepath = expand_path( filepath )
      if (is_folder(filepath))
        delete( forEach in listing(filepath,FilePattern("*")) )  # Recursively delete nested content
        return (0 == native( "rmdir( (const char*) $filepath->utf8 )")->Int32)
      endIf
      return (0 == native( "unlink( (const char*) $filepath->utf8 )")->Int32)

    method ends_with_separator( filepath:String )->Logical
      # \ is a valid filename character on macOS and Linux, so can't just blindly check for that
      return filepath.ends_with('/') or (System.is_windows and filepath.ends_with('\\'))

    method ensure_ends_with_separator( filepath:String )->String
      if (ends_with_separator(filepath)) return filepath
      return filepath + '/'

    method esc( filepath:String )->String
      # File.esc(filepath) is shorthand for File.shell_escaped(File.conventional_filepath(filepath))
      return File.shell_escaped( File.conventional_filepath(filepath) )

    method exists( filepath:String )->Logical
      filepath = expand_path( filepath )
      native @|if ( !$filepath ) return false;
              |
              |struct stat s;
              |return (stat((char*)$filepath->utf8, &s) == 0);

    method expand_path( filepath:String )->String
      if (System.is_windows)
        local n = filepath.count('%')
        while (n >= 2)
          local i1 = filepath.locate('%').value
          local i2 = filepath.locate('%',i1+1).value
          local name  = filepath.from(i1+1,i2-1)
          local value = which{ System.env[name] || "" }
          filepath .= replacing_at( i1, (i2-i1)+1, value )
          n -= 2
        endWhile
      endIf

      filepath = fix_slashes( filepath )
      if (filepath == "~" or filepath.begins_with("~/"))
        local home_folder : String
        if (System.is_windows)
          home_folder = System.environment//HOMEDRIVE + System.environment//HOMEPATH
        else
          home_folder = System.environment//HOME
        endIf
        if (home_folder and home_folder.count)
          filepath = home_folder + filepath.rightmost(-1)
          return filepath
        endIf
      endIf
      return filepath

    method extension( filepath:String )->String
      return File.filename( filepath ).after_last( '.' )

    method filename( filepath:String )->String
      filepath = expand_path( filepath )
      local i = filepath.locate_last( '/' )
      if (not i?) return filepath
      return filepath.from( i.value+1 )

    method fix_slashes( filepath:String )->String
      # Filepaths are always manipulated using forward slashes. Use .conventional_filepath() to
      # turn a file or filepath into a Windows-style version for display.
      if (System.is_windows) return filepath.replacing( '\\', '/' )
      else                   return filepath

    method folder( filepath:String )->String
      filepath = expand_path( filepath )

      # Replace multiple slashes with single slashes
      while (filepath.contains("//")) filepath = filepath.replacing( "//", "/" )

      # Discard trailing slash
      if (filepath.ends_with('/')) filepath = filepath.leftmost( -1 )

      if (filepath.count == 0) return ""

      local i1 = filepath.locate_last( '/' )
      if (not i1?) return ""
      if (i1.value == 0) return filepath.leftmost(1)  # /abc -> /

      return filepath.from( 0, i1.value-1 )

    method has_byte_order_mark( filepath:String )->Logical
      if (not File.exists(filepath)) return false
      if (File.size(filepath) < 3)  return false
      local has_bom = true
      local reader = reader( filepath )
      if (reader.read != 0xEF) has_bom = false
      if (reader.read != 0xBB) has_bom = false
      if (reader.read != 0xBF) has_bom = false
      reader.close
      return has_bom

    method is_different_than( filepath:String, other_filepath:String )->Logical
      filepath = expand_path( filepath )
      other_filepath = expand_path( other_filepath )
      if (File.exists(filepath) xor File.exists(other_filepath)) return true
      if (File.size(filepath) != File.size(other_filepath))      return true
      if (File.crc32(filepath) != File.crc32(other_filepath))    return true
      return false

    method is_folder( filepath:String )->Logical [essential]
      filepath = expand_path( filepath )

      native @|if ( !$filepath ) return false;
              |
              |#if defined(ROGUE_PLATFORM_WINDOWS)
              |  struct stat s;
              |  if (stat((char*)$filepath->utf8, &s) != 0) return false;
              |  return (s.st_mode & S_IFMT) == S_IFDIR;
              |#else
              |  DIR* dir = opendir( (char*)$filepath->utf8 );
              |  if ( !dir ) return 0;
              |
              |  closedir( dir );
              |  return 1;
              |#endif

    method is_hidden( filepath:String )->Logical
      local filename = File.filename( expand_path(filepath) )
      if (not filename.begins_with('.'))       return false
      if (filename == "." or filename == "..") return false
      return true

    method is_newer_than( filepath:String, other_filepath:String )->Logical
      filepath = expand_path( filepath )
      other_filepath = expand_path( other_filepath )
      if (not File.exists(filepath))       return false
      if (not File.exists(other_filepath)) return true
      return (File.timestamp(filepath).floor > File.timestamp(other_filepath).floor)

    method is_valid_utf8( filepath:String )->Logical
      if (not File.exists(filepath) or File.is_folder(filepath)) return false
      local reader = File.reader( filepath )
      contingent
        while (reader.has_another)
          local b = reader.read
          if (b & 0x80)
            necessary (b & 0x40) # 10xx_xxxx is an illegal first byte of UTF8
            if (b & 0x20)
              if (b & 0x10)
                necessary ((b&8) == 0) # 1111_1xxx is illegal
                loop (3)
                  # 1111_0xxx
                  necessary (reader.has_another)
                  necessary ((reader.read & 0xC0) == 0x80)
                endLoop
              else
                loop (2)
                  # 1110_xxxx
                  necessary (reader.has_another)
                  necessary ((reader.read & 0xC0) == 0x80)
                endLoop
              endIf
            else
              # 110x_xxxx
              necessary (reader.has_another)
              necessary ((reader.read & 0xC0) == 0x80)
            endIf
          #else 0xxx_xxxx
          endIf
        endWhile
      unsatisfied
        reader.close
        return false
      endContingent
      return true

    method join( segments:String[] )->String
      local buffer = StringBuilder()
      local needs_separator = false
      forEach (part at index in segments)
        if (not part) nextIteration
        if (needs_separator) buffer.print('/', &!formatted)
        if (index > 0 and part.begins_with('/')) part .= rightmost(-1)
        buffer.print(part)
        needs_separator = not File.ends_with_separator( part )
      endForEach
      return buffer

    method join( part1:String, part2:String )->String
      return join(String[][part1, part2])

    method join( part1:String, part2:String, part3:String, part4=null:String, part5=null:String, part6=null:String )->String
      return join(String[][part1, part2, part3, part4, part5, part6])

    method listing( folder:String, filepattern=null:FilePattern?, &ignore_hidden, &absolute, &omit_path, &files, &folders, &unsorted )->String[]
      # Use the filepattern '**' for a recursive listing.
      local options = FileOptions()
      if (ignore_hidden)    options = options.ignore_hidden
      if (absolute)         options = options.absolute
      if (omit_path)        options = options.omit_path
      if (files)            options = options.files
      if (folders)          options = options.folders
      if (unsorted)         options = options.unsorted
      return listing( folder, filepattern, options )

    method listing( folder:String, filepattern:String, &ignore_hidden, &absolute, &omit_path, &files, &folders )->String[]
      # Use the filepattern '**' for a recursive listing.
      return listing( folder, FilePattern(filepattern), &=ignore_hidden, &=absolute, &=omit_path, &=files, &=folders )

    method listing( folder:String, filepattern=null:FilePattern?, options:FileOptions )->String[]
      # Use the filepattern '**' for a recursive listing.
      return FileListing( folder, which{filepattern:filepattern.value->String||null}, options ).results

    method listing( folder:String, filepattern:String, options:FileOptions )->String[]
      # Use the filepattern '**' for a recursive listing.
      return FileListing( folder, filepattern, options ).results

    method _listing( folder:String, collector:Function(String) )
      native @|#ifdef ROGUE_PLATFORM_WINDOWS

      local search_filepath = File.ensure_ends_with_separator(folder) + "*"

      native @|{
              |  WIN32_FIND_DATA entry;
              |  HANDLE dir;
              |
              |  dir = FindFirstFile( $search_filepath->utf8, &entry );
              |
              |  if (dir != INVALID_HANDLE_VALUE)
              |  {
              |    do
              |    {
              |      int keep = 1;
              |      if (entry.cFileName[0] == '.')
              |      {
              |        switch (entry.cFileName[1])
              |        {
              |          case 0:   // '.' / this folder
              |            keep = 0;
              |            break;
              |          case '.':
              |            keep = entry.cFileName[2] != 0;  // ".." / Parent Folder
              |            break;
              |        }
              |      }
              |      if (keep)
              |      {
                       block
                         local entry = native("RogueString_create_from_utf8(entry.cFileName,-1)")->String
                         collector( entry )
                       endBlock
      native @|      }
              |    }
              |    while (FindNextFile(dir,&entry));
              |
              |    FindClose( dir );
              |  }
              |}
              |#else
              |// Mac/Linux
              |{
              |  DIR* dir;
              |  struct dirent* entry;
              |
              |  dir = opendir( (const char*) $folder->utf8 );
              |  if (dir)
              |  {
              |    entry = readdir( dir );
              |    while (entry)
              |    {
              |      int keep = 1;
              |      if (entry->d_name[0] == '.')
              |      {
              |        switch (entry->d_name[1])
              |        {
              |          case 0:   // '.' / this folder
              |            keep = 0;
              |            break;
              |          case '.':
              |            keep = entry->d_name[2] != 0;  // ".." / Parent Folder
              |            break;
              |        }
              |      }
              |      if (keep)
              |      {
                       block
                         local entry = native("RogueString_create_from_utf8(entry->d_name,-1)")->String
                         collector( entry )
                       endBlock
      native @|
              |      }
              |      entry = readdir( dir );
              |    }
              |    closedir( dir );
              |  }
              |}
              |#endif // Windows vs Mac/Linux

    method load_as_bytes( filepath:String )->Byte[]
      filepath = expand_path( filepath )
      local count = size( filepath )
      local bytes = Byte[]( count )
      local infile = reader( filepath )
      forEach (1..count) bytes.add( infile.read )
      infile.close
      return bytes

    method load_as_string( filepath:String, encoding=StringEncoding.AUTODETECT:StringEncoding )->String
      local bytes = load_as_bytes( filepath )
      if (bytes.count >= 3 and bytes[0] == 0xEF and bytes[1] == 0xBB and bytes[2] == 0xBF)
        # Discard Byte Order Marker (BOM)
        bytes.discard( 0, 3 )
      endIf
      return String( bytes, encoding )

    method matches_wildcard_pattern( filepath:String, pattern:String, &ignore_case )->Logical
      # Determines whether or not the given filepath matches the given
      # semi-Unix/Dos-style 'wildcard pattern'.  'pattern' is a
      # regular text string that may contain the following special
      # characters:
      #
      # *    - Matches any number of characters but does not match '/'
      # **   - Matches any number of characters including slashes
      # ***/ - Matches any number of characters and a slash or else nothing.
      # ?  - Matches any one character except '/'
      #
      # Note: A filepath with a ./ prefix is checked with and without the prefix.
      filepath = expand_path( filepath )

      # Check non-wildcard characters at the end of pattern first as an easy out
      local last_wildcard = -1
      forEach (ch at i in pattern step -1)
        if (ch == '*')
          last_wildcard = i
          if (i>0 and i+1<pattern.count and pattern[i-1]=='*' and pattern[i+1]=='/') ++last_wildcard
          escapeForEach
        elseIf (ch == '?')
          last_wildcard = i
          escapeForEach
        endIf
      endForEach

      if (last_wildcard != -1)
        local end_count = pattern.count - (last_wildcard+1)
        if (end_count > 0)
          if (end_count > filepath.count) return false

          local i = last_wildcard + 1
          forEach (ch in filepath from filepath.count-end_count)
            local pattern_ch = pattern[i]
            if (ignore_case)
              ch = ch.to_lowercase
              pattern_ch = pattern_ch.to_lowercase
            endIf
            if (ch != pattern_ch) return false
            ++i
          endForEach
        endIf
      endIf

      if (_matches_wildcard_pattern(filepath,0,filepath.count,pattern,0,pattern.count,&=ignore_case)) return true

      if (filepath.count <= 2 or not filepath.begins_with("./")) return false

      # Try ignoring the ./ prefix on the filepath
      return (_matches_wildcard_pattern(filepath,2,filepath.count-2,pattern,0,pattern.count,&=ignore_case))

    method _matches_wildcard_pattern( filepath:String, f0:Int32, fcount:Int32, pattern:String, p0:Int32, pcount:Int32,
       &ignore_case )->Logical
      # f0     - starting index in filepath
      # fcount - remaining filepath count
      # p0     - starting index in pattern
      # pcount - remaining pattern count
      if (pcount == 0) return (fcount == 0)

      local remaining_pattern = pattern
      local r0 = p0 + 1
      local rcount = pcount - 1
      local ch = pattern[p0]
      which (ch)
        case '*':
          if (rcount >= 2 and remaining_pattern[r0] == '*' and remaining_pattern[r0+1] == '/')
            # '**/' - match any characters (including '/') and ending with '/' or else match zero characters.

            # Match 0 characters (skip '**/' entirely)
            if (_matches_wildcard_pattern(filepath,f0,fcount,remaining_pattern,r0+2,rcount-2,&=ignore_case)) return true

            # Match 0+ characters for '**' and leave '/' to end pattern (matches 1+ total)
            ++r0
            --rcount
            forEach (n in 0..fcount)
              if (_matches_wildcard_pattern(filepath,f0+n,fcount-n,remaining_pattern,r0,rcount,&=ignore_case)) return true
            endForEach
          elseIf (rcount and remaining_pattern[r0] == '*')
            # '**' - match any characters including '/'
            ++r0
            --rcount
            forEach (n in 0..fcount)
              if (_matches_wildcard_pattern(filepath,f0+n,fcount-n,remaining_pattern,r0,rcount,&=ignore_case)) return true
            endForEach
          else
            # Single asterisk - match any characters except '/'
            forEach (n in 0..<fcount)
              ch = filepath[ f0+n ]
              if (_matches_wildcard_pattern(filepath,f0+n,fcount-n,remaining_pattern,r0,rcount, &=ignore_case)) return true
              if (ch == '/') return false
            endForEach
            return _matches_wildcard_pattern( "", 0, 0, remaining_pattern, r0, rcount, &=ignore_case )
          endIf

        case '?':
          if (fcount == 0) return false
          ch = filepath[ f0 ]
          if (ch == '/') return false
          return _matches_wildcard_pattern( filepath, f0+1, fcount-1, remaining_pattern, r0, rcount, &=ignore_case )

        others:
          if (fcount == 0) return false
          local filepath_ch = filepath[f0]
          if (ignore_case) ch = ch.to_lowercase; filepath_ch = filepath_ch.to_lowercase
          if (ch == filepath_ch)
            return _matches_wildcard_pattern( filepath, f0+1, fcount-1, remaining_pattern, r0, rcount, &=ignore_case )
          endIf
      endWhich
      return false

    method options->FileOptions
      return FileOptions()

    method rename( old_filepath:String, new_filepath:String )->Logical
      old_filepath = expand_path( old_filepath )
      new_filepath = expand_path( new_filepath )
      if (not File.exists(old_filepath)) return false
      native @|rename( $old_filepath->utf8, $new_filepath->utf8 );
      return File.exists( new_filepath )

    method parent( filepath:String, level=1:Int32 )->String
      filepath = expand_path( filepath )
      if (level <= 0) return filepath
      if (level == 1) return folder( filepath )
      return parent( folder(filepath), level-1 )

    method path( filepath:String )->String
      filepath = expand_path( filepath )
      return folder( filepath )

    method print_writer( filepath:String )->PrintWriter
      return PrintWriter( writer(filepath) )

    method reader( filepath:String )->FileReader
      filepath = expand_path( filepath )
      return FileReader( filepath )

    method rebuilder( filepath:String )->LineRebuilder
      filepath = expand_path( filepath )
      return LineRebuilder( File(filepath) )

    method rewrite( filepath:String, mappings:Table<<String,String>> )
      filepath = expand_path( filepath )
      local fn = function( line:String )->String with (mappings)
        local cur = mappings.first_entry
        while (cur)
          if (line.contains(cur.key))
            line = line.replacing( cur.key, cur.value )
          endIf
          cur = cur.next_entry
        endWhile
        return line
      endFunction

      rewrite( filepath, fn )

    method rewrite( filepath:String, fn1:Function(String)->String, fn2=null:Function(String)->String, fn3=null:Function(String)->String )
      filepath = expand_path( filepath )
      local has_bom = has_byte_order_mark( filepath )
      local data = load_as_string( filepath )
      local result = StringBuilder( data.count * 1.1 )
      forEach (line in LineReader(data))
        line = fn1( line )
        if (fn2) line = fn2( line )
        if (fn3) line = fn3( line )
        result.println( line )
      endForEach
      save( filepath, result->String, &bom=has_bom )

    method save( filepath:String, data:Byte[] )->Logical
      filepath = expand_path( filepath )
      local outfile = writer( filepath )
      outfile.write( data )
      outfile.close
      return not outfile.error

    method save( filepath:String, data:String, &bom )->Logical
      filepath = expand_path( filepath )
      local outfile = writer( filepath )
      if (bom) outfile.[ write(0xEF), write(0xBB), write(0xBF) ]
      outfile.write( data )
      outfile.close
      return not outfile.error

    method save( filepath:String, data:StringBuilder, &bom )->Logical
      filepath = expand_path( filepath )
      local outfile = writer( filepath )
      if (bom) outfile.[ write(0xEF), write(0xBB), write(0xBF) ]
      outfile.write( data )
      outfile.close
      return not outfile.error

    method separator->Character
      native @|#if defined(ROGUE_PLATFORM_WINDOWS)
              |  return '\\';
              |#else
              |  return '/';
              |#endif

    method is_valid_filename_character( ch:Character, &any_os )->Logical
      if (ch < 32 or ch == 127) return false
      if (any_os or System.is_windows) return not ''"*:<>?/\\|''.contains( ch )
      return ch != '/'

    method shell_escaped( filepath:String )->String
      local acceptable : String
      if (System.is_windows)
        # Windows
        # Characters that cannot be part of a filename:    "*:<>?/\|
        # Non-alpha-num chars that don't require escaping: #$.-@_
        acceptable = ''"*:<>?/\\|#$.-@_''
      else
        # Mac/Linux
        # Characters that cannot be part of a filename:    /
        # Non-alpha-num chars that don't require escaping: #%+-._~
        acceptable = "/#%+-._~"
      endIf

      contingent
        forEach (ch in filepath)
          necessary (ch.is_alphanumeric or acceptable.contains(ch))
        endForEach
        return filepath

      unsatisfied
        if (System.is_windows)
          # Surrounding the filepath with double quotes is all the escaping we need.
          return '"$"' (filepath)
        else
          # On Unixy OS's, put a '\' in front of every character that needs it.
          use builder = StringBuilder.pool
            forEach (ch in filepath)
              if (ch.is_alphanumeric or acceptable.contains(ch))
                builder.print( ch )
              else
                builder.print('\\').print(ch)
              endIf
            endForEach
            return builder->String
          endUse
        endIf

      endContingent

    method size( filepath:String )->Int64
      filepath = expand_path( filepath )
      native @|if ( !$filepath ) return 0;
              |
              |FILE* fp = fopen( (char*)$filepath->utf8, "rb" );
              |if ( !fp ) return 0;
              |
              |fseek( fp, 0, SEEK_END );
              |RogueInt64 size = (RogueInt64) ftell( fp );
              |fclose( fp );
              |
              |return size;

    method symlink( filepath:String, target:String )
      filepath = expand_path( filepath )
      target = expand_path( target )
      if (System.is_windows)
        local option = which{ File.is_folder(filepath):"/D " || "" }
        Process.run( "mklink $$ $" (option,File.esc(filepath),File.esc(target)) )
      else
        Process.run( "ln -s $ $" (File.esc(target),File.esc(filepath)) )
      endIf

    method sync_from( source_folder:String, dest_folder:String, &verbose, &keep_unused, &dry_run, &missing_only,
        &exclude:Function(String)->Logical )->Int32
      if (dry_run) verbose = true
      source_folder = expand_path( source_folder )
      dest_folder = expand_path( dest_folder )
      return sync_from( Files(source_folder).add("**"), dest_folder, &=verbose, &=keep_unused, &=dry_run, &=missing_only, &=exclude )

    method sync_from( source_files:Files, dest_folder:String, &verbose, &keep_unused, &dry_run, &missing_only,
        &exclude:Function(String)->Logical )->Int32
      if (dry_run) verbose = true
      dest_folder = File.fix_slashes( dest_folder )
      dest_folder = expand_path( dest_folder )

      if (not exists(dest_folder) and not dry_run)
        create_folder( dest_folder )
        if (not is_folder(dest_folder))
          Console.error.println( "ERROR: File.sync_from() can not create destination folder $" (dest_folder) )
          return 0
        endIf
      endIf

      dest_folder = ensure_ends_with_separator( dest_folder )
      local dest_name = dest_folder
      if (dest_name.begins_with("./")) dest_name = dest_name.from( 2 )

      if (dest_name == source_files.base_folder)
        Console.error.println( "ERROR: File.sync_from() has the same source and destination folders ($)."...
          (dest_folder.leftmost(-1)) )
        return 0
      endIf

      local width = 0
      width = width.or_larger( (forEach in source_files).count )
      width -= source_files.base_folder.count

      local dest_files = Files( dest_folder )
      if (not keep_unused) dest_files.add( "**" )
      local printed_header = false
      local change_count = 0
      forEach (src_filepath in source_files)
        local relative_filepath = source_files.relative_filepath( src_filepath )
        local dest_filepath = dest_name + relative_filepath
        dest_files.remove( dest_filepath )
        local folder = File.folder( dest_filepath )
        while (dest_files.contains(folder))
          dest_files.remove( folder )
          folder = File.folder( folder )
        endWhile

        contingent
          sufficient (not File.exists(dest_filepath))
          necessary  (not missing_only)
          sufficient (File.size(src_filepath) != File.size(dest_filepath))
          necessary  (File.crc32(src_filepath) != File.crc32(dest_filepath))

        satisfied
          if (not exclude or not exclude(dest_filepath))
            ++change_count

            if (verbose)
              if (not printed_header)
                printed_header = true
                local src = source_files.base_folder
                if (src.count) src = src.leftmost( -1 )
                else           src = "."
                local dest = dest_folder.leftmost( -1 )
                Console.println( "Copying $ -> $" (src,dest) )
              endIf
              Console.print( "  " ).println( relative_filepath )
            endIf

            if (not dry_run)
              File.copy( src_filepath, dest_filepath )
            endIf
          endIf

        endContingent
      endForEach

      if (not keep_unused)
        printed_header = false
        forEach (filepath in dest_files)
          if (not exclude or not exclude(filepath))
            if (verbose)
              if (not printed_header)
                printed_header = true
                Console.println( "Deleting unused files in " + dest_files.base_folder )
              endIf
              Console.print( "  " ).println( dest_files.relative_filepath(filepath) )
            endIf
            if (not dry_run) delete( filepath )
            ++change_count
          endIf
        endForEach
      endIf

      return change_count

    method timestamp( filepath:String )->Real64
      filepath = expand_path( filepath )
      # Returns the last modified time since Jan 1, 1970
      native @|#if defined(_WIN32)
              |  HANDLE handle = CreateFile( (const char*)$filepath->utf8, 0, 0, NULL, OPEN_EXISTING,
              |      FILE_ATTRIBUTE_NORMAL, NULL );
              |  if (handle != INVALID_HANDLE_VALUE)
              |  {
              |    BY_HANDLE_FILE_INFORMATION info;
              |    if (GetFileInformationByHandle( handle, &info ))
              |    {
              |      RogueInt64 result = info.ftLastWriteTime.dwHighDateTime;
              |      result <<= 32;
              |      result |= info.ftLastWriteTime.dwLowDateTime;
              |      result /= 10000; // convert from Crazyseconds to Milliseconds
              |      result -= 11644473600000;  // base on Jan 1, 1970 instead of Jan 1, 1601 (?!)
              |      CloseHandle(handle);
              |      return result / 1000.0;
              |    }
              |    CloseHandle(handle);
              |  }
              |
              |#elif defined(ROGUE_PLATFORM_UNIX_COMPATIBLE)
              |  int file_id = open( (const char*)$filepath->utf8, O_RDONLY );
              |  if (file_id >= 0)
              |  {
              |    struct stat info;
              |    if (0 == fstat(file_id, &info))
              |    {
              |#if defined(__APPLE__)
              |      RogueInt64 result = info.st_mtimespec.tv_sec;
              |      result *= 1000000000;
              |      result += info.st_mtimespec.tv_nsec;
              |      result /= 1000000;  // convert to milliseconds
              |#else
              |      RogueInt64 result = (RogueInt64) info.st_mtime;
              |      result *= 1000;  // convert to ms
              |#endif
              |      close(file_id);
              |      return result / 1000.0;
              |    }
              |    close(file_id);
              |  }
              |
              |#else
              |# error Must define File.timestamp() for this OS.
              |#endif
              |return 0.0;

    method touch( filepath:String )
      filepath = shell_escaped( expand_path(filepath) )
      if (System.is_windows)
        System.run "type nul >> $" (filepath)
      else
        System.run "touch $" (filepath)
      endIf

    method with_destination( filepath:String, destination_filepath:String )->String
      # Uses console-style filename and folder rules to modify a source filepath
      # given a destination filepath, with one big difference: if the destination
      # filepath does not include a folder then the source folder from the
      # source filepath is used instead. Use an explicit "./" prefix to specify
      # the current folder as the destination folder.
      #
      #
      # File( "path1/filename1" ).with_destination( "path2/filename2" ) -> "path2/filename2"
      # File( "path1/filename1" ).with_destination( "path2" )           -> "path2/filename1"
      # File( "path1/filename1" ).with_destination( "filename2" )       -> "path1/filename2"
      # File( "filename1" ).with_destination( "path2/filename2" )       -> "path2/filename2"
      # File( "filename1" ).with_destination( "path2" )                 -> "path2/filename1"
      # File( "filename1" ).with_destination( "filename2" )             -> "filename2"
      # File( "path1" ).with_destination( "path2/filename2" )           -> "path2/filename2"
      # File( "path1" ).with_destination( "path2" )                     -> "path2/path1"
      # File( "path1" ).with_destination( "filename2" )                 -> "filename2"
      #
      # Definitions
      # - path:     .exists and .is_folder
      # - filename: not .exists or (.exists and not .is_folder)
      filepath = File.without_trailing_separator( File.expand_path(filepath) )
      destination_filepath = File.without_trailing_separator( File.expand_path(destination_filepath) )

      if (File.is_folder(destination_filepath))
        if (File.is_folder(filepath))
          # File( "path1" ).with_destination( "path2" ) -> "path2/path1"
          return join( destination_filepath, filepath )
        else
          # File( "path1/filename1" ).with_destination( "path2" ) -> "path2/filename1"
          # File( "filename1" ).with_destination( "path2" )       -> "path2/filename1"
          return join( destination_filepath, File.filename(filepath) )
        endIf

      elseIf (File.is_folder(File.folder(destination_filepath)) or File.is_folder(filepath))
        # File( "path1/filename1" ).with_destination( "path2/filename2" ) -> "path2/filename2"
        # File( "filename1" ).with_destination( "path2/filename2" )       -> "path2/filename2"
        # File( "path1" ).with_destination( "path2/filename2" )           -> "path2/filename2"
        # File( "path1" ).with_destination( "filename2" )                 -> "filename2"
        return destination_filepath

      elseIf (File.is_folder(File.folder(filepath)))
        # File( "path1/filename1" ).with_destination( "filename2" )       -> "path1/filename2"
        return join( File.folder(filepath), destination_filepath )

      else
        # File( "filename1" ).with_destination( "filename2" ) -> "filename2"
        return destination_filepath

      endIf

    method without_trailing_separator( filepath:String )->String
      # Removes trailing slash on anything except "/"
      while (filepath.count > 1 and File.ends_with_separator(filepath))
        filepath = filepath.leftmost( -1 )
      endWhile
      return filepath

    method writer( filepath:String )->FileWriter
      filepath = expand_path( filepath )
      return FileWriter( filepath )

    method append_writer( filepath:String )->FileWriter
      filepath = expand_path( filepath )
      return FileWriter( filepath, &append=true )

  PROPERTIES
    filepath : String

  METHODS
    method init( filepath:String )
      this.filepath = fix_slashes( filepath )
      this.filepath = expand_path( this.filepath )

    method abs->String [macro]
      return File.absolute_filepath( this.filepath )

    method absolute_filepath->String
      return File.absolute_filepath( this.filepath )

    method before_wildcard_pattern->String
      return File.before_wildcard_pattern( this.filepath )

    method character_writer->CharacterToUTF8ByteWriter
      return CharacterToUTF8ByteWriter( this.writer )

    method common_path( other_filepath:String )->String
      return File.common_path( this.filepath, other_filepath )

    method contains( filename:String )->Logical
      return File.contains( this.filepath, filename )

    method copy( to_filepath:String, &if_newer, &if_different, &dry_run, &verbose )->Logical
      return File.copy( this.filepath, to_filepath, &=if_newer, &=if_different, &=dry_run, &=verbose )

    method conventional_filepath->String
      return File.conventional_filepath( this.filepath )

    method crc32->Int32
      return File.crc32( this.filepath )

    method create_folder->Logical
      return File.create_folder( this.filepath )

    method delete->Logical
      return File.delete( this.filepath )

    method ends_with_separator->Logical
      return File.ends_with_separator( this.filepath )

    method ensure_ends_with_separator->this
      if (not ends_with_separator) filepath += '/'
      return this

    method esc->String
      # File.esc() is shorthand for File.conventional_filepath.shell_escaped
      return File.shell_escaped( File.conventional_filepath(this.filepath) )

    method exists->Logical
      return File.exists( this.filepath )

    method expand_path->String
      return File.expand_path( this.filepath )

    method extension->String
      return File.extension( this.filepath )

    method filename->String
      return filename( filepath )

    method fix_slashes->String
      return fix_slashes( filepath )

    method folder->String
      return File.folder( this.filepath )

    method has_byte_order_mark->Logical
      return File.has_byte_order_mark( this.filepath )

    method is_different_than( other_filepath:String )->Logical
      return File.is_different_than( this.filepath, other_filepath )

    method is_folder->Logical
      return File.is_folder( this.filepath )

    method is_hidden->Logical
      return File.is_hidden( this.filepath )

    method is_newer_than( other_filepath:String )->Logical
      return File.is_newer_than( this.filepath, other_filepath )

    method is_valid_utf8->Logical
      return File.is_valid_utf8( this.filepath )

    method listing( filepattern=null:FilePattern, &ignore_hidden, &absolute, &omit_path, &files, &folders )->String[]
      return File.listing( this.filepath, filepattern, &=ignore_hidden, &=absolute, &=omit_path, &=files, &=folders )

    method listing( filepattern=null:FilePattern, options:FileOptions )->String[]
      return File.listing( this.filepath, filepattern, options )

    method load_as_bytes->Byte[]
      return File.load_as_bytes( this.filepath )

    method load_as_string( encoding=StringEncoding.AUTODETECT:StringEncoding )->String
      return File.load_as_string( this.filepath, encoding )

    method matches_wildcard_pattern( pattern:String, &ignore_case )->Logical
      return File.matches_wildcard_pattern( this.filepath, pattern, &=ignore_case )

    method operator/( path_segment:String )->File
      if (path_segment == "..")
        if (filepath.contains('/')) return File( File.path(filepath) )
        else                        return File( File.path(absolute_filepath) )
      endIf
      return File( this.expand_path / path_segment )

    method parent( level=1:Int32 )->String
      return File.parent( this.filepath, level )

    method path->String
      return File.folder( this.filepath )

    method print_writer->PrintWriter
      return File.print_writer( this.filepath )

    method reader->FileReader
      return File.reader( this.filepath )

    method rebuilder->LineRebuilder
      return LineRebuilder( this )

    method rename( new_filepath:String )->Logical [macro]
      return File.rename( this.filepath, new_filepath )

    method rewrite( mappings:Table<<String,String>> )
      File.rewrite( this.filepath, mappings )

    method rewrite( fn1:Function(String)->String, fn2=null:Function(String)->String, fn3=null:Function(String)->String )
      File.rewrite( this.filepath, fn1, fn2, fn3 )

    method save( data:Byte[] )->Logical
      return File.save( this.filepath, data )

    method save( data:String, &bom )->Logical
      return File.save( this.filepath, data, &=bom )

    method save( data:StringBuilder, &bom )->Logical
      return File.save( this.filepath, data, &=bom )

    method shell_escaped->String
      return File.shell_escaped( this.filepath )

    method size->Int64
      return File.size( this.filepath )

    method symlink( target:String )
      File.symlink( this.filepath, target )

    method sync_from( source_folder:String, &verbose, &keep_unused, &dry_run, &missing_only )->Int32
      return File.sync_from( source_folder, this.filepath, verbose, keep_unused, dry_run, &=missing_only )

    method sync_from( source_files:Files, &verbose, &keep_unused, &dry_run, &missing_only )->Int32
      return File.sync_from( source_files, this.filepath, verbose, keep_unused, dry_run, &=missing_only )

    method timestamp->Real64
      return File.timestamp( this.filepath )

    method touch
      File.touch( this.filepath )

    method with_destination( destination_filepath:String )->String
      return File.with_destination( this.filepath, destination_filepath )

    method without_trailing_separator->String
      return File.without_trailing_separator( this.filepath )

    method writer->FileWriter
      return File.writer( this.filepath )

    method append_writer->FileWriter
      return File.append_writer( this.filepath )

    method description->String
      return filepath
endClass

class FileOptions( flags=0:Int32 ) [compound]
  ENUMERATE
    FLAG_RECURSIVE          = 1
    FLAG_OMIT_PATH          = 2
    FLAG_ABSOLUTE           = 4
    FLAG_FILES              = 8
    FLAG_FOLDERS            = 16
    FLAG_BOTH               = 24
    FLAG_IGNORE_HIDDEN      = 32
    FLAG_UNSORTED           = 64

  METHODS
    method absolute->FileOptions [macro]
      return FileOptions( this.flags | FileOptions.FLAG_ABSOLUTE )

    method ignore_hidden->FileOptions [macro]
      return FileOptions( this.flags | FileOptions.FLAG_IGNORE_HIDDEN )

    method is_ignoring_hidden->Logical [macro]
      return (this.flags & FileOptions.FLAG_IGNORE_HIDDEN)

    method keeping_files_and_folders->Logical
      local f = (flags & FLAG_BOTH)
      return (f == 0) or (f == FLAG_BOTH)

    method keeping_files->Logical
      return (flags & FLAG_FILES) or not (flags & FLAG_BOTH)

    method keeping_folders->Logical
      return (flags & FLAG_FOLDERS) or not (flags & FLAG_BOTH)

    method is_absolute->Logical [macro]
      return (this.flags & FileOptions.FLAG_ABSOLUTE)

    method files->FileOptions [macro]
      return FileOptions( this.flags | FileOptions.FLAG_FILES )

    method folders->FileOptions [macro]
      return FileOptions( this.flags | FileOptions.FLAG_FOLDERS )

    method include_path->FileOptions [macro]
      return FileOptions( this.flags & !FileOptions.FLAG_OMIT_PATH )

    method includes_path->Logical [macro]
      return ((this.flags & FileOptions.FLAG_OMIT_PATH) == 0)

    method is_limited->Logical [macro]
      return (not (this.flags & FileOptions.FLAG_RECURSIVE))

    method is_omitting_path->Logical [macro]
      return (this.flags & FileOptions.FLAG_OMIT_PATH)

    method is_recursive->Logical [macro]
      return (this.flags & FileOptions.FLAG_RECURSIVE)

    method is_relative->Logical [macro]
      return (not (this.flags & FileOptions.FLAG_ABSOLUTE))

    method is_showing_hidden->Logical [macro]
      return (not (this.flags & FileOptions.FLAG_IGNORE_HIDDEN))

    method is_unsorted->Logical [macro]
      return (this.flags & FileOptions.FLAG_UNSORTED)

    method limited->FileOptions [macro]
      return FileOptions( this.flags & !FileOptions.FLAG_RECURSIVE )

    method omit_path->FileOptions [macro]
      return FileOptions( this.flags | FileOptions.FLAG_OMIT_PATH )

    method relative->FileOptions [macro]
      return FileOptions( this.flags & !FileOptions.FLAG_ABSOLUTE )

    method recursive->FileOptions [macro]
      return FileOptions( this.flags | FileOptions.FLAG_RECURSIVE )

    method show_hidden->FileOptions [macro]
      return FileOptions( this.flags & !FileOptions.FLAG_IGNORE_HIDDEN )

    method unsorted->FileOptions [macro]
      return FileOptions( this.flags | FileOptions.FLAG_UNSORTED )

endClass

class FileReader : Reader<<Byte>>
  PROPERTIES
    filepath        : String
    count           : Int32
    position        : Int32
    buffer_position : Int32
    buffer          = Byte[](1024)
    native "FILE* fp;"

  METHODS
    method init( _filepath:String )
      if (not open(_filepath))
        throw IOError( "Unable to open $ for reading." (filepath) )
      endIf

    method on_cleanup
      close

    method close
      if (fp)
        native @|fclose( $this->fp );
                |$this->fp = 0;
      endIf

      position = 0
      count = 0

    method fp->Int64 [macro]
      return native("$this->fp")->Int64

    method has_another->Logical
      return (position < count)

    method open( filepath )->Logical
      close

      filepath = File.fix_slashes( filepath )
      filepath = File.expand_path( filepath )

      native @|$this->fp = fopen( (char*)$filepath->utf8, "rb" );
              |if ( !$this->fp ) return false;
              |
              |fseek( $this->fp, 0, SEEK_END );
              |$count = (RogueInt32) ftell( $this->fp );
              |fseek( $this->fp, 0, SEEK_SET );

      # Always close after the last byte is read, so if there are no
      # bytes then close right away.
      if (count == 0) close

      return true

    method peek->Byte
      if (position == count) return 0

      if (buffer_position == buffer.count)
        native @|$buffer->count = (RogueInt32) fread( $buffer->data->as_bytes, 1, 1024, $this->fp );
        buffer_position = 0
      endIf

      return buffer[ buffer_position ]

    method read->Byte
      if (position == count) return 0

      local result = peek

      ++position
      ++buffer_position
      if (position == count) close

      return result

    method read( result:Byte[], limit:Int32 )->Int32
      result.reserve( limit )

      # Read up to the end of our internal buffer
      local total_read = 0
      local n = (buffer.count - buffer_position).or_smaller( limit )
      if (n > 0)
        native @|memcpy( $result->data->as_bytes + $result->count, $buffer->data->as_bytes+$buffer_position, $n );
        buffer_position += n
        position += n
        total_read += n
        limit -= n
      endIf

      if (limit > 0)
        # fread directly from file
        native @|$n = (RogueInt32) fread( $result->data->as_bytes+$result->count, 1, $limit, $this->fp );
        total_read += n
        position += n
      endIf

      if (position == count) close

      result.count += total_read

      return total_read

    method remaining->Int32
      return count - position

    method reset
      if (not fp) return
      count = native( "(RogueInt32)ftell($this->fp)" )->Int32
      seek( 0 )

    method seek( pos:Int32 )
      if (not fp) return

      if (pos < 0) pos = 0
      if (pos > count) pos = count

      position = pos
      native "fseek( $this->fp, $position, SEEK_SET );"

      buffer_position = 0
      buffer.clear
endClass


class FileWriter : Writer<<Byte>>
  PROPERTIES
    filepath : String
    error    : Logical
    buffer   = Byte[](1024)
    native "FILE* fp;"

  METHODS
    method init( _filepath:String, append=false:Logical )
      if (not open(_filepath,append))
        throw IOError( "Unable to open $ for writing." (filepath) )
      endIf

    method on_cleanup
      close

    method close
      $if (target("Web")) nativeHeader extern "C" void Rogue_sync_local_storage();

      flush

      if (fp)
        native @|fclose( $this->fp ); $this->fp = 0;
        System.sync_storage
      endIf

    method flush
      if (buffer.count == 0 or not fp) return

      native @|fwrite( $buffer->data->as_bytes, 1, $buffer->count, $this->fp );
              |fflush( $this->fp );

      buffer.clear

    method fp->Int64 [macro]
      return native( "$this->fp" )->Int64

    method open( filepath, append=false:Logical )->Logical
      close
      error = false

      filepath = File.expand_path( filepath )
      filepath = File.fix_slashes( filepath )

      if (append)
        native @|$this->fp = fopen( (char*)$filepath->utf8, "ab" );
      else
        native @|$this->fp = fopen( (char*)$filepath->utf8, "wb" );
      endIf

      native "$this->error = !($this->fp);"

      return not error

    method reset
      if (not fp) return
      flush
      seek( 0 )

    method seek( pos:Int32 )
      if (not fp) return
      flush
      if (pos < 0) pos = 0
      position = pos

      native "fseek( $this->fp, 0, SEEK_SET );"

    method seek_end()
      if (not fp) return
      flush

      native "fseek( $this->fp, 0, SEEK_END );"
      position = native( "(RogueInt32)ftell( $this->fp )" )->Int32

    method write( ch:Byte )
      if (not fp) return

      ++position
      buffer.add( ch )
      if (buffer.count == 1024) flush

    method write( bytes:Byte[] )
      if (not fp) return

      flush
      position += bytes.count
      native @|fwrite( $bytes->data->as_bytes, 1, $bytes->count, $this->fp );

    method write( data:String )
      if (not fp) return

      flush
      position += data.byte_count
      native @|fwrite( $data->utf8, 1, $data->byte_count, $this->fp );

    method write( builder:StringBuilder )
      write( builder.utf8 )
endClass


class FDReader : Reader<<Byte>>
  GLOBAL METHODS
    method stderr->FDReader
      return FDReader( native("STDERR_FILENO")->Int32, &!auto_close )

    method stdin->FDReader
      return FDReader( native("STDIN_FILENO")->Int32, &!auto_close )

  PROPERTIES
    fd              : Int32
    position        : Int32
    buffer_position : Int32
    auto_close      : Logical
    buffer          = Byte[](1024)

  METHODS
    method init( fd, auto_close=true )

    method on_cleanup
      if (auto_close) close

    method buffer_more->Logical
      # Used by Process which needs to keep buffering from both the stdout and stderr of a process
      # to make sure the process doesn't get blocked.
      if (fd < 0) return false

      buffer.reserve( 1024 )
      local cur_count = buffer.count

      local n : Int32
      native @|$n = (RogueInt32) read( $fd, $buffer->data->as_bytes+$cur_count, 1024 );
      if (n <= 0)
        if (auto_close) close
        fd = -1
        return false
      endIf
      buffer.count += n

      return true

    method close
      if (fd >= 0)
        native @|close( $fd );
        fd = -1
      endIf

    method is_open->Logical
      return fd != -1

    method has_another->Logical
      return (fd >= 0 or buffer_position < buffer.count)

    method peek->Byte
      if (not has_another) return 0

      if (buffer_position == buffer.count)
        buffer.clear
        buffer_position = 0
        if (not buffer_more) return 0
      endIf

      return buffer[ buffer_position ]

    method read->Byte
      if (not has_another) return 0

      local result = peek

      ++position
      ++buffer_position

      return result

endClass


class FDWriter : Writer<<Byte>>
  GLOBAL METHODS
    method stdout->FDWriter
      return FDWriter( native("STDOUT_FILENO")->Int32, &!auto_close )

  PROPERTIES
    fd         : Int32
    auto_close : Logical
    error      : Logical
    buffer     = Byte[](1024)

  METHODS
    method init( fd, auto_close=true )

    method on_cleanup
      if (auto_close) close

    method close
      flush

      if (fd != -1)
        native @|close( $fd );
        fd = -1
      endIf

    method flush
      if (buffer.count == 0 or fd == -1) return

      native @|if (-1 == write( $fd, $buffer->data->as_bytes, $buffer->count ))
              |{
              |  if ($auto_close) close( $fd );
              |  $fd = -1;
              |}

      buffer.clear

    method write( ch:Byte )
      ++position
      buffer.add( ch )
      if (buffer.count == 1024) flush

    method write( bytes:Byte[] )
      if (fd == -1 or bytes.count == 0) return

      if (bytes.count < 1024)
        forEach (byte in bytes) write( byte )
      else
        flush
        position += bytes.count
        native @|if (-1 == write( $fd, $bytes->data->as_bytes, $bytes->count ))
                |{
                |  if ($auto_close) close( $fd );
                |  $fd = -1;
                |}
      endIf

    method write( data:String )
      if (fd == -1 or data.count == 0) return

      if (data.count < 1024)
        forEach (i in 0..<data.byte_count) write( data.byte(i) )
      else
        flush
        position += data.byte_count
        native @|if (-1 == write( $fd, $data->utf8, $data->byte_count ))
                |{
                |  if ($auto_close) close( $fd );
                |  $fd = -1;
                |}
      endIf

    method write( builder:StringBuilder )
      write( builder.utf8 )
endClass

class FilePattern( pattern:String ) [compound]
  METHODS
    method matches( st:String )->Logical
      return File.matches_wildcard_pattern( st, pattern )

    method description->String
      return pattern
endClass

class FileListing
  PROPERTIES
    folder            : String
    pattern           : String
    options           : FileOptions
    path_segments     : String[]
    pattern_segments  : String[]

    filepath_segments = String[]
    empty_segments    = String[]
    results           = String[]

    callback          : Function(String)

  METHODS
    method init( folder, pattern=null, options )
      folder  = fix(folder)
      pattern = fix(pattern)
      if (folder)  folder  = File.expand_path( folder )
      if (pattern) pattern = File.expand_path( pattern )

      if (File.exists(folder) and not File.is_folder(folder))
        # We have a single file instead of a folder
        local filepath = folder
        if (options.is_ignoring_hidden and filepath.begins_with('.')) return
        if (options.keeping_files)
          if (options.is_absolute) filepath = File.absolute_filepath( filepath )
          if (options.is_omitting_path) filepath = File.filename( filepath )
          results.add( filepath )
        endIf
        return
      endIf

      callback = this=>collect

      if (pattern is null)
        # If no pattern is specified the treat the folder as a possible pattern
        local path_segments = File.without_trailing_separator( File.fix_slashes(folder) ).split( '/' )
        local pattern_segments = String[]
        local first_wildcard_i = path_segments.locate( (p) => (p.contains('*') or p.contains('?')) )
        if (first_wildcard_i)
          forEach (p in path_segments from first_wildcard_i.value)
            pattern_segments.add( p )
          endForEach
          path_segments.discard_from( first_wildcard_i.value )
        endIf
        if (path_segments.is_empty) folder = "."
        else                        folder = path_segments.join( "/" )
        if (pattern_segments.is_empty) pattern = "*"
        else                           pattern = pattern_segments.join( "/" )
      endIf

      if (options.is_absolute) folder = File.absolute_filepath( folder )

      folder = File.ensure_ends_with_separator( folder )

      local filepath_pattern = folder + pattern
      local file_exists = false
      if (File.exists(filepath_pattern))
        if (File.is_folder(filepath_pattern))
          pattern += "/*"
        else
          # 'pattern' refers to a single file (non-folder)
          if (pattern.count > 0) file_exists = true
        endIf
      endIf

      path_segments = File.fix_slashes(folder).split( '/' )
      if (path_segments.first == ".") path_segments.remove_first
      if (path_segments.count and path_segments.last == "") path_segments.remove_last  # folder ended with "/"

      pattern_segments = File.fix_slashes(pattern).split( '/' )

      if (not file_exists) File._listing( folder, callback )

      # Process the results
      filepath_segments.[ clear, add(path_segments), add(pattern_segments) ]
      pattern = filepath_segments.join( "/" )

      # Need special handling for omitting the folder when it starts with "./"
      local adjusted_folder = folder
      if (options.is_omitting_path and folder.begins_with("./") and folder.count>2)
        adjusted_folder = folder.rightmost( -2 )
      endIf

      if (file_exists)
        local filepath = filepath_pattern
        if (options.is_omitting_path and filepath.begins_with(adjusted_folder))
          filepath = filepath.after_first( adjusted_folder )
        endIf
        results.add( filepath )
        return
      endIf

      forEach (filepath in writer=results.rewriter)
        contingent
          if (pattern.count)
            # Directories were recursed into based on the pattern, but some files could have been added
            # earlier that don't match the wildcard pattern.
            necessary (File.matches_wildcard_pattern(filepath,pattern))
          endIf

          if (options.is_omitting_path and filepath.begins_with(adjusted_folder))
            filepath = filepath.after_first( adjusted_folder )
          endIf

        satisfied
          writer.write( filepath )
        endContingent
      endForEach

      if (not options.is_unsorted)
        results.sort( (a,b) => (a.compare_to(b,&ignore_case) < 0) )
      endIf

    method collect( filename:String )
      if (options.is_ignoring_hidden and filename.begins_with('.')) return
      if (pattern_segments.count and not File.matches_wildcard_pattern(filename,pattern_segments.first)) return
      filepath_segments.[ clear, add(path_segments), add(filename) ]
      local filepath = filepath_segments.join( "/" )
      if (File.is_folder(filepath))
        if (options.keeping_folders) results.add( filepath )
        if (pattern_segments.count)
          # Implied recursion because we have more pattern segments
          path_segments.add( filename )
          if (pattern_segments.first.begins_with("**"))
            # Once we encounter `**`, switch to recursively collecting everything
            # and let the top-level filter decide which ones match
            local saved_options = options
            options = options.recursive
            local saved_segments = pattern_segments
            pattern_segments = empty_segments
            File._listing( filepath, callback )
            pattern_segments = saved_segments
            options = saved_options
          else
            local saved_segment = pattern_segments.remove_first
            File._listing( filepath, callback )
            pattern_segments.insert( saved_segment )
          endIf

          path_segments.remove_last
        elseIf (options.is_recursive)
          path_segments.add( filename )
          File._listing( filepath, callback )
          path_segments.remove_last
        endIf
      else
        if (options.keeping_files) results.add( filepath )
      endIf

    method fix( pattern:String )->String
      # Without this fix, "**Alpha*" would not match "Source/Alpha.rogue"
      if (not (pattern and pattern.contains("**"))) return pattern

      # Replace **[^/] with **/*
      local parts = pattern.split( "**/" )
      forEach (part at index in parts)
        parts[index] = part.replacing( "**", "**/*" )
      endForEach
      pattern = parts.join( "**/" )

      return pattern
endClass

