class WAV
  PROPERTIES
    channels    = WAVChannel[](2)
    format      : WAVFormat
    bit_depth   : Int32
    sample_rate : Int32

  METHODS
    method init( file:File )
      if (not WAVDecoder.decode(DataReader(file),this))
        throw Error( "Error decoding WAV file: $"(file.filepath) )
      endIf

    method init( format, bit_depth, sample_rate )

    method description->String
      return "$ channel $-bit $ $ Hz" (channels.count,bit_depth,format,sample_rate)

    method save( file:File )->Logical
      file.save( WAVEncoder.encode(this) )
      return true
endClass

class WAVDecoder [singleton]
  # http://www-mmsp.ece.mcgill.ca/Documents/AudioFormats/WAVE/WAVE.html
  # http://tiny.systems/software/soundProgrammer/WavFormatDocs.pdf
  PROPERTIES
    reader : DataReader
    wav    : WAV

  METHODS
    method decode( reader, wav )->Logical
      if (not reader.read_int32 == 0x52494646) return false  # "RIFF"
      reader.read_int32_low_high                             # chunk size
      if (not reader.read_int32 == 0x57415645) return false  # "WAVE"
      if (not reader.read_int32 == 0x666D7420) return false  # "fmt "
      if (reader.read_int32_low_high != 16) return false     # subchunk 1 size

      wav.format = WAVFormat( reader.read_int16_low_high )
      if (not wav.format.exists) return false

      local channel_count = reader.read_int16_low_high

      wav.sample_rate = reader.read_int32_low_high

      reader.read_int32_low_high  # data rate
      reader.read_int16_low_high  # block size in bytes

      wav.bit_depth = reader.read_int16_low_high

      loop channel_count
        wav.channels.add( WAVChannel(wav.format,wav.bit_depth) )
      endLoop

      while (reader.has_another)
        read_another_chunk
      endWhile

      return true

    method read_another_chunk
      local id = reader.read_int32
      local size = reader.read_int32_low_high

      which (id)
        case 0x64617461   # "data"
          local n = size / ((wav.bit_depth / 8) * wav.channels.count)
          (forEach in wav.channels).reserve( n )
          loop (n)
            (forEach in wav.channels).read( reader )
          endLoop

        case 0x464C4C52   # "FLLR"
          # A FLLR chunk aligns the read position to a multiple of 4096 minus 8
          # so that the content of the data chunk is 4K page-aligned.
          reader.skip( size )

        others            # Unknown chunk type
          #println "Unknown chunk type: $" (id_to_string(id))
          reader.skip( size )
      endWhich

    method id_to_string( id:Int32 )->String
      local a = (id:>>>:24)->Byte->Character
      local b = (id:>>>:16)->Byte->Character
      local c = (id:>>>:8)->Byte->Character
      local d = id->Byte->Character
      return "$$$$"(a,b,c,d)
endClass

class WAVEncoder [singleton]
  METHODS
    method encode( wav:WAV )->Byte[]
      local writer = DataWriter()

      writer.write_int32( 0x52494646 )  # "RIFF"
      writer.write_int32_low_high( encoded_size(wav) - 8 )
      writer.write_int32( 0x57415645 )  # "WAVE"
      writer.write_int32( 0x666D7420 )  # "fmt "

      writer.write_int32_low_high( 16 )                 # subchunk 1 size
      writer.write_int16_low_high( wav.format->Int32 )  # format

      writer.write_int16_low_high( wav.channels.count ) # channel count
      writer.write_int32_low_high( wav.sample_rate )    # sample rate

      writer.write_int32_low_high( wav.sample_rate * (wav.bit_depth/8) * wav.channels.count )
      writer.write_int16_low_high( (wav.bit_depth/8) * wav.channels.count )
      writer.write_int16_low_high( wav.bit_depth )

      #writer.write_int32( 0x464C4C52 )    # "FLLR"
      #writer.write_int32_low_high( 4044 )
      #loop (4044) writer.write(0)

      writer.write_int32( 0x64617461 )  # "data"
      local sample_count = which{ wav.channels.count:wav.channels.first.count || 0 }
      writer.write_int32_low_high( sample_count * (wav.bit_depth/8) * wav.channels.count )  # chunk size
      forEach (i in 0..<sample_count)
        (forEach in wav.channels).write( i, writer )
      endForEach

      return writer.output_bytes


    method encoded_size( wav:WAV )->Int32
      local size = 36  # header
      size += 8        # "data" chunk header
      #size += 4052     # FLLR
      if (wav.channels.count)
        size += wav.channels.count * (wav.bit_depth / 8) * wav.channels.first.count
      endIf
      return size
endClass

enum WAVFormat
  PCM        = 0x0001
  IEEE_FLOAT = 0x0003
  ALAW       = 0x0006   # 8-bit ITU-T G.711 A-law
  MULAW      = 0x0007   # 8-bit ITU-T G.711 Âµ-law
  EXTENSIBLE = 0xFFFE   # Determined by SubFormat

  METHODS
    method exists->Logical
      return categories.contains(this)
endEnum

class WAVChannel
  PROPERTIES
    format    : WAVFormat
    bit_depth : Int32
    samples   = Real32[]

  METHODS
    method init( format, bit_depth )
      which (format)
        case PCM, IEEE_FLOAT: noAction
        others:               throw Error( "WAVDecoder cannot handle format $."(format) )
      endWhich

    method add( sample:Real64 )
      samples.add( sample )

    method count->Int32
      return samples.count

    method get( index:Int32 )->Real64
      return samples[index]

    method read( reader:DataReader )
      which (format)
        case PCM
          which (bit_depth)
            case 16
              samples.add( (reader.read_int16_low_high:<<:16) / 32768.0 )
            case 24
              local sample = reader.read_int16_low_high
              sample = (reader.read->Int32 :<<: 16) | sample
              samples.add( (sample:<<:8) / 8388608.0 )
            others
              samples.add( reader.read_int32_low_high / 2147483648.0 )
          endWhich
        case IEEE_FLOAT
          samples.add( reader.read_int32_low_high.real_bits )
      endWhich

    method reserve( n:Int32 )
      samples.reserve( n )

    method write( index:Int32, writer:DataWriter )
      which (format)
        case PCM
          which (bit_depth)
            case 16
              writer.write_int16_low_high( (samples[index] * 32768)->Int32 :>>>: 16 )
            case 24
              local sample = (samples[index] * 8388608)->Int32 :>>>: 8
              writer.write_int16_low_high( sample )
              writer.write( sample:>>>:16 )
            others
              writer.write_int32_low_high( samples[index] * 2147483648.0 )
          endWhich
        case IEEE_FLOAT
          writer.write_int32_low_high( samples[index]->Real32.integer_bits )
      endWhich
endClass

