$include "Math/Degrees.rogue"
$include "Math/Radians.rogue"

# Additional specialized Math libraries are available:
#   uses Math/Matrix
#   uses Math/Quaternion

class Math
  DEFINITIONS
    E = 2.718281828459045

  GLOBAL METHODS
    $if (target("C++"))
    method acos( n:Real64 )->Real64 [macro]
      return native('acos((double)$n)')->Real64

    method asin( n:Real64 )->Real64 [macro]
      return native('asin((double)$n)')->Real64

    method atan( n:Real64 )->Real64 [macro]
      return native('atan((double)$n)')->Real64

    method atan2( y:Real64, x:Real64 )->Real64 [macro]
      return native('atan2((double)$y,(double)$x)')->Real64

    method ceiling( n:Real64 )->Real64 [macro]
      return native('ceil((double)$n)')->Real64

    method cos( n:Real64 )->Real64 [macro]
      return native('cos((double)$n)')->Real64

    method exp( n:Real64 )->Real64 [macro]
      return native('exp((double)$n)')->Real64

    method floor( n:Real64 )->Real64 [macro]
      return native('floor((double)$n)')->Real64

    method log( n:Real64 )->Real64 [macro]
      return native('log((double)$n)')->Real64

    method log2( n:Real64 )->Real64 [macro]
      return native('log2((double)$n)')->Real64

    method log10( n:Real64 )->Real64 [macro]
      return native('log10((double)$n)')->Real64

    method sin( n:Real64 )->Real64 [macro]
      return native('sin((double)$n)')->Real64

    method sqrt( n:Real64 )->Real64 [macro]
      return native('sqrt((double)$n)')->Real64

    method tan( n:Real64 )->Real64 [macro]
      return native('tan((double)$n)')->Real64

    $endIf

    method abs( n:Real64 )->Real64
      if (n >= 0) return  n
      else        return -n

    method abs( n:Int64 )->Int64
      if (n >= 0) return  n
      else        return -n

    method abs( n:Int32 )->Int32
      if (n >= 0) return  n
      else        return -n

    method lerp( a:Real64, b:Real64, progress:Real64 )->Real64
      return a + (b-a) * progress

    method lerp( a:Int32,  b:Int32,  progress:Real64 )->Int32
      return a + (b-a) * progress

    method max( a:Int32, b:Int32 )->Int32
      if (a >= b) return a
      else        return b

    method max( a:Int64, b:Int64 )->Int64
      if (a >= b) return a
      else        return b

    method max( a:Real64, b:Real64 )->Real64
      if (a >= b) return a
      else        return b

    method min( a:Int32, b:Int32 )->Int32
      if (a <= b) return a
      else        return b

    method min( a:Int64, b:Int64 )->Int64
      if (a <= b) return a
      else        return b

    method min( a:Real64, b:Real64 )->Real64
      if (a <= b) return a
      else        return b

    method mod( a:Int32, b:Int32 )->Int32
      if ((not a and not b) or b == 1) return 0

      local r = native("$a % $b")->Int32
      if ((a ~ b) < 0)
        if (r) return r + b
        else   return 0
      else
        return r
      endIf

    method mod( a:Int64, b:Int64 )->Int64
      if ((not a and not b) or b == 1) return 0

      local r = native("$a % $b")->Int64
      if ((a ~ b) < 0)
        if (r) return r + b
        else   return 0
      else
        return r
      endIf

    method mod( a:Real64, b:Real64 )->Real64
      local q = a / b
      return a - floor(q)*b

    method shift_right( value:Int32, bits:Int32 )->Int32
      if (bits <= 0) return value

      --bits
      if (bits) return ((value :>>>: 1) & 0x7fffFFFF) :>>>: bits
      else      return (value :>>>: 1) & 0x7fffFFFF

    method shift_right( value:Int64, bits:Int64 )->Int64
      if (bits <= 0) return value

      --bits
      if (bits) return ((value :>>>: 1) & 0x7fffFFFFffffFFFF) :>>>: bits
      else      return (value :>>>: 1) & 0x7fffFFFFffffFFFF
endClass
